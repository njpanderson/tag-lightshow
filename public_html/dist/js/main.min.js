webpackJsonp([0],[
/* 0 */,
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @module assets/constants
 */

/**
 * Action types
 * @private
 */
var actionTypes = exports.actionTypes = {
	UI_STATE: 'ui-state',
	ZONE_ADD_ATTACHMENT: 'zone-add-attachment',
	ZONE_EDIT_ATTACHMENT: 'zone-edit-attachment',
	ZONE_DETACH_ATTACHMENT: 'zone-detach-attachment',
	ZONE_CLEAR_ALL_ATTACHMENTS: 'zone-clear-all-attachments',
	SET_DIALOG_MODE: 'set-dialog-mode',
	SET_ACTIVE_DROPLET: 'set-active-droplet',
	SET_TOUR_STAGE: 'set-tour-stage',
	SHOW_TOOLTIP: 'show-tooltip',
	HIDE_TOOLTIP: 'hide-tooltip',
	SET_TOOLTIP_CONTENT: 'set-tooltip-content',
	COMPLETE_FIRST_DROP: 'complete-first-drop',
	COMPLETE_LAST_DROP: 'complete-last-drop',
	RESET_APP: 'reset-app'
};

/**
 * Dialog modes
 */
var dialogModes = exports.dialogModes = {
	NONE: 'none',
	GENERAL: 'general',
	EDIT_DROPLET: 'edit-droplet',
	TOUR: 'tour'
};

var uiStates = exports.uiStates = {
	INITIALISING: 'initialising',
	ACTIVE: 'active'
};

var messageCommands = exports.messageCommands = {
	RELOAD: 'reload',
	RESET: 'reset',
	DIALOG: 'dialog',
	DIALOG_CALLBACK: 'dialog-callback'
};

var errorCodes = exports.errorCodes = {
	NOT_A_DROPLET: 'A valid Droplet instance must be passed to DropZone#willAccept.'
};

var setLabels = exports.setLabels = {
	value: 'Value',
	attrs: 'Attributes',
	tagName: 'Tag name',
	innerHTML: 'HTML content'
};

/***/ }),
/* 9 */,
/* 10 */,
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var registerGeneralEvent = exports.registerGeneralEvent = function registerGeneralEvent(component, id, info) {
	var args = arguments;

	return function (event) {
		event.preventDefault();
		if (typeof component.props.onEvent === 'function') {
			component.props.onEvent.apply(component, [event, info, id].concat(Array.prototype.slice.call(args, 3)));
		}
	}.bind(this);
};

var collectRef = exports.collectRef = function collectRef(props, collection, key) {
	return function (ref) {
		if (typeof props.refCollector === 'function') {
			props.refCollector(collection, ref, key);
		} else {
			throw new Error('ref collection used but no collector has been set up for ' + collection + (key ? '/' + key : ''));
		}
	};
};

/**
 * Returns a function for validating specific keys within an object property.
 */
var validatePropKeys = exports.validatePropKeys = function validatePropKeys(require) {
	return function (props, key, component) {
		var a;

		for (a = 0; a < require.length; a += 1) {
			if (!props[key].hasOwnProperty(require[a]) && props[key][require[a]] !== undefined) {
				return new Error('Prop	`' + key + '` does not contain definition `' + require[a] + '` in ' + component + ' component.');
			}
		}
	};
};

/**
 * Escapes a string for use as a match within a regex
 * @see http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex/6969486#6969486
 */
var escapeRegExp = exports.escapeRegExp = function escapeRegExp(str) {
	return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\$&');
};

var rawMarkup = exports.rawMarkup = function rawMarkup(html) {
	return { __html: html };
};

/**
 * from https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API.
 * Checks if localStorage works.
 * (localStorage can be disabled using security policies or private browsing modes)
 */
var checkStorage = exports.checkStorage = function checkStorage(type) {
	try {
		var storage = window[type],
		    x = '__tag_storage_test__';
		storage.setItem(x, x);
		storage.removeItem(x);
		return true;
	} catch (e) {
		return false;
	}
};

/**
 * @description
 * Provides loose comparison of the keys of two objects.
 * If the value of a key is an array, the test object's key is also confirmed to be the same type.
 * If the alue of a key is an object, it is tested recursively.
 * @param {object} test - Test object
 * @param {object} expected - Expected result
 */
var structCompare = exports.structCompare = function structCompare(test, expected) {
	var result = true,
	    key;

	if ((typeof test === 'undefined' ? 'undefined' : _typeof(test)) !== 'object' || (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) !== 'object') {
		return false;
	}

	for (key in expected) {
		if (expected.hasOwnProperty(key)) {
			if (_typeof(expected[key]) === 'object') {
				if (Array.isArray(expected[key])) {
					// expected value is an array
					if (!Array.isArray(test[key])) {
						result = false;
					}
				} else {
					// expect value is an object
					if (key in test) {
						// key exists in test
						result = structCompare(test[key], expected[key]);
					} else {
						result = false;
					}
				}
			} else {
				// value is (probably) scalar
				if (!(key in test)) {
					result = false;
				}
			}
		}

		// if the result is false at any point, just break here
		if (result === false) {
			break;
		}
	}

	return result;
};

/***/ }),
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.GLYPHS = undefined;
exports.Icon = Icon;

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Icon glyphs available for use.
 * @property {string} TEXT
 * @property {string} PUZZLE_PIECE
 * @property {string} TAG
 * @property {string} COMPASS
 * @property {string} LOOP_CIRCULAR
 * @property {string} MEDIA_PLAY
 * @property {string} LIGHTBULB
 * @property {string} RESIZE_WIDTH
 */
var GLYPHS = exports.GLYPHS = {
	TEXT: __webpack_require__(307),
	PUZZLE_PIECE: __webpack_require__(304),
	TAG: __webpack_require__(306),
	COMPASS: __webpack_require__(300),
	LOOP_CIRCULAR: __webpack_require__(302),
	MEDIA_PLAY: __webpack_require__(303),
	LIGHTBULB: __webpack_require__(301),
	RESIZE_WIDTH: __webpack_require__(305)
}; /**
    * @module components/views/Icon
    */
function Icon(props) {
	var className = props.glyph.replace(/^#/, '');

	return _react2.default.createElement(
		'svg',
		{ className: 'icon', width: props.width, height: props.height },
		_react2.default.createElement('use', { xlinkHref: props.glyph, className: className })
	);
}

Icon.defaultProps = {
	width: 16,
	height: 16
};

Icon.propTypes = {
	width: _react.PropTypes.number,
	height: _react.PropTypes.number,
	glyph: _react.PropTypes.string
};

/***/ }),
/* 17 */,
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var Sprite = __webpack_require__(308);
var globalSprite = new Sprite();

if (document.body) {
  globalSprite.elem = globalSprite.render(document.body);
} else {
  document.addEventListener('DOMContentLoaded', function () {
    globalSprite.elem = globalSprite.render(document.body);
  }, false);
}

module.exports = globalSprite;


/***/ }),
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Droplet = __webpack_require__(27);

var _Droplet2 = _interopRequireDefault(_Droplet);

var _constants = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DropZone,
    drop_zone_id = 0;

/**
 * @class
 */
DropZone = function DropZone() {
	var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	var tag = arguments[1];

	this.tag = tag;
	this.id = 'drop_zone_' + ++drop_zone_id;
	this.attachmentId = data.attachmentId;
	this.maxAttachments = typeof data.maxAttachments !== 'undefined' ? data.maxAttachments : 1;
};

DropZone.prototype = {
	/**
  * Test if the DropZone instance will accept a new droplet. The test looks at the
  * maximum number of attachments and attachment eligibility based on attachmentId
  */
	willAccept: function willAccept(droplet, store) {
		var current_attachments = 0,
		    state;

		if (!(droplet instanceof _Droplet2.default)) {
			throw new Error(_constants.errorCodes.NOT_A_DROPLET);
		}

		if (store) {
			// store exists - get state (and current number of attachments)
			state = store.getState();

			if (state.zones[this.id] && state.zones[this.id].attachments) {
				current_attachments = state.zones[this.id].attachments.length;
			}
		}

		// test attachment count
		if (this.maxAttachments !== 0 && current_attachments === this.maxAttachments) {
			return false;
		}

		// test attachmentId eligibility
		if (this.attachmentId !== '*' && droplet.attachmentIds.indexOf(this.attachmentId) === -1) {
			return false;
		}

		return true;
	}
};

/**
 * Matches a drop zone within the supplied markup.
 * Can be used more than once on the same markup, and will internally increment through the data.
 */
DropZone.fetchZone = function (markup) {
	var match, zone;

	// keep looking for a valid drop zone - report on the bad ones
	while ((match = DropZone._re_zones.exec(markup)) !== null) {
		if (match !== null && (zone = DropZone.checkSyntax(match[0]))) {
			// return it
			return new DropZone({
				attachmentId: zone.attachmentId,
				maxAttachments: zone.maxAttachments
			}, match[0]);
		}
	}

	return null;
};

/**
 * Checks and reports on syntax errors within a supplied tag.
 */
DropZone.checkSyntax = function (tag) {
	var d;

	if ((d = tag.match(DropZone.syntax_re.re_structure)) !== null && d[1] !== null) {
		// check id portion
		if (!d[2] || !DropZone.syntax_re.re_id.test(d[2])) {
			return DropZone.snytaxFault(d[1], 'Invalid syntax. ID must either start with a letter and only contain' + ' letters, numbers, and the undescore (_) character, or be an asterisk (*) ' + 'to specify any attachment ID.', d[2]);
		}

		// check quantity portion
		if (d[4] && (!DropZone.syntax_re.re_qty.test(d[4]) || d[4] < 1 || d[4] > 100)) {
			return DropZone.snytaxFault(d[1], 'Invalid syntax. Quantity must be a valid number and between 1 and 100, ' + 'or the asterisk (*) character to specify unlimited up to the internal maximum.', d[4]);
		}
	} else {
		return DropZone.snytaxFault(tag, 'Invalid syntax.');
	}

	return {
		attachmentId: d[2],
		maxAttachments: d[4] === '*' ? 0 : parseFloat(d[4]) || 1
	};
};

DropZone.snytaxFault = function (str, message, char) {
	var error;

	if (char) {
		// escape % symbols
		str = str.replace('%', '%%');
		char = char.replace('%', '%%');

		// add colouring
		str = str.replace(char, '%c$&%c');

		error = 'Error with syntax in tag "' + str + '": ' + message;
		console.warn(error, 'color: red;', 'color: inherit;');
	} else {
		// basic error with no colouring
		error = 'Error with syntax in tag "' + str + '": ' + message;
		console.warn(error);
	}

	return false;
};

/**
 * Discriminating regex collection for testing drop zones with explicit syntax.
 */
DropZone.syntax_re = {
	re_structure: /^\{\{\s?(([^|\s]+)(\|([^|\s]*))?)\s?\}\}$/,
	re_id: /^[a-z*][a-z0-9_]*$/i,
	re_qty: /^[0-9*]+$/
};

/**
 * Inclusive regex for capturing individual zones with basic syntax
 */
DropZone._re_zones = /\{\{\s?(.+?)(\|(.*?))?\s?\}\}/gi;

exports.default = DropZone;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A single `editable` defiition to produce one field.
 * @typedef EditableItemDefinition
 * @property {string} type - One of 'text', 'longtext', 'dropdown', 'checkbox', or 'radio'.
 * @property {bool} [required] - Whether the field must be filled in or not.
 * @property {mixed} [value] - Either an array of values, or a single string value.
 * @property {string} [placeholder] - In the case of a text value, this will show in place of empty values.
 * @property {string} [selected] - In the case of an array value, this set the value as 'selected'.
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _PropTypes = __webpack_require__(153);

var _PropTypes2 = _interopRequireDefault(_PropTypes);

var _FormField = __webpack_require__(35);

var _FormField2 = _interopRequireDefault(_FormField);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Droplet,
    droplet_id = 0;

/**
 * Individual droplet class. Handles validation of props in a similar fashion to
 * React, but (probably) with a lot less style.
 * @class
 */
Droplet = function Droplet() {
	var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	var id = arguments[1];

	if (typeof id === 'number') {
		this.id = 'droplet_' + id;
	} else {
		this.id = 'droplet_' + ++droplet_id;
	}

	this._originalSettings = Object.deepAssign({}, settings);
	this.data = {};
	this.name = null;
	this.dropletType = null;
	this.attachmentIds = [];

	this.init();
};

Droplet.prototype = {
	/**
  * Initialisation.
  * @private
  */
	init: function init() {
		// set base properties for all droplets
		this._validateAndSet(['name', 'dropletType', 'attachmentIds', 'editable', 'guidance'], this);

		// check droplet type is valid
		switch (this.dropletType) {
			case 'element':
			case 'text':
			case 'attribute':
				this._setExtraFields();
				break;

			default:
				throw new Error('Droplet type ' + this.dropletType + ' is invalid.');
		}
	},

	/**
  * Registers type specific fields for validation.
  * @private
  */
	_setExtraFields: function _setExtraFields() {
		switch (this.dropletType) {
			case 'text':
				this._validateAndSet(['value'], this.data);
				break;

			case 'element':
				this._validateAndSet(['attrs', 'tagName', 'innerHTML'], this.data);
				break;

			case 'attribute':
				this._validateAndSet(['key', 'value'], this.data);
				break;
		}
	},

	/**
  * Validates (using the PropType functions) and sets the instance values
  * given the defined properties.
  */
	_validateAndSet: function _validateAndSet(values, context) {
		var _this = this;

		values.forEach(function (value) {
			if (Droplet.PropTypes.hasOwnProperty(value)) {
				if (Droplet.PropTypes[value](_this._originalSettings[value], value, _this._originalSettings.name || null, _this._originalSettings.dropletType || null)) {
					context[value] = _this._originalSettings[value];
				}
			} else {
				throw new Error('Droplet property "' + value + '" definition does not exist.');
			}
		});
	}
};

/**
 * Designed as a PropType validator much like string, isRequired, arrayOf etc, this
 * function specifically tests the validity of the `editable` prop and its children.
 */
Droplet._validateEditableSet = function (value, prop, droplet_name, droplet_type) {
	var attribute,
	    key,
	    attrkey,
	    prop_error = 'Error in Droplet prop ' + droplet_name + ' (' + prop + '):';

	// allow undefined values
	if (typeof value === 'undefined') {
		return true;
	}

	// testing the droplet value
	if (_PropTypes2.default._assert((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object', prop, 'Value must be an object.', droplet_name, droplet_type)) {
		// continue testing
		for (key in value) {
			// testing individual attributes
			attribute = value[key];

			// attribute is unrecognised or not an object
			if (Droplet.editableAttributes.indexOf(key) === -1 || (typeof attribute === 'undefined' ? 'undefined' : _typeof(attribute)) !== 'object') {
				throw new Error(prop_error + ' "' + key + '" is not an editable attribute or is of the wrong type');
			}

			// attribute is 'attrs', but is not an object of objects
			if (key === 'attrs') {
				for (attrkey in attribute) {
					Droplet._validateEditableItem(attrkey, attribute[attrkey], prop_error);
				}
			} else {
				Droplet._validateEditableItem(key, attribute, prop_error);
			}
		}
	}

	return true;
};

Droplet._validateEditableItem = function (item, data, error_prefix) {
	var error = error_prefix + item + ' - ';

	if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
		throw new Error(error + 'not an EditableItemDefinition object');
	}

	// check "type" exists
	if (typeof data.type === 'undefined') {
		throw new Error(error + 'doesn’t contain ‘type’ value');
	}

	// check "type" is valid
	if (Droplet.editableFieldTypes.indexOf(data.type) === -1) {
		throw new Error(error + 'invalid type attribute "' + data.type + '"');
	}

	// run checks on the editable attributes that match FormField data attributes
	_FormField2.default.validateDataAttribute(data, item, error_prefix);

	return true;
};

/**
 * Defines the possible prop types for Droplets. Some are always required.
 * @prop {string} value - Droplet 'value'. When used as an `attribute` type value, can be
 * set to `null` to define a value-less attribute.
 * @prop {string} name - Droplet name (used as a label).
 * @prop {string[]} attachmentIds - Drop zone attachment IDs.
 * @prop {string} dropletType - Droplet type. One of `element`, `text` or `attribute`.
 * @prop {object} [attrs] - Droplet attributes, in the case of the `element` type.
 * @prop {string} tagname - Droplet tagName attribute, i.e. the actual HTMLElement used.
 * Requred when type is `element`.
 * @prop {string} innerHTML - Droplet's innerHTML.
 * @prop {EditableItemDefinition} editable - Editable properties of `element` types. [add link to tutorial!].
 * @prop {string} key - Attribute keys (names) of `attribute` types.
 */
Droplet.PropTypes = {
	value: _PropTypes2.default.string.isRequired,
	name: _PropTypes2.default.string.notEmpty.isRequired,
	attachmentIds: _PropTypes2.default.arrayOf.string.isRequired,
	dropletType: _PropTypes2.default.string.isRequired,
	attrs: _PropTypes2.default.object,
	tagName: _PropTypes2.default.string.notEmpty.isRequired,
	innerHTML: _PropTypes2.default.string,
	editable: Droplet._validateEditableSet,
	key: _PropTypes2.default.string.notEmpty.isRequired,
	guidance: _PropTypes2.default.string
};

Droplet.editableAttributes = ['value', 'attrs', 'tagName', 'innerHTML'];

Droplet.editableFieldTypes = ['text', 'longtext', 'dropdown', 'checkbox', 'radio'];

exports.default = Droplet;

/***/ }),
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.dialog = exports.field = undefined;

var _react = __webpack_require__(3);

var _FormField = __webpack_require__(35);

var _FormField2 = _interopRequireDefault(_FormField);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var field = exports.field = {
	refCollector: _react.PropTypes.func,
	field: _react.PropTypes.instanceOf(_FormField2.default).isRequired,
	value: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number, _react.PropTypes.arrayOf(_react.PropTypes.string)]).isRequired,
	onChange: _react.PropTypes.func
};

var dialog = exports.dialog = {
	data: _react.PropTypes.object.isRequired,
	settings: _react.PropTypes.object.isRequired,
	refCollector: _react.PropTypes.func,
	onDialogCancel: _react.PropTypes.func,
	onDialogComplete: _react.PropTypes.func,
	onButtonClick: _react.PropTypes.func,
	lib: _react.PropTypes.object
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * FormField data object
 * @typedef FormFieldData
 * @property {boolean} [required]
 * @property {string} [label]
 * @property {mixed} [options]
 * @property {string} [placeholder]
 * @property {mixed} [value]
 * @example
 * var field = FormField('fieldname', 'dropdown', {
 * 	'label': 'Please select a value',
 * 	'options': ['Value 1', 'Value 2', 'Value 3'],
 * 	'value': 'Value 2'
 * });
 */

/**
* This class exists almost entirely for data consistency.
* @class
* @param {string} name - Field name.
* @param {string} type - Input type.
* @param {FormFieldData} data - Field data.
*/
var FormField = function FormField(name, type) {
	var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	this._setNameAndType(name, type);
	this._validateAndSet(data);
};

FormField.prototype = {
	_setNameAndType: function _setNameAndType(name, type) {
		if (typeof name !== 'string') {
			throw new Error('Invalid field name "' + name + '"');
		} else {
			this.name = name;
		}

		if (typeof type !== 'string' || FormField.validTypes.indexOf(type) === -1) {
			throw new Error('Invalid field type "' + type + '"');
		} else {
			this.type = type;
		}
	},

	_validateAndSet: function _validateAndSet(data) {
		var _data = Object.deepAssign({}, data);

		if (FormField.validateDataAttribute(_data, this.name, 'Error with FormField data attribute')) {
			this.data = _data;

			// externalise remaining options
			this.required = data.required;
			this.options = data.options;
			this.placeholder = data.placeholder;
			this.label = data.label;

			this.value = typeof data.value !== 'undefined' ? data.value : '';
		}
	}
};

/**
 * Ensures a form field's data attributes are valid
 */
FormField.validateDataAttribute = function (data, item, error_prefix) {
	var error = error_prefix + ' ' + item + ' - ';

	// check "required" is a boolean, if defined
	if (typeof data.required !== 'undefined' && typeof data.required !== 'boolean') {
		throw new Error(error + '"required" attribute isn’t a boolean true or false');
	}

	// check "options" is valid
	if (typeof data.options !== 'undefined') {
		FormField._validateOptionsSetting(data.options, error);
	}

	// check "placeholder" is valid
	if (typeof data.placeholder !== 'undefined' && typeof data.placeholder !== 'string') {
		throw new Error(error + '"placeholder" attribute isn’t a string');
	}

	// check "value" is valid
	if (typeof data.value !== 'undefined') {
		FormField._validateValueSetting(data.value, data.options, error);
	}

	// check "label" is valid
	if (typeof data.label !== 'undefined' && typeof data.label !== 'string') {
		throw new Error(error + '"label" attribute isn’t a string');
	}

	// check "maxlength" is valid
	if (typeof data.maxlength !== 'undefined' && (typeof data.maxlength !== 'number' || data.maxlength < 1)) {
		throw new Error(error + '"maxlength" attribute isn’t a number or above zero');
	}

	return true;
};

FormField._validateOptionsSetting = function (options, error_prefix) {
	var key,
	    a,
	    error = error_prefix + '"options" is of an unrecognised type';

	if (Array.isArray(options)) {
		for (a = 0; a < options.length; a += 1) {
			if (typeof options[a] !== 'string') {
				throw new Error(error);
			}
		}
	} else if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && options !== null) {
		for (key in options) {
			if (typeof key !== 'string' || typeof options[key] !== 'string') {
				throw new Error(error + ' - object values must be a simple key/value set');
			}
		}
	} else if (options === null) {
		throw new Error(error + ' - options cannot be null');
	}

	return true;
};

FormField._validateValueSetting = function (value, options, error_prefix) {
	if (!Array.isArray(value) && typeof value !== 'string' && typeof value !== 'number') {
		throw new Error(error_prefix + '"value" is of an unrecognised type');
	}

	if (typeof options !== 'undefined') {
		// validate against options
		if (Array.isArray(options) && options.indexOf(value) === -1 || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && !Array.isArray(options) && !options[value]) {
			throw new Error(error_prefix + '"value" attribute contains an option that doesn’t exist');
		}
	}
};

FormField.validTypes = ['text', 'longtext', 'dropdown', 'checkbox', 'radio'];

exports.default = FormField;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _ajax = __webpack_require__(81);

var _ajax2 = _interopRequireDefault(_ajax);

var _DropZone = __webpack_require__(26);

var _DropZone2 = _interopRequireDefault(_DropZone);

var _Droplet = __webpack_require__(27);

var _Droplet2 = _interopRequireDefault(_Droplet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Template = function Template(parent) {
	var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	this._parent = parent;
	this.settings = settings;
	this._drop_zones = {};
	this._template = [];
	this._max_zones = 100;
};

Template.prototype = {
	load: function load(url) {
		var _this = this;

		return _ajax2.default.get(url).then(function (response) {
			if (response.text) {
				_this._markup = response.text;
			}
		}).catch(function (error) {
			throw new Error(error);
		});
	},

	create: function create() {
		var markup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._markup;

		if (typeof markup === 'undefined') {
			throw new Error('Cannot call create() with no markup defined.');
		}

		// replace html with entities
		markup = Template.entities(markup);

		return this._createDropZones(markup);
	},

	_createDropZones: function _createDropZones(markup) {
		var zone,
		    counter = 0;

		// loop through markup finding drop zones
		while ((zone = _DropZone2.default.fetchZone(markup)) !== null) {
			this._drop_zones[zone.id] = zone;
			counter += 1;

			if (counter === this._max_zones) {
				throw new Error('Maximum number of zones in template reached (' + this._max_zones + ').');
			}
		}

		// loop through collected drop zones and replace tags in markup
		for (zone in this._drop_zones) {
			markup = markup.replace(this._drop_zones[zone].tag, '<span' + ' data-id="' + this._drop_zones[zone].id + '"' + ' data-attachment="' + this._drop_zones[zone].attachmentId + '">' + '</span>');
		}

		this._template = this._createTemplateArray(markup);

		return {
			drop_zones: this._drop_zones,
			template: this._template
		};
	},

	_createTemplateArray: function _createTemplateArray(markup) {
		var sandbox = document.createElement('div'),
		    data = [],
		    node,
		    a;
		sandbox.innerHTML = markup;

		for (a = 0; node = sandbox.childNodes[a]; a += 1) {
			switch (node.nodeType) {
				case Node.TEXT_NODE:
					data.push({
						type: 'text',
						content: node.textContent
					});
					break;

				case Node.ELEMENT_NODE:
					data.push({
						type: 'dropzone',
						zone: this._drop_zones[node.dataset.id]
					});
					break;
			}
		}

		return data;
	},

	renderAsHTML: function renderAsHTML(zones) {
		var _this2 = this;

		var html = '';

		this._template.forEach(function (node) {
			if (node.type === 'text') {
				// plain text node
				html += node.content;
			} else if (node.type === 'dropzone' && zones[node.zone.id]) {
				// drop zone with attachments
				zones[node.zone.id].attachments.forEach(function (attachment) {
					var droplet = _this2._parent._UI.getDropletById(attachment.droplet_id),
					    data = Object.deepAssign({}, droplet.data, attachment.data);

					html += Template.renderDroplet(droplet, data, _this2._parent._UI.getDropZoneById(node.zone.id), _this2.settings.onElementRender);
				});
			}
		});

		return html;
	}
};

Template.renderDroplet = function (droplet, data, drop_zone) {
	var is_output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

	var output;

	if (!(droplet instanceof _Droplet2.default)) {
		throw new Error('droplet argument must be a Droplet instance');
	}

	switch (droplet.dropletType) {
		case 'element':
			output = Template.renderElementDroplet(data, droplet, drop_zone, is_output);
			break;

		case 'text':
			output = Template.renderTextDroplet(data, droplet, drop_zone, is_output);
			break;

		case 'attribute':
			output = Template.renderAttributeDroplet(data, droplet, drop_zone, is_output);
			break;
	}

	return output;
};

Template.renderElementDroplet = function (data, droplet, drop_zone, is_output) {
	// TODO - make sure self-closing tags are correctly rendered
	var attrs = [],
	    markup = {},
	    attr;

	markup.open = '<' + data.tagName;

	if (data.attrs) {
		for (attr in data.attrs) {
			attrs.push(attr += '="' + Template.entities(data.attrs[attr]) + '"');
		}

		if (attrs.length) {
			markup.open += ' ' + attrs.join(' ');
		}
	}

	if (data.innerHTML || Template.voidTags.indexOf(data.tagName) === -1) {
		markup.open += '>';
		markup.innerHTML = data.innerHTML || '';
		markup.close = '</' + data.tagName + '>';
	} else {
		markup.close = '/>';
	}

	markup = Template.onElementRender(markup, droplet, drop_zone, is_output);

	return markup.open + (markup.innerHTML || '') + markup.close;
};

Template.renderTextDroplet = function (data, droplet, drop_zone, is_output) {
	var value = Template.onElementRender(data.value, droplet, drop_zone, is_output);

	return Template.entities(value);
};

Template.renderAttributeDroplet = function (data, droplet, drop_zone, is_output) {
	var markup = {
		key: data.key,
		value: data.value
	};

	markup = Template.onElementRender(markup, droplet, drop_zone, is_output);

	return markup.key + '="' + Template.entities(markup.value) + '"';
};

Template.entities = function (str) {
	return str.replace(/[\u00A0-\u9999<>\&]/gim, function (i) {
		return '&#' + i.charCodeAt(0) + ';';
	});
};

/**
 * @param {object} markup - The current markup data as set by Template#renderDroplet.
 * @param {object} droplet - The Droplet being rendered.
 * @param {object} zone - The Drop Zone the Droplet is attached to.
 * @param {bool} is_output - See below.
 * @description
 * Receives element data from Droplets as attached to Drop Zones, as well as the
 * existing markup about to be rendered. The return value should equal the `markup`
 * argument sent but can be augmented to alter rendering.
 *
 * ## The `is_output` argument.
 * Rendering can take place in two forms: Either for the template display or within as
 * tooltips as visible source code, or within the view frame as part of an outputted page.
 * The `is_output` argument will be `false` in the former case and `true` in the latter.
 */
Template.onElementRender = function () {
	return arguments[0];
};

/**
 * From https://www.w3.org/TR/html/syntax.html#writing-html-documents-elements
 * This array is a list of tag considered to be "void" and have no closing tag.
 * All other tags can (and do) have closing tags when being rendered.
 */
Template.voidTags = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'];

exports.default = Template;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _constants = __webpack_require__(8);

exports.default = {
	setUIState: function setUIState(ui_state) {
		return {
			type: _constants.actionTypes.UI_STATE,
			ui_state: ui_state
		};
	},

	resetApp: function resetApp() {
		return {
			type: _constants.actionTypes.RESET_APP
		};
	},

	completeFirstDrop: function completeFirstDrop() {
		return {
			type: _constants.actionTypes.COMPLETE_FIRST_DROP
		};
	},

	completeLastDrop: function completeLastDrop() {
		return {
			type: _constants.actionTypes.COMPLETE_LAST_DROP
		};
	},

	setActiveDroplet: function setActiveDroplet(droplet_id) {
		return {
			type: _constants.actionTypes.SET_ACTIVE_DROPLET,
			droplet_id: droplet_id
		};
	},

	setDialogMode: function setDialogMode(mode) {
		var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var onDialogComplete = arguments[2];
		var onDialogCancel = arguments[3];

		return {
			type: _constants.actionTypes.SET_DIALOG_MODE,
			mode: mode,
			data: data,
			onDialogComplete: onDialogComplete,
			onDialogCancel: onDialogCancel
		};
	},

	zoneAddAttachment: function zoneAddAttachment(id, droplet_id, attached, data) {
		return {
			type: _constants.actionTypes.ZONE_ADD_ATTACHMENT,
			id: id,
			droplet_id: droplet_id,
			attached: attached,
			data: data
		};
	},

	zoneEditAttachment: function zoneEditAttachment(id, attachment_index, data) {
		return {
			type: _constants.actionTypes.ZONE_EDIT_ATTACHMENT,
			id: id,
			attachment_index: attachment_index,
			data: data
		};
	},

	zoneDetachAttachment: function zoneDetachAttachment(id, attachment_index) {
		return {
			type: _constants.actionTypes.ZONE_DETACH_ATTACHMENT,
			id: id,
			attachment_index: attachment_index
		};
	},

	zoneClearAllAttachments: function zoneClearAllAttachments() {
		return {
			type: _constants.actionTypes.ZONE_CLEAR_ALL_ATTACHMENTS
		};
	},

	setTourStage: function setTourStage(stage) {
		return {
			type: _constants.actionTypes.SET_TOUR_STAGE,
			stage: stage
		};
	},

	showTooltip: function showTooltip(attachment) {
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		return {
			type: _constants.actionTypes.SHOW_TOOLTIP,
			attachment: attachment,
			options: options
		};
	},

	hideTooltip: function hideTooltip() {
		return {
			type: _constants.actionTypes.HIDE_TOOLTIP
		};
	},

	setTooltipContent: function setTooltipContent(title, content, iconGlyph) {
		return {
			type: _constants.actionTypes.SET_TOOLTIP_CONTENT,
			content: content,
			title: title,
			iconGlyph: iconGlyph
		};
	}
};

/***/ }),
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var Communicator = function Communicator(id, origin) {
	var callbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	if (typeof id !== 'string') {
		throw new Error('Please choose a string-based ID for the guest.');
	}

	if (typeof origin !== 'string') {
		throw new Error('Please choose a string-based origin address.');
	}

	this._settings = {
		name: 'tag-comm-data'
	};

	this._guests = {};
	this._queue = {};
	this.id = id;
	this.message_index = 0;

	this._origin = origin;
	this._callbacks = Object.assign({
		message: null
	}, callbacks);

	window.addEventListener('message', this._receiveMessage.bind(this), false);

	this._sendPing();
};

Communicator.prototype = {
	/**
  * Attempt to ping source window
  */
	_sendPing: function _sendPing(node) {
		var ping = this._createMessage(null, {
			ping: this.id
		});

		if (!node) {
			if (window.opener) {
				node = window.opener;
			} else if (window.top !== window) {
				node = window.top;
			}
		}

		if (node) {
			this._post(node, ping);
		}
	},

	_sendPong: function _sendPong(node) {
		var pong = this._createMessage(null, {
			pong: this.id
		});

		this._post(node, pong);
	},

	/**
  * Registers a single guest for communication purposes.
  * @param {string} id - Guest ID. Used when sending messages.
  * @param {mixed} dest - Destination node.
  */
	registerGuestAddress: function registerGuestAddress(id, dest) {
		if (typeof dest === 'undefined') {
			throw new Error('Cannot register address for ' + id + '. ' + 'A guest address DOM node, window or frame must be defined.');
		}

		if (!('postMessage' in dest)) {
			throw new Error('Communicator cannot send messages to destination. Please choose an HTMLElement ' + 'that supports the postMessage method');
		}

		if (typeof id !== 'string') {
			throw new Error('Please choose a string-based ID for the guest.');
		}

		// register local address for guest
		this._setGuestData(id, {
			id: id,
			node: dest
		});

		// start timer
		if (this.timer) {
			window.clearInterval(this.timer);
		}
	},

	/**
  * Sets or replaces the guest data.
  * @param {string} id - Guest ID.
  * @param {object} data - Guest data.
  * @private
  */
	_setGuestData: function _setGuestData(id, data) {
		if (!this._guests[id]) {
			this._guests[id] = {
				live: false,
				node: null
			};
		}

		Object.assign(this._guests[id], data);
	},

	/**
  * @param {string} to - Guest ID, as stored.
  * @param {mixed} message - Any JS compatible data to send as a message.
  * @param {string} id - Add a message ID to allow the recipient to prevent race conditions.
  * @description
  * Sends a message to the defined guest.
  * If no ID is defined, one will be generated.
  * @returns {string} The ID of the message as defined or generated.
  */
	send: function send(to, message) {
		var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

		var guest = this._getGuestById(to);

		id = id || this._generateSendId(to);

		if (guest && guest.live) {
			// post message immediately
			this._post(to, this._createMessage(message, {}, id));
		} else {
			// queue message for posting
			this._addToQueue(to, message, id);
		}

		return id;
	},

	/**
  * Adds a message to the local 'outbox' for the guest (by ID).
  */
	_addToQueue: function _addToQueue(to, message, id) {
		if (!this._queue[to]) {
			this._queue[to] = [];
		}

		this._queue[to].push({
			message: message,
			id: id
		});
	},

	_sendQueue: function _sendQueue(to) {
		var a;

		if (this._queue[to] && this._guests[to]) {
			// send messages in the order they were queued
			for (a = 0; a < this._queue[to].length; a += 1) {
				this._post(this._guests[to].node, this._createMessage(this._queue[to][a].message, {}, this._queue[to][a].id));
			}

			// clear queue for this recipient
			this._queue[to] = [];
		}
	},

	/**
  * Gets a communicator guest by its ID, or returns `null`.
  * @returns {mixed} Guest data, or `null`.
  * @private
  */
	_getGuestById: function _getGuestById(id) {
		return this._guests[id] || null;
	},

	/**
  * Get a guest by known node (i.e. that registered in `this._guests`)
  * @private
  */
	_getGuestByNode: function _getGuestByNode(node) {
		var id;

		for (id in this._guests) {
			if (this._guests.hasOwnProperty(id) && this._guests[id].node === node) {
				return this._getGuestById(id);
			}
		}

		return null;
	},

	/**
  * Actually posts the message to the destination.
  * @param {string} to - Guest ID.
  * @param {mixed} message - Any JS compatible data to send as a message.
  * @private
  */
	_post: function _post(to, message) {
		var guest, node;

		if (typeof to === 'string') {
			guest = this._getGuestById(to);

			if (!guest.node) {
				throw new Error('Cannot communicate with guest "' + to + '". Has its Node address been registered?');
			}

			node = guest.node;
		} else {
			node = to;
		}

		node.postMessage(message, this._origin);
	},

	/**
  * Invoked when a live message is received.
  * @private
  */
	_receiveMessage: function _receiveMessage(event) {
		var origin = event.origin || event.originalEvent.origin,
		    source = event.source || event.originalEvent.source,
		    message = event.data,
		    guest;

		if (origin !== location.origin) return;

		if ((message.ping || message.pong) && this._getGuestByNode(source)) {
			// received a ping/pong from valid source
			guest = message.ping || message.pong;

			this._setGuestLive(guest);
			this._sendQueue(guest);

			if (message.ping) {
				// pong back a ping (don't pong a pong or we'll be here forever)
				this._sendPong(source);
			}
		}

		if (this._callbacks.message && message.originalMessage) {
			this._callbacks.message(message.originalMessage, message.id);
		}
	},

	_setGuestLive: function _setGuestLive(id) {
		this._setGuestData(id, {
			live: true
		});
	},

	_createMessage: function _createMessage(message, data, id) {
		return Object.assign({}, data, {
			host: this.id,
			id: id,
			originalMessage: message
		});
	},

	_generateSendId: function _generateSendId(prefix) {
		if (window.performance && 'now' in window.performance) {
			return prefix + '-xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
				var r = (window.performance.now() + Math.random() * 16) % 16 | 0;
				return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
			});
		} else {
			return prefix + '-' + this.message_index++;
		}
	}
};

exports.default = Communicator;

/***/ }),
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _constants = __webpack_require__(8);

// default state for...
exports.default = {
	// general application
	app: {
		ui_state: _constants.uiStates.INITIALISING,
		active: false,
		first_valid_drop: false,
		last_valid_drop: false
	},

	// active zones and current attachments
	zones: {},

	// UI states - do not persist
	UI: {
		// the currently active dialog and its data
		dialog: {
			mode: _constants.dialogModes.NONE,
			data: null,
			onDialogComplete: null,
			onDialogCancel: null,
			overlay: true,
			attachment: null,
			id: ''
		},

		// the currently active droplet (i.e. the one that will be "dropped" when a
		// drop zone is next clicked)
		active_droplet_id: '',

		// stage the tour is at (from 1 - dialogs.tour.length)
		tour_stage: null,

		tooltip: {
			show: false,
			attachment: null,
			options: null,
			title: '',
			iconGlyph: '',
			content: ''
		}
	}
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = createDialogs;
var tourDialogModifiers = {
	arrow: {
		element: '.arrow'
	}
};

var tourButtons = {
	proceed: [{
		type: 'cancel',
		label: 'Close'
	}, {
		type: 'submit',
		label: 'Continue'
	}],
	try_it: [{
		type: 'cancel',
		label: 'Close'
	}, {
		type: 'pause',
		label: 'Try it out'
	}, {
		type: 'submit',
		label: 'Continue'
	}],
	end: [{
		type: 'submit',
		label: 'Finish tour'
	}]
};

function createDialogs(settings) {
	return {
		intro: {
			title: 'Welcome to <span class="logo">&lt;<b>Tag</b>&gt;</span>!',
			message: ['Tag is an app designed to explain how web pages are constructed.', 'If you are new to tag, you can use the Tour button in the toolbar.', 'Otherwise, just click “OK” and get creating!']
		},
		resetState: {
			title: 'Reset Tag',
			message: ['Are you sure you want to go back to the beginning?', 'All of your current work will be cleared.'],
			buttons: [{
				type: 'cancel',
				label: 'Cancel'
			}, {
				type: 'submit',
				className: 'danger',
				label: 'Clear my work'
			}]
		},
		dropletBadPlacement: {
			title: 'Oops!',
			message: ['Almost there, but the Droplet you’ve chosen doesn’t go here.', 'Try again and see if you can find the correct place.', 'Remember, the target will be <span class="drop-zone accept"><span class="target"><b>green</b></span></span> when you can place the Droplet.']
		},
		firstDropletDrop: function firstDropletDrop(droplet_output) {
			return {
				title: 'Well done!',
				message: ['<code>' + droplet_output + '</code>', 'You’ve placed your <b>very first</b> Droplet onto the Template. Hurrah!', 'Press the <span class="pseudo-button run"><svg class="icon" width="14" height="14"><use xlink:href="#icon-media-play"></use></svg>Run</span> button to see how it looks.']
			};
		},
		lastDropletDrop: {
			title: 'Well done!',
			message: ['You’ve placed at <b>least one Droplet</b> on every target in the template. Yippee!', 'Why not try the <span class="pseudo-button run"><svg class="icon" width="14" height="14"><use xlink:href="#icon-media-play"></use></svg>Run</span> button to see how it looks?']
		},
		tour: [{
			title: 'Welcome to <span class="logo">&lt;<b>Tag</b>&gt;</span>!',
			message: ['Tag is an app designed to explain how web pages are constructed.', 'The idea is simple: Place <b>elements</b> onto the <b>template</b>, and then use the ' + '<span class="pseudo-button run"><svg class="icon" width="14" height="14"><use xlink:href="#icon-media-play"></use></svg>Run</span> button to see how the page will look in the <b>view</b>.', 'Some parts of the tour will let you try things out before moving on. If you want to, use the <span class="pseudo-button">Try it out</span> button when you see it, then use <span class="pseudo-button"><svg class="icon" width="14" height="14"><use xlink:href="#icon-compass"></use></svg>Continue tour</span> to go back to the tour.'],
			buttons: tourButtons.proceed
		}, {
			title: 'The template',
			message: ['This is the template. It contains the source code for your web page, and is where you’ll add snippets of code.', 'Add elements to the <span class="drop-zone"><span class="target"><b>' + settings.dropZone.label + '</b></span></span> targets to construct the page.'],
			overlay: false,
			attachment: {
				selector: '.main > .template',
				options: {
					placement: 'right',
					modifiers: tourDialogModifiers
				}
			},
			buttons: tourButtons.proceed
		}, {
			title: 'The pallet',
			message: ['This is the pallet. It contains Droplets, which can be added to the template above.'],
			overlay: false,
			attachment: {
				selector: 'section.pallet',
				options: {
					placement: 'top',
					modifiers: tourDialogModifiers
				}
			},
			buttons: tourButtons.proceed
		}, {
			title: 'Droplet',
			message: ['This is a Droplet. It can be added to the template above.', 'Certain <span class="drop-zone"><span class="target"><b>' + settings.dropZone.label + '</b></span></span> targets only allow certain Droplets to be added to them.', 'When a target goes green <span class="drop-zone accept"><span class="target"><b>' + settings.dropZone.label + '</b></span></span>, it means it can accept the Droplet you have chosen, or <span class="drop-zone decline"><span class="target"><b>' + settings.dropZone.label + '</b></span></span> if the Droplet can’t be placed there.', 'Click on a Droplet and then click on one of the <span class="drop-zone"><span class="target"><b>' + settings.dropZone.label + '</b></span></span> targets in the template to attach it.'],
			overlay: false,
			attachment: {
				selector: 'section.pallet .droplet:first-child',
				options: {
					placement: 'top',
					modifiers: tourDialogModifiers
				}
			},
			buttons: tourButtons.try_it
		}, {
			title: 'The view',
			message: ['This is the view. It will show you how the page looks after running the code!', 'Use the <span class="pseudo-button run"><svg class="icon" width="14" height="14"><use xlink:href="#icon-media-play"></use></svg>Run</span> button to update the view'],
			overlay: false,
			attachment: {
				selector: 'section.view',
				options: {
					placement: 'left',
					modifiers: tourDialogModifiers
				}
			},
			buttons: tourButtons.try_it
		}, {
			title: 'All done!',
			message: ['Once you’ve used the <span class="pseudo-button run"><svg class="icon" width="14" height="14"><use xlink:href="#icon-media-play"></use></svg>Run</span> button, the view has updated and your last change should now be showing here!'],
			overlay: false,
			attachment: {
				selector: 'section.view',
				options: {
					placement: 'left',
					modifiers: tourDialogModifiers
				}
			},
			buttons: tourButtons.finish
		}]
	};
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Icon = __webpack_require__(16);

var _utils = __webpack_require__(11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DialogHeading = function DialogHeading(props) {
	var notes = [],
	    icon;

	props.notes.forEach(function (note, index) {
		return notes.push(_react2.default.createElement('p', { key: 'note-' + index,
			dangerouslySetInnerHTML: (0, _utils.rawMarkup)(note) }));
	});

	if (props.iconGlyph) {
		icon = _react2.default.createElement(_Icon.Icon, { glyph: props.iconGlyph });
	}

	return _react2.default.createElement(
		'div',
		{ className: props.className },
		_react2.default.createElement(
			'h2',
			null,
			icon,
			_react2.default.createElement('span', { dangerouslySetInnerHTML: (0, _utils.rawMarkup)(props.title) })
		),
		notes
	);
};

DialogHeading.propTypes = {
	iconGlyph: _react.PropTypes.string,
	className: _react.PropTypes.string.isRequired,
	title: _react.PropTypes.string.isRequired,
	notes: _react.PropTypes.arrayOf(_react.PropTypes.string)
};

exports.default = DialogHeading;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Fieldset = __webpack_require__(143);

var _Fieldset2 = _interopRequireDefault(_Fieldset);

var _Button = __webpack_require__(137);

var _Button2 = _interopRequireDefault(_Button);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @typedef FormOnSubmit
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @param {object} formValues - the current values of the form elements, as an object.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * @typedef FormFieldSets
 * @description
 * An array of fieldsets — each item of which contains an object defining a
 * single fieldset. See {@link FormFieldset}.
 * @example
 * var fieldsets = [
 * 	{@link FormFieldSet}...
 * ];
 */

/**
 * An object defining a single fieldset.
 * @typedef FormFieldSet
 * @property {string} key - Unique key value.
 * @property {string} legend - Legend label.
 * @property {object} fields - Fields within the fieldset. The keys of which
 * should represent the name of the field, with the values being one of
 * {@link FormField} each.
 * @example
 * var fieldset = [
 * 	{@link FormField}...
 * ]
 */

/**
 * @typedef FormButton
 * @property {string} type - Either 'cancel', 'submit' or a custom type.
 * @property {string} label - Button label.
 * @property {object} data - Data sent as `data` to the form onSubmit prop.
 * @property {object} className - Extra class name(s) for the button.
 */


/**
 * @description
 * Takes a form specification and produces an HTML form.
 * See {@link Form.propTypes} for more information
 */
var Form = function (_Component) {
	_inherits(Form, _Component);

	function Form(props) {
		_classCallCheck(this, Form);

		var formValues = {};

		var _this = _possibleConstructorReturn(this, (Form.__proto__ || Object.getPrototypeOf(Form)).call(this, props));

		_this.ui = {
			refs: {
				buttons: {},
				fields: {}
			}
		};

		// set default state for fields based on original values
		if (_this.props.fieldSets) {
			_this.props.fieldSets.forEach(function (set) {
				formValues[set.key] = {};

				set.fields.forEach(function (field) {
					return formValues[set.key][field.name] = field.value;
				});
			});
		}

		// set default form value state
		_this.state = {
			formValues: formValues
		};

		// bind functions for events
		_this.elementChange = _this.elementChange.bind(_this);
		return _this;
	}

	_createClass(Form, [{
		key: 'valueSet',
		value: function valueSet(values, node) {
			var nodes = [],
			    key;

			if (Array.isArray(values)) {
				values.forEach(function (value) {
					nodes.push(_react2.default.createElement(
						'node',
						{ value: value },
						value
					));
				});
			} else if ((typeof values === 'undefined' ? 'undefined' : _typeof(values)) === 'object') {
				for (key in values) {
					nodes.push(_react2.default.createElement(
						'node',
						{ value: key },
						values[key]
					));
				}
			}

			return nodes;
		}
	}, {
		key: 'fieldSets',
		value: function fieldSets() {
			var _this2 = this;

			var output = [];

			if (this.props.fieldSets) {
				this.props.fieldSets.forEach(function (set) {
					var key = 'fieldset-' + set.key;

					output.push(_react2.default.createElement(_Fieldset2.default, {
						key: key,
						refCollector: _this2.collectFieldRef.bind(_this2),
						set: set.key,
						fields: set.fields,
						legend: set.legend,
						onFieldUpdate: _this2.elementChange
					}));
				});
			}

			return output;
		}
	}, {
		key: 'elementChange',
		value: function elementChange(set, name, value, values_state) {
			var sets = Object.assign({}, this.state.formValues);

			sets[set] = values_state;

			this.setState({
				formValues: sets
			});
		}
	}, {
		key: 'componentOnSubmit',
		value: function componentOnSubmit(proxy_event) {
			this.onSubmit(proxy_event, 'submit');
		}
	}, {
		key: 'onSubmit',
		value: function onSubmit(event, button, button_data) {
			if (event) {
				event.preventDefault();
			}

			this.props.onSubmit(this.state.formValues, button, button_data);
		}

		/**
   * Return a function to collect Button component DOM references.
   */

	}, {
		key: 'collectButtonRef',
		value: function collectButtonRef(key) {
			return function (ref) {
				this.ui.refs.buttons[key] = ref;
			}.bind(this);
		}

		/**
   * @description
   * Collect a reference to a field. Each field component uses two arguments
   * for their refCollector prop (unlike the usual one):
   * 1. An identifying key
   * 2. The DOM reference
   */

	}, {
		key: 'collectFieldRef',
		value: function collectFieldRef(key, ref) {
			this.ui.refs.fields[key] = ref;
		}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this3 = this;

			var a, b, key;

			if ('ontouchstart' in window) {
				// if it's a touch device, it'll likely have an on-screen keyboard
				// which could get in the way of the dialog opening and cause UX issues.
				return;
			}

			// handle focusing of the first field (or button) in the form
			if (this.props.fieldSets && this.props.fieldSets.length) {
				// highlight first collected field
				for (a = 0; a < this.props.fieldSets.length; a += 1) {
					for (b = 0; b < this.props.fieldSets[a].fields.length; b += 1) {
						key = 'field-' + this.props.fieldSets[a].fields[b].name;

						if (this.props.fieldSets[a].fields[b].type !== 'hidden' && this.ui.refs.fields[key]) {
							this.ui.refs.fields[key].focus();
							a = this.props.fieldSets.length;
							break;
						}
					}
				}
			} else {
				// highlight first collected button
				this.props.buttons.forEach(function (button, index) {
					var key = 'button-' + index;

					if (_this3.ui.refs.buttons[key] && button.type === 'submit') {
						_this3.ui.refs.buttons[key].focus();
					}
				});
			}
		}

		/**
   * @description
   * Iterate through the `buttons` object in `props` and produce a list of Button
   * components.
   */

	}, {
		key: 'getButtons',
		value: function getButtons() {
			var _this4 = this;

			var buttons = [];

			if (this.props.buttons && this.props.buttons.length) {
				this.props.buttons.forEach(function (button, index) {
					var key = 'button-' + index,
					    click_function;

					click_function = function (component, key) {
						return function (event) {
							if (component.ui.refs.buttons && component.ui.refs.buttons[key]) {
								component.ui.refs.buttons[key].blur();
								component.props.onButtonClick(component.ui.refs.buttons[key], event);
							}

							if (button.type === 'cancel') {
								// cancel button
								component.props.onCancel();
							} else if (button.type !== 'submit') {
								// anything except submit
								component.onSubmit(null, button.type, button.data);
							}
						};
					}(_this4, key, button.onClick);

					buttons.push(_react2.default.createElement(_Button2.default, {
						key: key,
						refCollector: _this4.collectButtonRef(key),
						type: button.type,
						label: button.label,
						className: button.className,
						onClick: click_function }));
				});
			}

			return buttons;
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'form',
				{ action: '', onSubmit: this.componentOnSubmit.bind(this) },
				_react2.default.createElement(
					'div',
					{ className: 'fields' },
					this.fieldSets()
				),
				_react2.default.createElement(
					'fieldset',
					{ className: 'buttons' },
					this.getButtons()
				)
			);
		}
	}]);

	return Form;
}(_react.Component);

/**
 * @property {function} onCancel - invoked when the form is cancelled
 * @property {FormOnSubmit} onSubmit - invoked when the form is submitted
 * @property {FormFieldSets} fieldSets - fieldsets for display
 */


Form.propTypes = {
	onButtonClick: _react.PropTypes.func.isRequired,
	onCancel: _react.PropTypes.func,
	onSubmit: _react.PropTypes.func,
	fieldSets: _react.PropTypes.arrayOf(_react.PropTypes.shape({
		key: _react.PropTypes.string,
		legend: _react.PropTypes.string,
		fields: _react.PropTypes.array
	})),
	buttons: _react.PropTypes.array
};

Form.defaultProps = {
	onCancel: function onCancel() {},
	onSubmit: function onSubmit() {}
};

exports.default = Form;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _utils = __webpack_require__(11);

var JSON = JSON || window.JSON;
var store = window.localStorage || window.sessionStorage;

var Storage = function Storage(prefix) {
	this.prefix = prefix + '_';
	this.storageEnabled = (0, _utils.checkStorage)('localStorage');
};

Storage.prototype = {
	get: function get(key, default_value) {
		var value;

		if (this.storageEnabled && (value = store.getItem(this.prefix + key)) !== null) {
			try {
				value = JSON.parse(value);
				return value;
			} catch (e) {
				return default_value;
			}
		}

		return default_value;
	},

	set: function set(key, value) {
		if (this.storageEnabled) {
			store.setItem(this.prefix + key, JSON.stringify(value));
		}
	}
};

exports.default = Storage;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(71);

var _promise2 = _interopRequireDefault(_promise);

var _superagent = __webpack_require__(74);

var _superagent2 = _interopRequireDefault(_superagent);

var _superagentPromise = __webpack_require__(73);

var _superagentPromise2 = _interopRequireDefault(_superagentPromise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _superagentPromise2.default)(_superagent2.default, _promise2.default);

/***/ }),
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * The built in HTMLElement type. Used to define DOM compatible nodes of Element type.
                                                                                                                                                                                                                                                                               * @typedef HTMLElement
                                                                                                                                                                                                                                                                               */

/**
 * React's internal simulated event type. Exposes further properties for ease of development.
 * @typedef ReactEvent
 */

/**
 * @callback DialogPromise
 * @param {DialogData} dialog - Data from the dialog.
 */

/**
 * @typedef DialogData
 * @property {object} data - Data from any form elements within the dialog.
 * @property {string} action - Action string. 'submit', 'cancel' or a custom action, if set.
 * @property {object} action_data - Data specific to the special action, if set.
 */

var _redux = __webpack_require__(33);

__webpack_require__(156);

__webpack_require__(294);

var _UI = __webpack_require__(155);

var _UI2 = _interopRequireDefault(_UI);

var _Icon = __webpack_require__(16);

var _Droplet = __webpack_require__(27);

var _Droplet2 = _interopRequireDefault(_Droplet);

var _ajax = __webpack_require__(81);

var _ajax2 = _interopRequireDefault(_ajax);

var _Template = __webpack_require__(36);

var _Template2 = _interopRequireDefault(_Template);

var _Storage = __webpack_require__(80);

var _Storage2 = _interopRequireDefault(_Storage);

var _utils = __webpack_require__(11);

var _actions = __webpack_require__(37);

var _actions2 = _interopRequireDefault(_actions);

var _reducers = __webpack_require__(157);

var _reducers2 = _interopRequireDefault(_reducers);

var _defaults = __webpack_require__(125);

var _defaults2 = _interopRequireDefault(_defaults);

var _defaultState = __webpack_require__(76);

var _defaultState2 = _interopRequireDefault(_defaultState);

var _dialogs = __webpack_require__(77);

var _dialogs2 = _interopRequireDefault(_dialogs);

var _constants = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Main application wraper.
 * @param {AppDefaults} settings - Settings object.
 * @class
 */
var App = function App() {
	var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	this.settings = Object.deepAssign({}, App.defaults, settings);
	this._init();
	this.dialogs = (0, _dialogs2.default)(this.settings);
	this.storage = new _Storage2.default('tag_app');

	// set Template.onElementRender to settings, if defined
	if (settings.onElementRender) {
		_Template2.default.onElementRender = settings.onElementRender.bind(this);
	}

	// bind hideDialog to this context in case its used as a direct argument within a promise
	this.hideDialog = this.hideDialog.bind(this);
};

App.prototype = {
	_init: function _init() {
		this._refs = {
			ui: {
				app: document.querySelector('.app')
			},
			mounted: {},
			components: {}
		};

		// app data store (not stateful)
		this._data = {
			template: '',
			pallet: []
		};

		// templates module
		this._template = new _Template2.default(this, this.settings);
	},

	/**
  * Load the template/pallet data and activate Tag.
  */
	load: function load(url, pallet) {
		var _this = this;

		return this._template.load(url).then(function () {
			// load the HTML template and create it
			var data = _this._template.create();

			_this._data.drop_zones = data.drop_zones;
			_this._data.template = data.template;
		}).then(function () {
			// load the JSON based pallet data
			return _this._loadPallet(pallet);
		}).then(function () {
			var stored_state = _this.storage.get('state', undefined);

			if (stored_state !== undefined && (typeof stored_state === 'undefined' ? 'undefined' : _typeof(stored_state)) === 'object') {
				// stored state exists - reset UI (which is non-persistant)
				stored_state.UI = {};
				stored_state.UI = _defaultState2.default.UI;

				if (!_this._validate_state(stored_state)) {
					// reset stored_state back to undefined if  it's not valid
					stored_state = undefined;
				}
			} else {
				// reset back to undefined
				stored_state = undefined;
			}

			// app state store - default
			_this._store = (0, _redux.createStore)(_reducers2.default, stored_state, typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__({
				// black list all session-based non persistant actions
				// (some of which contain unserialisable objects)
				actionsBlacklist: [_constants.actionTypes.SET_ACTIVE_DROPLET, _constants.actionTypes.SET_DIALOG_MODE, _constants.actionTypes.SET_TOUR_STAGE, _constants.actionTypes.SHOW_TOOLTIP, _constants.actionTypes.HIDE_TOOLTIP, _constants.actionTypes.SET_TOOLTIP_CONTENT]
			}));

			// activate the UI
			_this._UI = new _UI2.default(_this, _this.settings, _this._refs, _this._data, _this._store, _this._template);

			// render
			_this._UI.render();

			// set active state
			_this._store.dispatch(_actions2.default.setUIState(_constants.uiStates.ACTIVE));
		}).catch(function (error) {
			throw error;
		});
	},

	/**
  * Load the pallet data
  * @private
  */
	_loadPallet: function _loadPallet(url) {
		var _this2 = this;

		return _ajax2.default.get(url).then(function (response) {
			var pallet, item;

			try {
				pallet = JSON.parse(response.text);
			} catch (e) {
				return Promise.reject(new Error('Pallet data at file "' + url + '"" could not be parsed.' + ' is it valid JSON?'));
			}

			if (Array.isArray(pallet) && pallet.length) {
				for (item in pallet) {
					_this2._data.pallet.push(new _Droplet2.default(pallet[item]));
				}
			} else {
				throw new Error('Looks like the pallet at path ' + url + ' isn’t a valid array in JSON format.');
			}
		}).catch(function (error) {
			throw error;
		});
	},

	/**
  * Validates a state object by comparing it to the default state.
  * @private
  */
	_validate_state: function _validate_state(state) {
		return (0, _utils.structCompare)(state, _defaultState2.default);
	},

	/**
  * Displays a dialog message with optional confirmations
  * @param {string} title - Title of the dialog.
  * @param {array|HTMLElement} message - Message to display.
  * @param {array} [buttons] - Buttons to show. Defaults to a single "OK" button.
  * @returns {DialogPromise} a Promise, the resolve/reject methods of which will denote
  * completion or cancellation of the dialog. Custom button events will not complete
  * the promise.
  */
	dialog: function dialog(title, message) {
		var buttons = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

		this._requireUI();

		if (!Array.isArray(message)) {
			message = [message];
		}

		return this._UI._showDialog(_constants.dialogModes.GENERAL, {
			title: title,
			message: message,
			buttons: buttons
		});
	},

	/**
  * Hides whichever active dialog is currently open.
  */
	hideDialog: function hideDialog() {
		this._UI._hideDialog.apply(this._UI);
	},

	/**
  * Starts the standardised tour process, guiding the user through the interface.
  */
	startTour: function startTour() {
		this._requireUI();
		this._UI._tour.start();
	},

	/**
  * Resets the template and view frame. *note*, all placements will be lost.
  */
	reset: function reset() {
		var _this3 = this;

		this._requireUI();

		this._UI._showDialog(_constants.dialogModes.GENERAL, this.dialogs.resetState).then(function () {
			// clear all zones and reset the app
			_this3._store.dispatch(_actions2.default.zoneClearAllAttachments());
			_this3._store.dispatch(_actions2.default.resetApp());

			// clear view
			_this3._UI._comms.send('view', {
				cmd: _constants.messageCommands.RESET
			});

			_this3.hideDialog();
		});
	},

	/**
  * Updates the view frame with the latest template and its attachments.
  */
	updateView: function updateView() {
		this._requireUI();
		this._UI._updateView();
	},

	/**
  * Requires a _UI instance. Will throw if one doesn't exist.
  */
	_requireUI: function _requireUI() {
		if (!this._UI) {
			throw new Error('UI has not yet been initialised! Have you used #load() yet?');
		}
	}
};

/**
 * Default settings.
 */
App.defaults = _defaults2.default;

/**
 * Icon glyphs
 */
App.GLYPHS = _Icon.GLYPHS;

exports.default = App;

/***/ }),
/* 123 */,
/* 124 */,
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Icon = __webpack_require__(16);

var _constants = __webpack_require__(8);

/**
 * The default settings applied to tag's App class on instantiation.
 * @typedef AppDefaults
 * @property {object} classes - Class definitions.
 * @property {object} selectors - CSS Selector definitions.
 * @property {object} template - Template options.
 * @property {number} template.initial_flex_basis=50 - The initial flex basis (width) of
 * the template container.
 * @property {object} view - View options.
 * @property {string} view.src='view.html' - Source filename for the view frame (relative to the App index).
 * @property {boolean} view.autoUpdate=false - Whether to automatically update the view when Droplet attachments change.
 * @property {object} dropZone - Drop Zone options.
 * @property {string} dropZone.label='...' - The label to use for Drop Zone targets.
 * @property {boolean} dropZone.warnOnBadPlacement=true - Produce a dialog when placing a Droplet into an invalid Drop Zone.
 * @property {boolean} dropZone.noticeOnFirstPlacement=true - Produce a dialog on the first valid placement of a Droplet
 * @property {boolean} dropZone.noticeOnLastPlacement=true - Produce a dialog when all of the Drop Zones have at least one attachment.
 * @property {ToolbarItem[]} toolbar - Toolbar items.
 */

exports.default = {
	classes: {
		canvas: 'tag-canvas',
		canvas_active: 'active',
		droplet_active: 'droplet-active',
		is_dragging: 'dragging',
		item_dragging: 'item-dragging',
		dropzone_target: 'target',
		dropzone_is_active: 'is-active',
		dropzone_is_target: 'is-target',
		attached: 'attached',
		text_element: 'text',
		hidden: 'hidden',
		button: 'button',
		button_animate: 'animate',
		popup: 'popup',
		tooltip: 'tooltip',
		template: {
			node: 'template',
			inner: 'template-inner'
		},
		droplet: {
			node: 'droplet',
			active: 'active'
		},
		dropzone: {
			node: 'drop-zone',
			possible_target: 'possible-target',
			will_accept: 'will-accept',
			will_decline: 'will-decline'
		},
		dialog: {
			main: 'dialog',
			visible: 'visible',
			container: 'dialog-container',
			heading: 'dialog-heading',
			no_overlay: 'no-overlay'
		},
		toolbar: {
			separator: 'separator'
		}
	},
	selectors: {
		drop_zone: '.drop-zone .target',
		droplet: '.droplet',
		button_circle: '.circle'
	},
	template: {
		initial_flex_basis: 50
	},
	view: {
		src: 'view.html',
		autoUpdate: false
	},
	dropZone: {
		label: '...',
		warnOnBadPlacement: true,
		noticeOnFirstPlacement: true,
		noticeOnLastPlacement: true
	},
	toolbar: [{
		label: function label(state) {
			if (state.UI.tour_stage !== null && state.UI.dialog.mode === _constants.dialogModes.NONE) {
				return 'Continue tour';
			} else {
				return 'Tour';
			}
		},
		icon: _Icon.GLYPHS.COMPASS,
		method: 'startTour'
	}, {
		label: 'Reset',
		icon: _Icon.GLYPHS.LOOP_CIRCULAR,
		method: 'reset'
	}, {
		label: 'Run',
		icon: _Icon.GLYPHS.MEDIA_PLAY,
		method: 'updateView',
		className: 'run',
		separator: true
	}],
	onElementRender: null,
	showIntro: false
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.optionValueSet = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var optionValueSet = exports.optionValueSet = function optionValueSet(values) {
	var nodes = [],
	    key;

	if (Array.isArray(values)) {
		values.forEach(function (value, index) {
			var key = 'item-' + index;
			nodes.push(_react2.default.createElement(
				'option',
				{ key: key, value: value },
				value
			));
		});
	} else if ((typeof values === 'undefined' ? 'undefined' : _typeof(values)) === 'object') {
		for (key in values) {
			nodes.push(_react2.default.createElement(
				'option',
				{ key: key, value: key },
				values[key]
			));
		}
	}

	return nodes;
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(11);

var _View = __webpack_require__(149);

var _View2 = _interopRequireDefault(_View);

var _TooltipContainer = __webpack_require__(133);

var _TooltipContainer2 = _interopRequireDefault(_TooltipContainer);

var _HeaderContainer = __webpack_require__(130);

var _HeaderContainer2 = _interopRequireDefault(_HeaderContainer);

var _TemplateContainer = __webpack_require__(132);

var _TemplateContainer2 = _interopRequireDefault(_TemplateContainer);

var _DialogContainer = __webpack_require__(129);

var _DialogContainer2 = _interopRequireDefault(_DialogContainer);

var _PalletContainer = __webpack_require__(131);

var _PalletContainer2 = _interopRequireDefault(_PalletContainer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Canvas = function (_Component) {
	_inherits(Canvas, _Component);

	function Canvas(props) {
		_classCallCheck(this, Canvas);

		return _possibleConstructorReturn(this, (Canvas.__proto__ || Object.getPrototypeOf(Canvas)).call(this, props));
	}

	_createClass(Canvas, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (typeof this.props.onMount === 'function') {
				this.props.onMount('canvas');
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var classes = [this.props.settings.classes.canvas, this.props.state.ui_state];

			if (typeof this.props.active_droplet_id === 'string' && this.props.active_droplet_id !== '') {
				classes.push(this.props.settings.classes.droplet_active);
			}

			return _react2.default.createElement(
				'div',
				{ className: classes.join(' '),
					ref: (0, _utils.collectRef)(this.props, 'canvas')
				},
				_react2.default.createElement(
					_HeaderContainer2.default,
					{
						settings: this.props.settings,
						onButtonClick: this.props.onButtonClick,
						lib: this.props.lib },
					_react2.default.createElement(
						'h1',
						{ className: 'logo' },
						'<',
						_react2.default.createElement(
							'b',
							null,
							'Tag'
						),
						'>'
					),
					_react2.default.createElement(
						'p',
						null,
						'The webpage learning tool.'
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'main' },
					_react2.default.createElement(_TemplateContainer2.default, {
						data: this.props.data,
						settings: this.props.settings,
						refCollector: this.props.refCollector,
						onMount: this.props.onMount,
						onAttachmentClick: this.props.onAttachmentClick,
						onDropZoneEvent: this.props.onDropZoneEvent,
						template: this.props.data.template,
						lib: this.props.lib
					}),
					_react2.default.createElement('div', { className: 'drag-handle',
						onMouseEnter: this.props.onDragHandleEvent,
						onMouseLeave: this.props.onDragHandleEvent,
						onMouseDown: this.props.onDragHandleEvent,
						onMouseUp: this.props.onDragHandleEvent,
						onTouchStart: this.props.onDragHandleEvent,
						onTouchEnd: this.props.onDragHandleEvent,
						ref: (0, _utils.collectRef)(this.props, 'drag_handle') }),
					_react2.default.createElement(_View2.default, {
						settings: this.props.settings,
						onMount: this.props.onMount,
						refCollector: this.props.refCollector })
				),
				_react2.default.createElement(_PalletContainer2.default, {
					data: this.props.data,
					settings: this.props.settings,
					lib: this.props.lib,
					onMount: this.props.onMount,
					onDropletEvent: this.props.onDropletEvent,
					refCollector: this.props.refCollector }),
				_react2.default.createElement('div', { className: 'overlay' }),
				_react2.default.createElement(_DialogContainer2.default, {
					settings: this.props.settings,
					lib: this.props.lib,
					onButtonClick: this.props.onButtonClick }),
				_react2.default.createElement(_TooltipContainer2.default, {
					settings: this.props.settings,
					attacher: this.props.lib.setUIPopperAttachment })
			);
		}
	}]);

	return Canvas;
}(_react.Component);

Canvas.propTypes = {
	// from CanvasContainer
	state: _react.PropTypes.object.isRequired,
	active_droplet_id: _react.PropTypes.any,
	state_tooltip: _react.PropTypes.object,

	// from UI#render
	data: _react.PropTypes.object.isRequired,
	onMount: _react.PropTypes.func.isRequired,
	onAttachmentClick: _react.PropTypes.func.isRequired,
	onDropletEvent: _react.PropTypes.func.isRequired,
	onDropZoneEvent: _react.PropTypes.func.isRequired,
	onDragHandleEvent: _react.PropTypes.func.isRequired,
	onButtonClick: _react.PropTypes.func.isRequired,
	refCollector: _react.PropTypes.func.isRequired,
	settings: _react.PropTypes.object.isRequired,
	lib: _react.PropTypes.object.isRequired
};

exports.default = Canvas;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(15);

var _Canvas = __webpack_require__(127);

var _Canvas2 = _interopRequireDefault(_Canvas);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapStateToProps = function mapStateToProps(state) {
	return {
		state: state.app,
		active_droplet_id: state.UI.active_droplet_id
	};
};

var CanvasContainer = (0, _reactRedux.connect)(mapStateToProps)(_Canvas2.default);

exports.default = CanvasContainer;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(15);

var _Dialog = __webpack_require__(134);

var _Dialog2 = _interopRequireDefault(_Dialog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapStateToProps = function mapStateToProps(state) {
	return {
		id: state.UI.dialog.id,
		mode: state.UI.dialog.mode,
		data: state.UI.dialog.data,
		onDialogComplete: state.UI.dialog.onDialogComplete,
		onDialogCancel: state.UI.dialog.onDialogCancel
	};
};

var DialogContainer = (0, _reactRedux.connect)(mapStateToProps)(_Dialog2.default);

exports.default = DialogContainer;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(15);

var _Header = __webpack_require__(144);

var _Header2 = _interopRequireDefault(_Header);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapStateToProps = function mapStateToProps(state) {
	return {
		tour_stage: state.UI.tour_stage,
		dialog_mode: state.UI.dialog.mode
	};
};

var HeaderContainer = (0, _reactRedux.connect)(mapStateToProps)(_Header2.default);

exports.default = HeaderContainer;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(15);

var _actions = __webpack_require__(37);

var _actions2 = _interopRequireDefault(_actions);

var _Pallet = __webpack_require__(145);

var _Pallet2 = _interopRequireDefault(_Pallet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapStateToProps = function mapStateToProps(state) {
	return {
		activeDropletId: state.UI.active_droplet_id
	};
};

var mapDispatchToProps = function mapDispatchToProps(dispatch, props) {
	return {
		onDropletEvent: function onDropletEvent(event, droplet, data) {
			switch (event.type) {
				case 'mouseenter':
				case 'touchstart':
					dispatch(_actions2.default.setTooltipContent(data.title, data.content, data.iconGlyph));
					dispatch(_actions2.default.showTooltip(data.ref));
					break;

				case 'mouseleave':
				case 'touchend':
				case 'click':
					dispatch(_actions2.default.hideTooltip());
					break;
			}

			props.onDropletEvent(event, droplet, data);
		}
	};
};

var PalletContainer = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_Pallet2.default);

exports.default = PalletContainer;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(15);

var _Template = __webpack_require__(146);

var _Template2 = _interopRequireDefault(_Template);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapStateToProps = function mapStateToProps(state) {
	return {
		zones: state.zones,
		activeDropletID: state.UI.active_droplet_id
	};
};

var TemplateContainer = (0, _reactRedux.connect)(mapStateToProps)(_Template2.default);

exports.default = TemplateContainer;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(15);

var _Tooltip = __webpack_require__(148);

var _Tooltip2 = _interopRequireDefault(_Tooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapStateToProps = function mapStateToProps(state) {
	return {
		state: state.UI.tooltip
	};
};

var TooltipContainer = (0, _reactRedux.connect)(mapStateToProps)(_Tooltip2.default);

exports.default = TooltipContainer;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _constants = __webpack_require__(8);

var _DialogGeneral = __webpack_require__(136);

var _DialogGeneral2 = _interopRequireDefault(_DialogGeneral);

var _DialogEditDroplet = __webpack_require__(135);

var _DialogEditDroplet2 = _interopRequireDefault(_DialogEditDroplet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// import the dialogs used, then put into a global for referencing


var DialogComponents = {};
DialogComponents[_constants.dialogModes.EDIT_DROPLET] = _DialogEditDroplet2.default;
DialogComponents[_constants.dialogModes.GENERAL] = _DialogGeneral2.default;
DialogComponents[_constants.dialogModes.TOUR] = _DialogGeneral2.default;

var Dialog = function (_Component) {
	_inherits(Dialog, _Component);

	function Dialog(props) {
		_classCallCheck(this, Dialog);

		return _possibleConstructorReturn(this, (Dialog.__proto__ || Object.getPrototypeOf(Dialog)).call(this, props));
	}

	/**
  * `ref` and `popper` reference is refreshed here instead of componentDidMount
  * because this component doesn't really "unmount" as such - it just changes the
  * inner `Component` value for dialog contents.
  */


	_createClass(Dialog, [{
		key: 'collectRef',
		value: function collectRef(ref) {
			if (ref !== null) {
				this.dialogRef = ref;

				if (this.popper) {
					// popper already exists - remove and set null
					this.popper.destroy();
					this.popper = null;
				}

				if (this.props.data && this.props.data.attachment) {
					// attachment data exists - apply with popper
					this.popper = this.props.lib.setUIPopperAttachment(this.props.data.attachment, this.dialogRef);
				}
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var Component,
			    classes = [this.props.settings.classes.dialog.main];

			if (this.props.mode !== _constants.dialogModes.NONE) {
				classes.push(this.props.settings.classes.dialog.visible);
			}

			// get appropriate component for dialog mode
			Component = DialogComponents[this.props.mode];

			if (Component) {
				// a dialog is being requested - render the appropriate component
				if (this.props.data.overlay === false) {
					classes.push(this.props.settings.classes.dialog.no_overlay);
				}

				return _react2.default.createElement(
					'div',
					{ className: classes.join(' ') },
					_react2.default.createElement(Component, {
						key: this.props.id,
						data: this.props.data,
						settings: this.props.settings,
						refCollector: this.collectRef.bind(this),
						onDialogComplete: this.props.onDialogComplete,
						onDialogCancel: this.props.onDialogCancel,
						onButtonClick: this.props.onButtonClick,
						lib: this.props.lib })
				);
			} else {
				return _react2.default.createElement('div', { className: classes.join(' ') });
			}
		}
	}]);

	return Dialog;
}(_react.Component);

Dialog.propTypes = {
	// from DialogContainer
	mode: _react.PropTypes.string,
	data: _react.PropTypes.object,
	onDialogCancel: _react.PropTypes.func,
	onButtonClick: _react.PropTypes.func,
	id: _react.PropTypes.string.isRequired,

	// from Canvas
	settings: _react.PropTypes.object,
	onDialogComplete: _react.PropTypes.func,
	lib: _react.PropTypes.object
};

Dialog.defaultProps = {
	onDialogCancel: null,
	onDialogComplete: null
};

exports.default = Dialog;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _FormField = __webpack_require__(35);

var _FormField2 = _interopRequireDefault(_FormField);

var _constants = __webpack_require__(8);

var _commonPropTypes = __webpack_require__(34);

var _Icon = __webpack_require__(16);

var _DialogHeading = __webpack_require__(78);

var _DialogHeading2 = _interopRequireDefault(_DialogHeading);

var _Form = __webpack_require__(79);

var _Form2 = _interopRequireDefault(_Form);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var headingsByType = {
	'element': {
		text: 'Element',
		icon: _Icon.GLYPHS.TAG
	},
	'text': {
		text: 'Text item',
		icon: _Icon.GLYPHS.TEXT
	},
	'attribute': {
		text: 'Attribute',
		icon: _Icon.GLYPHS.PUZZLE_PIECE
	}
};

var DialogEditDroplet = function (_Component) {
	_inherits(DialogEditDroplet, _Component);

	function DialogEditDroplet(props) {
		_classCallCheck(this, DialogEditDroplet);

		var _this = _possibleConstructorReturn(this, (DialogEditDroplet.__proto__ || Object.getPrototypeOf(DialogEditDroplet)).call(this, props));

		if (_this.props.data && _this.props.data.droplet_id) {
			_this.droplet = _this.props.lib.getDropletById(_this.props.data.droplet_id);
		}

		_this.onDialogComplete = _this.onDialogComplete.bind(_this);
		_this.detachAttachment = _this.detachAttachment.bind(_this);
		return _this;
	}

	/**
  * Instead of passing completion straight to the prop, handles conversion of raw form
  * data back into a format matching the original droplet data.
  */


	_createClass(DialogEditDroplet, [{
		key: 'onDialogComplete',
		value: function onDialogComplete(values, action, action_data) {
			var droplet_values = {},
			    key;

			if (typeof this.props.onDialogComplete === 'function') {
				// convert data back into format replicating Droplet.data format
				for (key in values) {
					if (values.hasOwnProperty(key)) {
						if (key === 'attrs') {
							droplet_values[key] = values[key];
						} else {
							droplet_values[key] = values[key][key];
						}
					}
				}

				droplet_values = Object.deepAssign({}, this.droplet.data, droplet_values);

				// finally, fire the original prop with the converted data
				this.props.onDialogComplete(droplet_values, action, action_data);
			}
		}
	}, {
		key: 'detachAttachment',
		value: function detachAttachment() {
			if (this.props.data.attachment_index !== null) {
				this.props.lib.zoneDetachAttachment(this.props.data.zone_id, this.props.data.attachment_index);
			} else {
				throw new Error('attachment_index is null or not defined. Cannot detach');
			}

			this.props.onDialogCancel();
		}
	}, {
		key: 'getFieldsets',
		value: function getFieldsets() {
			var fieldsets = [],
			    attachment = null,
			    fieldset,
			    field,
			    attribute,
			    item;

			if (this.props.data.attachment_index !== null) {
				attachment = this.props.lib.zoneGetAttachment(this.props.data.zone_id, this.props.data.attachment_index);
			}

			for (attribute in this.droplet.editable) {
				fieldset = {
					key: attribute,
					legend: _constants.setLabels[attribute],
					fields: []
				};

				// add indidual fields, depending on editable attribute type
				if (attribute === 'attrs') {
					// the 'attrs' attribute, which contains key/value pairs
					for (item in this.droplet.editable[attribute]) {
						field = Object.deepAssign({}, this.droplet.editable[attribute][item]);

						// preset value from attachment
						if (attachment !== null && attachment.data.attrs && attachment.data.attrs[item]) {
							field.value = attachment.data.attrs[item];
						}

						fieldset.fields.push(new _FormField2.default(item, this.droplet.editable[attribute][item].type, field));
					}
				} else {
					// string based attributes
					field = Object.deepAssign({}, this.droplet.editable[attribute]);

					// preset value from attachment
					if (attachment !== null && attachment.data[attribute]) {
						field.value = attachment.data[attribute];
					}

					fieldset.fields.push(new _FormField2.default(attribute, this.droplet.editable[attribute].type, field));
				}

				// add fieldset to form
				fieldsets.push(fieldset);
			}

			return fieldsets;
		}
	}, {
		key: 'render',
		value: function render() {
			var fieldsets = this.getFieldsets(),
			    buttons = [],
			    classes = [this.props.settings.classes.dialog.container, this.props.settings.classes.popup],
			    title,
			    notes;

			classes.push('droplet-' + this.droplet.dropletType);

			// add cancel button (for every dialog type)
			buttons.push({
				type: 'cancel',
				label: 'Cancel'
			});

			if (this.props.data.attachment_index !== null) {
				// editing an existing droplet
				title = 'Edit ' + headingsByType[this.droplet.dropletType].text;

				if (fieldsets.length) {
					notes = ['You can edit the Droplet using the fields below. ' + 'Change the bits you want to customise and use “Add Droplet” when you’re done.'];

					buttons.push({
						type: 'submit',
						label: 'Edit Droplet'
					});
				} else {
					notes = ['There is nothing to edit on this Droplet, but you can remove it ' + 'With the “Remove Droplet” button.'];
				}

				buttons.push({
					type: 'remove_droplet',
					label: 'Remove Droplet',
					className: 'danger pull-left',
					data: {
						attachment_index: this.props.data.attachment_index,
						zone_id: this.props.data.zone_id
					}
				});
			} else {
				// adding
				title = 'Add ' + headingsByType[this.droplet.dropletType].text;
				notes = ['You’ve found the right drop place to put this Droplet! ', 'Edit anything you would like to change and then use “Edit Droplet”.'];
				buttons = buttons.concat({
					type: 'submit',
					label: 'Add Droplet'
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: classes.join(' '),
					ref: this.props.refCollector },
				_react2.default.createElement(_DialogHeading2.default, {
					title: title,
					notes: notes,
					iconGlyph: headingsByType[this.droplet.dropletType].icon,
					className: this.props.settings.classes.dialog.heading }),
				_react2.default.createElement(_Form2.default, {
					fieldSets: fieldsets,
					buttons: buttons,
					onButtonClick: this.props.onButtonClick,
					onSubmit: this.onDialogComplete,
					onCancel: this.props.onDialogCancel }),
				_react2.default.createElement('span', { className: 'arrow' })
			);
		}
	}]);

	return DialogEditDroplet;
}(_react.Component);

DialogEditDroplet.propTypes = _commonPropTypes.dialog;

exports.default = DialogEditDroplet;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _DialogHeading = __webpack_require__(78);

var _DialogHeading2 = _interopRequireDefault(_DialogHeading);

var _Form = __webpack_require__(79);

var _Form2 = _interopRequireDefault(_Form);

var _commonPropTypes = __webpack_require__(34);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DialogGeneral = function (_Component) {
	_inherits(DialogGeneral, _Component);

	function DialogGeneral(props) {
		_classCallCheck(this, DialogGeneral);

		return _possibleConstructorReturn(this, (DialogGeneral.__proto__ || Object.getPrototypeOf(DialogGeneral)).call(this, props));
	}

	_createClass(DialogGeneral, [{
		key: 'render',
		value: function render() {
			var buttons = this.props.data.buttons,
			    classes = [this.props.settings.classes.dialog.container, this.props.settings.classes.popup];

			if (!buttons || !buttons.length) {
				buttons = [{
					type: 'submit',
					label: 'OK'
				}];
			}

			return _react2.default.createElement(
				'div',
				{ className: classes.join(' '),
					ref: this.props.refCollector },
				_react2.default.createElement(_DialogHeading2.default, {
					title: this.props.data.title,
					notes: this.props.data.message,
					className: this.props.settings.classes.dialog.heading }),
				_react2.default.createElement(_Form2.default, {
					buttons: buttons,
					onButtonClick: this.props.onButtonClick,
					onSubmit: this.props.onDialogComplete,
					onCancel: this.props.onDialogCancel }),
				_react2.default.createElement('span', { className: 'arrow' })
			);
		}
	}]);

	return DialogGeneral;
}(_react.Component);

DialogGeneral.propTypes = _commonPropTypes.dialog;

exports.default = DialogGeneral;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Button = function Button(props) {
	var type = props.type === 'submit' ? 'submit' : 'button',
	    classes = ['button', props.className],
	    onClick = props.onClick;

	if (props.type === 'cancel') {
		classes.push('cancel');
	} else if (props.type === 'submit') {
		classes.push('primary');
	}

	return _react2.default.createElement(
		'button',
		{
			ref: props.refCollector,
			className: classes.join(' '),
			onClick: onClick,
			type: type },
		_react2.default.createElement(
			'span',
			null,
			props.label,
			_react2.default.createElement('span', { className: 'circle' })
		)
	);
};

Button.propTypes = {
	type: _react.PropTypes.string.isRequired,
	label: _react.PropTypes.string.isRequired,
	className: _react.PropTypes.string,
	onClick: _react.PropTypes.func,
	refCollector: _react.PropTypes.func
};

exports.default = Button;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(11);

var _DropZone = __webpack_require__(26);

var _DropZone2 = _interopRequireDefault(_DropZone);

var _DropZoneAttachmentList = __webpack_require__(140);

var _DropZoneAttachmentList2 = _interopRequireDefault(_DropZoneAttachmentList);

var _DropZoneTarget = __webpack_require__(141);

var _DropZoneTarget2 = _interopRequireDefault(_DropZoneTarget);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DropZoneComponent = function (_Component) {
	_inherits(DropZoneComponent, _Component);

	function DropZoneComponent(props) {
		_classCallCheck(this, DropZoneComponent);

		var _this = _possibleConstructorReturn(this, (DropZoneComponent.__proto__ || Object.getPrototypeOf(DropZoneComponent)).call(this, props));

		_this.myrefs = {};
		_this.onEvent = _this.onEvent.bind(_this);
		return _this;
	}

	_createClass(DropZoneComponent, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (typeof this.props.onMount === 'function') {
				this.props.onMount('dropzone', this.props.zone.id);
			}
		}
	}, {
		key: 'onEvent',
		value: function onEvent(event) {
			if (event.type === 'click') {
				event.preventDefault();
			}

			this.props.onEvent(event, this.props.zone);
		}
	}, {
		key: 'render',
		value: function render() {
			var key = this.props.zone.id + '-zone',
			    classNames = [this.props.settings.classes.dropzone.node];

			if (this.props.className !== '') {
				classNames.push(this.props.className);
			}

			return _react2.default.createElement(
				'span',
				{
					key: key,
					className: classNames.join(' '),
					ref: (0, _utils.collectRef)(this.props, ['dropzone'], this.props.zone.id),
					'data-id': this.props.zone.id,
					'data-attachment': this.props.zone.attachmentId },
				_react2.default.createElement(_DropZoneAttachmentList2.default, {
					zone: this.props.zone,
					activeAttachments: this.props.activeAttachments,
					onAttachmentClick: this.props.onAttachmentClick,
					lib: this.props.lib }),
				_react2.default.createElement(_DropZoneTarget2.default, {
					zone: this.props.zone,
					settings: this.props.settings,
					activeAttachments: this.props.activeAttachments,
					refCollector: this.props.refCollector,
					onEvent: this.onEvent })
			);
		}
	}]);

	return DropZoneComponent;
}(_react.Component);

DropZoneComponent.propTypes = {
	zone: _react.PropTypes.instanceOf(_DropZone2.default).isRequired,
	className: _react.PropTypes.string,
	settings: _react.PropTypes.object.isRequired,
	activeAttachments: _react.PropTypes.array.isRequired,
	onMount: _react.PropTypes.func.isRequired,
	onAttachmentClick: _react.PropTypes.func.isRequired,
	onEvent: _react.PropTypes.func.isRequired,
	refCollector: _react.PropTypes.func.isRequired,
	lib: _react.PropTypes.object.isRequired
};

exports.default = DropZoneComponent;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Template = __webpack_require__(36);

var _Template2 = _interopRequireDefault(_Template);

var _Droplet = __webpack_require__(27);

var _Droplet2 = _interopRequireDefault(_Droplet);

var _DropZone = __webpack_require__(26);

var _DropZone2 = _interopRequireDefault(_DropZone);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DropZoneAttachment = function (_Component) {
	_inherits(DropZoneAttachment, _Component);

	function DropZoneAttachment(props) {
		_classCallCheck(this, DropZoneAttachment);

		var _this = _possibleConstructorReturn(this, (DropZoneAttachment.__proto__ || Object.getPrototypeOf(DropZoneAttachment)).call(this, props));

		_this.onClick = _this.onClick.bind(_this);
		return _this;
	}

	_createClass(DropZoneAttachment, [{
		key: 'onClick',
		value: function onClick(event) {
			event.preventDefault();

			this.props.onClick(event, this.props.droplet, this.props.attachmentIndex);
		}
	}, {
		key: 'render',
		value: function render() {
			var className = 'dropzone-attachment',
			    data;

			// merge edited data with droplet data
			data = Object.deepAssign({}, this.props.droplet.data, this.props.data);

			// set classname
			className += ' ' + this.props.droplet.dropletType;

			return _react2.default.createElement(
				'span',
				{
					className: className,
					onClick: this.onClick },
				_Template2.default.renderDroplet(this.props.droplet, data, this.props.zone, false)
			);
		}
	}]);

	return DropZoneAttachment;
}(_react.Component);

DropZoneAttachment.propTypes = {
	droplet: _react.PropTypes.instanceOf(_Droplet2.default).isRequired,
	zone: _react.PropTypes.instanceOf(_DropZone2.default).isRequired,
	attachmentIndex: _react.PropTypes.number.isRequired,
	onClick: _react.PropTypes.func.isRequired,
	data: _react.PropTypes.object.isRequired
};

exports.default = DropZoneAttachment;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _DropZone = __webpack_require__(26);

var _DropZone2 = _interopRequireDefault(_DropZone);

var _DropZoneAttachment = __webpack_require__(139);

var _DropZoneAttachment2 = _interopRequireDefault(_DropZoneAttachment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DropZoneAttachmentList = function (_Component) {
	_inherits(DropZoneAttachmentList, _Component);

	function DropZoneAttachmentList(props) {
		_classCallCheck(this, DropZoneAttachmentList);

		var _this = _possibleConstructorReturn(this, (DropZoneAttachmentList.__proto__ || Object.getPrototypeOf(DropZoneAttachmentList)).call(this, props));

		_this.attachmentClick = _this.attachmentClick.bind(_this);
		return _this;
	}

	_createClass(DropZoneAttachmentList, [{
		key: 'attachmentClick',
		value: function attachmentClick(event, droplet, attachmentIndex) {
			if (typeof this.props.onAttachmentClick === 'function') {
				this.props.onAttachmentClick(droplet, this.props.zone, attachmentIndex);
			}
		}
	}, {
		key: 'renderActiveAttachments',
		value: function renderActiveAttachments() {
			var _this2 = this;

			var children = [];

			this.props.activeAttachments.forEach(function (attachment, index) {
				children.push(_react2.default.createElement(_DropZoneAttachment2.default, {
					key: attachment.droplet_id + '-attachment-' + index,
					attachmentIndex: index,
					onClick: _this2.attachmentClick,
					droplet: _this2.props.lib.getDropletById(attachment.droplet_id),
					zone: _this2.props.zone,
					data: attachment.data }));
			});

			return children;
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'span',
				{
					className: 'attachments' },
				this.renderActiveAttachments()
			);
		}
	}]);

	return DropZoneAttachmentList;
}(_react.Component);

DropZoneAttachmentList.propTypes = {
	zone: _react.PropTypes.instanceOf(_DropZone2.default).isRequired,
	activeAttachments: _react.PropTypes.array.isRequired,
	onAttachmentClick: _react.PropTypes.func.isRequired,
	lib: _react.PropTypes.object.isRequired
};

exports.default = DropZoneAttachmentList;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(11);

var _DropZone = __webpack_require__(26);

var _DropZone2 = _interopRequireDefault(_DropZone);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DropZoneTarget = function (_Component) {
	_inherits(DropZoneTarget, _Component);

	function DropZoneTarget(props) {
		_classCallCheck(this, DropZoneTarget);

		var _this = _possibleConstructorReturn(this, (DropZoneTarget.__proto__ || Object.getPrototypeOf(DropZoneTarget)).call(this, props));

		_this.onEvent = _this.onEvent.bind(_this);
		return _this;
	}

	_createClass(DropZoneTarget, [{
		key: 'onEvent',
		value: function onEvent(event) {
			if (event.type === 'click') {
				event.preventDefault();
			}

			this.props.onEvent(event, this.props.zone);
		}
	}, {
		key: 'render',
		value: function render() {
			var key = this.props.zone.id + '-target',
			    classNames = [this.props.settings.classes.dropzone_target];

			if (this.props.activeAttachments.length >= this.props.zone.maxAttachments) {
				classNames.push(this.props.settings.classes.hidden);
			}

			return _react2.default.createElement(
				'span',
				{ className: 'target-outer' },
				_react2.default.createElement(
					'span',
					{ key: key,
						onClick: this.onEvent,
						ref: (0, _utils.collectRef)(this.props, ['dropzone_target'], this.props.zone.id),
						className: classNames.join(' ') },
					_react2.default.createElement(
						'b',
						null,
						this.props.settings.dropZone.label
					)
				)
			);
		}
	}]);

	return DropZoneTarget;
}(_react.Component);

DropZoneTarget.propTypes = {
	zone: _react.PropTypes.instanceOf(_DropZone2.default).isRequired,
	settings: _react.PropTypes.object.isRequired,
	activeAttachments: _react.PropTypes.array.isRequired,
	onEvent: _react.PropTypes.func.isRequired,
	refCollector: _react.PropTypes.func
};

exports.default = DropZoneTarget;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(11);

var _Droplet = __webpack_require__(27);

var _Droplet2 = _interopRequireDefault(_Droplet);

var _Template = __webpack_require__(36);

var _Template2 = _interopRequireDefault(_Template);

var _Icon = __webpack_require__(16);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dropletTypeToGlyphs = {
	'text': _Icon.GLYPHS.TEXT,
	'element': _Icon.GLYPHS.TAG,
	'attribute': _Icon.GLYPHS.PUZZLE_PIECE
};

var DropletComponent = function (_Component) {
	_inherits(DropletComponent, _Component);

	function DropletComponent(props) {
		_classCallCheck(this, DropletComponent);

		var _this = _possibleConstructorReturn(this, (DropletComponent.__proto__ || Object.getPrototypeOf(DropletComponent)).call(this, props));

		_this.tooltip_cache = '';
		_this.ui = {
			droplet: null
		};

		_this.onEvent = _this.onEvent.bind(_this);
		return _this;
	}

	_createClass(DropletComponent, [{
		key: 'refCollector',
		value: function refCollector(ref) {
			var collector = (0, _utils.collectRef)(this.props, ['droplet'], this.props.droplet.id);
			this.ui.droplet = ref;
			collector(ref);
		}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (typeof this.props.onMount === 'function') {
				this.props.onMount('droplet', this.props.droplet.id);
			}
		}
	}, {
		key: 'onEvent',
		value: function onEvent(event) {
			if (event.type === 'click') {
				event.preventDefault();
			}

			if (event.type === 'mouseenter' || event.type === 'touchstart') {
				if (this.tooltip_cache === '') {
					this.tooltip_cache += '<code>' + _Template2.default.entities(_Template2.default.renderDroplet(this.props.droplet, this.props.droplet.data, null, false)) + '</code>';

					if (this.props.droplet.guidance) {
						this.tooltip_cache += this.props.droplet.guidance;
					}

					this.tooltip_cache += '<p>' + ('ontouchstart' in window ? 'Tap' : 'Click') + ' on the Droplet to place it in the template.</p>';
				}
			}

			this.props.onEvent(event, this.props.droplet, {
				ref: this.ui.droplet,
				title: this.props.droplet.name,
				content: this.tooltip_cache,
				iconGlyph: _Icon.GLYPHS.LIGHTBULB
			});
		}
	}, {
		key: 'showDescription',
		value: function showDescription() {
			var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			console.log('showDescription', this.props.droplet.id, show);
		}
	}, {
		key: 'render',
		value: function render() {
			var classes = [this.props.settings.classes.droplet.node, 'type-' + this.props.droplet.dropletType];

			if (this.props.active) {
				classes.push(this.props.settings.classes.droplet.active);
			}

			return _react2.default.createElement(
				'button',
				{
					id: this.props.droplet.id,
					className: classes.join(' '),
					onClick: this.onEvent,
					onMouseEnter: this.onEvent,
					onMouseLeave: this.onEvent,
					onTouchStart: this.onEvent,
					onTouchEnd: this.onEvent,
					ref: this.refCollector.bind(this) },
				_react2.default.createElement(
					'span',
					{ className: 'label' },
					_react2.default.createElement(_Icon.Icon, { glyph: dropletTypeToGlyphs[this.props.droplet.dropletType] }),
					this.props.droplet.name
				)
			);
		}
	}]);

	return DropletComponent;
}(_react.Component);

DropletComponent.propTypes = {
	active: _react.PropTypes.bool,
	settings: _react.PropTypes.object.isRequired,
	lib: _react.PropTypes.object.isRequired,
	refCollector: _react.PropTypes.func.isRequired,
	droplet: _react.PropTypes.instanceOf(_Droplet2.default).isRequired,
	onMount: _react.PropTypes.func,
	onEvent: _react.PropTypes.func
};

exports.default = DropletComponent;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _FormField = __webpack_require__(35);

var _FormField2 = _interopRequireDefault(_FormField);

var _TextField = __webpack_require__(151);

var _TextField2 = _interopRequireDefault(_TextField);

var _DropDown = __webpack_require__(150);

var _DropDown2 = _interopRequireDefault(_DropDown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldComponents = {
	'text': _TextField2.default,
	'dropdown': _DropDown2.default
};

var Fieldset = function (_Component) {
	_inherits(Fieldset, _Component);

	function Fieldset(props) {
		_classCallCheck(this, Fieldset);

		var formValues = {};

		// set default state for fields based on original values
		var _this = _possibleConstructorReturn(this, (Fieldset.__proto__ || Object.getPrototypeOf(Fieldset)).call(this, props));

		_this.props.fields.forEach(function (field) {
			return formValues[field.name] = field.value || '';
		});

		// set default form value state
		_this.state = {
			formValues: formValues
		};

		// bind functions for events
		_this.elementChange = _this.elementChange.bind(_this);
		return _this;
	}

	_createClass(Fieldset, [{
		key: 'collectRef',
		value: function collectRef(key) {
			return function (ref) {
				if (typeof this.props.refCollector === 'function') {
					this.props.refCollector(key, ref);
				}
			}.bind(this);
		}
	}, {
		key: 'fields',
		value: function fields() {
			var _this2 = this;

			var Component,
			    output = [];

			this.props.fields.forEach(function (field) {
				var key = 'field-' + field.name;

				Component = FieldComponents[field.type];

				switch (field.type) {
					case 'text':
						output.push(_react2.default.createElement(Component, { key: key,
							refCollector: _this2.collectRef(key),
							field: field,
							onChange: _this2.elementChange,
							value: _this2.state.formValues[field.name] }));
						break;

					case 'dropdown':
						output.push(_react2.default.createElement(Component, { key: key,
							refCollector: _this2.collectRef(key),
							field: field,
							onChange: _this2.elementChange,
							value: _this2.state.formValues[field.name] }));
				}
			});

			return output;
		}
	}, {
		key: 'elementChange',
		value: function elementChange(event) {
			var target = event.target,
			    formValues = Object.deepAssign({}, this.state.formValues);

			formValues[target.name] = target.value;

			this.setState({
				formValues: formValues
			});

			this.props.onFieldUpdate(this.props.set, target.name, target.value, formValues);
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'fieldset',
				null,
				_react2.default.createElement(
					'legend',
					null,
					this.props.legend
				),
				this.fields()
			);
		}
	}]);

	return Fieldset;
}(_react.Component);

Fieldset.propTypes = {
	refCollector: _react.PropTypes.func,
	set: _react.PropTypes.string.isRequired,
	onFieldUpdate: _react.PropTypes.func.isRequired,
	legend: _react.PropTypes.string,
	fields: _react.PropTypes.arrayOf(_react2.default.PropTypes.instanceOf(_FormField2.default))
};

Fieldset.defaultProps = {
	onFieldUpdate: function onFieldUpdate() {},
	fields: {}
};

exports.default = Fieldset;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Toolbar = __webpack_require__(147);

var _Toolbar2 = _interopRequireDefault(_Toolbar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Header = function (_Component) {
	_inherits(Header, _Component);

	function Header(props) {
		_classCallCheck(this, Header);

		return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).call(this, props));
	}

	_createClass(Header, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'header',
				null,
				this.props.children,
				_react2.default.createElement(_Toolbar2.default, {
					buttons: this.props.settings.toolbar,
					tour_stage: this.props.tour_stage,
					dialog_mode: this.props.dialog_mode,
					settings: this.props.settings,
					onButtonClick: this.props.onButtonClick,
					lib: this.props.lib })
			);
		}
	}]);

	return Header;
}(_react.Component);

Header.propTypes = {
	// from HeaderContainer
	tour_stage: _react.PropTypes.any,
	dialog_mode: _react.PropTypes.string,

	// from Canvas
	children: _react.PropTypes.node,
	settings: _react.PropTypes.object.isRequired,
	onButtonClick: _react.PropTypes.func,
	lib: _react.PropTypes.object.isRequired
};

exports.default = Header;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Droplet = __webpack_require__(142);

var _Droplet2 = _interopRequireDefault(_Droplet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Pallet = function (_Component) {
	_inherits(Pallet, _Component);

	function Pallet(props) {
		_classCallCheck(this, Pallet);

		return _possibleConstructorReturn(this, (Pallet.__proto__ || Object.getPrototypeOf(Pallet)).call(this, props));
	}

	_createClass(Pallet, [{
		key: 'getItems',
		value: function getItems() {
			var _this2 = this;

			var items = [];

			if (this.props.data.pallet) {
				this.props.data.pallet.forEach(function (droplet) {
					items.push(_react2.default.createElement(_Droplet2.default, { droplet: droplet,
						active: _this2.props.activeDropletId === droplet.id,
						settings: _this2.props.settings,
						lib: _this2.props.lib,
						onMount: _this2.props.onMount,
						onEvent: _this2.props.onDropletEvent,
						refCollector: _this2.props.refCollector,
						key: droplet.id }));
				});
			}

			return items;
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'section',
				{ className: 'pallet' },
				_react2.default.createElement(
					'form',
					null,
					this.getItems.apply(this)
				)
			);
		}
	}]);

	return Pallet;
}(_react.Component);

Pallet.propTypes = {
	// from PalletContainer
	activeDropletId: _react.PropTypes.string.isRequired,

	// from Canvas
	data: _react.PropTypes.object.isRequired,
	settings: _react.PropTypes.object.isRequired,
	lib: _react.PropTypes.object.isRequired,
	onMount: _react.PropTypes.func,
	onDropletEvent: _react.PropTypes.func.isRequired,
	refCollector: _react.PropTypes.func
};

Pallet.defaultProps = {
	data: {
		pallet: []
	}
};

exports.default = Pallet;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(11);

var _DropZone = __webpack_require__(138);

var _DropZone2 = _interopRequireDefault(_DropZone);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Template = function (_Component) {
	_inherits(Template, _Component);

	function Template(props) {
		_classCallCheck(this, Template);

		return _possibleConstructorReturn(this, (Template.__proto__ || Object.getPrototypeOf(Template)).call(this, props));
	}

	_createClass(Template, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (typeof this.props.onMount === 'function') {
				this.props.onMount('template');
			}
		}

		/**
   * Uses state (from props.zones) to ascertain the attachments
   */

	}, {
		key: 'getZoneAttachments',
		value: function getZoneAttachments(dropzone_id) {
			if (this.props.zones && this.props.zones[dropzone_id]) {
				return this.props.zones[dropzone_id].attachments;
			} else {
				return [];
			}
		}

		/**
   * @description
   * Computes the correct potential className for the drop zone based on:
   * - The active Droplet ID
   * - Whether or not this drop zone will accept the droplet
   */

	}, {
		key: 'getDropZoneClassNames',
		value: function getDropZoneClassNames(dropzone) {
			var classes = [],
			    droplet;

			if (this.props.activeDropletID !== '' && (droplet = this.props.lib.getDropletById(this.props.activeDropletID))) {
				classes.push(this.props.settings.classes.dropzone.possible_target);
				classes.push(this.props.settings.classes.dropzone[this.props.lib.isValidDrop(droplet, dropzone) ? 'will_accept' : 'will_decline']);

				return classes;
			} else {
				return [];
			}
		}
	}, {
		key: 'getTemplate',
		value: function getTemplate() {
			var _this2 = this;

			var children = [];

			this.props.template.forEach(function (node, index) {
				var key;

				switch (node.type) {
					case 'text':
						key = 'fragment-' + index;

						children.push(_react2.default.createElement(
							'span',
							{
								key: key,
								className: _this2.props.settings.classes.component },
							node.content
						));
						break;

					case 'dropzone':
						children.push(_react2.default.createElement(_DropZone2.default, {
							key: node.zone.id,
							zone: node.zone,
							className: _this2.getDropZoneClassNames(node.zone).join(' '),
							settings: _this2.props.settings,
							activeAttachments: _this2.getZoneAttachments(node.zone.id),
							refCollector: _this2.props.refCollector,
							onMount: _this2.props.onMount,
							onEvent: _this2.props.onDropZoneEvent,
							onAttachmentClick: _this2.props.onAttachmentClick,
							lib: _this2.props.lib }));
						break;
				}
			});

			return children;
		}
	}, {
		key: 'getInstruction',
		value: function getInstruction() {
			if (this.props.activeDropletID != '') {
				return _react2.default.createElement(
					'p',
					{ className: 'instruction' },
					'Choose a target for the droplet...'
				);
			}
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'section',
				{ className: this.props.settings.classes.template.node,
					ref: (0, _utils.collectRef)(this.props, 'template') },
				this.getInstruction(),
				_react2.default.createElement(
					'div',
					{ className: this.props.settings.classes.template.inner },
					_react2.default.createElement(
						'pre',
						null,
						_react2.default.createElement(
							'code',
							{ className: 'html',
								ref: (0, _utils.collectRef)(this.props, 'template_inner') },
							this.getTemplate()
						)
					)
				)
			);
		}
	}]);

	return Template;
}(_react.Component);

Template.propTypes = {
	// from TemplateContainer
	zones: _react.PropTypes.object.isRequired,
	activeDropletID: _react.PropTypes.string,

	// from Canvas
	settings: _react.PropTypes.object.isRequired,
	template: _react.PropTypes.array.isRequired,
	onMount: _react.PropTypes.func.isRequired,
	onAttachmentClick: _react.PropTypes.func.isRequired,
	onDropZoneEvent: _react.PropTypes.func.isRequired,
	refCollector: _react.PropTypes.func.isRequired,
	lib: _react.PropTypes.object.isRequired
};

Template.defaultProps = {
	template: ''
};

exports.default = Template;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Icon = __webpack_require__(16);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @typedef ToolbarStateSegment
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @description
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * A small segment of the App's internal state which includes values relevant to toolbar
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * button production.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @property {object} UI
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @property {object} UI.dialog
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @property {module:assets/constants.dialogModes} UI.dialog.mode - The current mode of the active dialog.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @property {number|null} tour_stage - The current tour stage index. (Or `null`).
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * A toolbar label function will be invoked with the following arguments:
 * @typedef {function} ToolbarItemLabel
 * @param {ToolbarStateSegment} state - A segment of the current application state.
 */

/**
 * @typedef ToolbarItem
 * @property {ToolbarItemLabel|string} label - The toolbar label. Either a function or a literal string.
 * @property {module:components/views/Icon.GLYPHS} glyph - The icon glyph to use.
 * @property {string} method - The App method to invoke when the buttons is pressed.
 * @property {string} className - Extra class name(s) to apply to the button.
 * @property {boolean} separator=false - Produce a separator to the left of the button.
 */


var Toolbar = function (_Component) {
	_inherits(Toolbar, _Component);

	function Toolbar(props) {
		_classCallCheck(this, Toolbar);

		var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, props));

		_this.buttonRefs = {};
		return _this;
	}

	_createClass(Toolbar, [{
		key: 'registerButtonClick',
		value: function registerButtonClick(button, key) {
			return function (event) {
				var args = button.arguments || [];

				event.preventDefault();

				if (this.buttonRefs && this.buttonRefs[key]) {
					this.buttonRefs[key].blur();
					this.props.onButtonClick(this.buttonRefs[key], event);
				}

				if (typeof button.method === 'string' && this.props.lib.tools[button.method]) {
					// method is a defined App method (as a string)
					this.props.lib.tools[button.method].apply(null, args);
				} else {
					// method is a custom function. call with app context (unless bound elsewhere)
					button.method.apply(null, args);
				}
			}.bind(this);
		}
	}, {
		key: 'registerButtonRef',
		value: function registerButtonRef(key) {
			return function (ref) {
				if (ref !== null) {
					this.buttonRefs[key] = ref;
				}
			}.bind(this);
		}
	}, {
		key: 'getToolbarButtons',
		value: function getToolbarButtons() {
			var _this2 = this;

			var buttons = [];

			if (this.props.buttons && this.props.buttons.length) {
				this.props.buttons.forEach(function (button, index) {
					var key = 'button-' + index,
					    classes = [],
					    icon,
					    label;

					if (button.icon) {
						icon = _react2.default.createElement(_Icon.Icon, { glyph: button.icon,
							width: 14,
							height: 14 });
					}

					if (button.className) {
						classes.push(button.className);
					}

					if (button.separator) {
						classes.push(_this2.props.settings.classes.toolbar.separator);
					}

					if (typeof button.label === 'function') {
						label = button.label({
							UI: {
								dialog: {
									mode: _this2.props.dialog_mode
								},
								tour_stage: _this2.props.tour_stage
							}
						});
					} else {
						label = button.label;
					}

					buttons.push(_react2.default.createElement(
						'li',
						{ key: key,
							className: classes.join(' ') },
						_react2.default.createElement(
							'button',
							{
								className: _this2.props.settings.classes.button,
								ref: _this2.registerButtonRef(key),
								onClick: _this2.registerButtonClick(button, key) },
							_react2.default.createElement(
								'span',
								null,
								icon,
								label,
								_react2.default.createElement('span', { className: 'circle' })
							)
						)
					));
				});

				return buttons;
			}
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'menu',
				{ className: 'toolbar' },
				_react2.default.createElement(
					'form',
					null,
					_react2.default.createElement(
						'ul',
						null,
						this.getToolbarButtons()
					)
				)
			);
		}
	}]);

	return Toolbar;
}(_react.Component);

Toolbar.propTypes = {
	buttons: _react.PropTypes.arrayOf(_react.PropTypes.object),
	tour_stage: _react.PropTypes.any,
	dialog_mode: _react.PropTypes.string,
	settings: _react.PropTypes.object.isRequired,
	onButtonClick: _react.PropTypes.func,
	lib: _react.PropTypes.object.isRequired
};

exports.default = Toolbar;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Icon = __webpack_require__(16);

var _utils = __webpack_require__(11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tooltip = function (_Component) {
	_inherits(Tooltip, _Component);

	function Tooltip(props) {
		_classCallCheck(this, Tooltip);

		var _this = _possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this, props));

		_this.popper = null;
		_this.ui = {
			tooltip: null
		};
		return _this;
	}

	_createClass(Tooltip, [{
		key: 'refCollector',
		value: function refCollector(ref) {
			this.ui.tooltip = ref;
		}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.updateAttachment();
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate() {
			this.updateAttachment();
		}
	}, {
		key: 'updateAttachment',
		value: function updateAttachment() {
			var options;

			if (this.props.state.show) {
				// merge default options with those assigned via the state change
				options = Object.deepAssign({}, {
					placement: 'top',
					modifiers: {
						flip: ['top', 'bottom'],
						arrow: {
							element: '.arrow'
						}
					}
				}, this.props.state.options);

				this.popper = this.props.attacher(this.props.state.attachment, this.ui.tooltip, options);
			} else {
				if (this.popper) {
					this.popper.destroy();
					this.popper = null;
				}
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var classes, icon;

			classes = [this.props.settings.classes.popup, this.props.settings.classes.tooltip];

			if (!this.props.state.show) {
				classes.push(this.props.settings.classes.hidden);
			} else {
				if (this.props.state.iconGlyph) {
					icon = _react2.default.createElement(_Icon.Icon, { glyph: this.props.state.iconGlyph });
				}
			}

			return _react2.default.createElement(
				'div',
				{
					ref: this.refCollector.bind(this),
					className: classes.join(' ') },
				_react2.default.createElement(
					'div',
					{ className: 'content' },
					_react2.default.createElement(
						'h2',
						null,
						icon,
						_react2.default.createElement(
							'span',
							null,
							this.props.state.title
						)
					),
					_react2.default.createElement('div', { dangerouslySetInnerHTML: (0, _utils.rawMarkup)(this.props.state.content) })
				),
				_react2.default.createElement('span', { className: 'arrow' })
			);
		}
	}]);

	return Tooltip;
}(_react.Component);

Tooltip.propTypes = {
	settings: _react.PropTypes.object.isRequired,
	attacher: _react.PropTypes.func.isRequired,
	state: _react.PropTypes.object.isRequired
};

exports.default = Tooltip;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var View = function (_Component) {
	_inherits(View, _Component);

	function View(props) {
		_classCallCheck(this, View);

		return _possibleConstructorReturn(this, (View.__proto__ || Object.getPrototypeOf(View)).call(this, props));
	}

	_createClass(View, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (typeof this.props.onMount === 'function') {
				this.props.onMount('view_frame');
			}
		}
	}, {
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate() {
			// no. reloads/updates are handled by the view class
			return false;
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'section',
				{ className: 'view',
					ref: (0, _utils.collectRef)(this.props, 'view') },
				_react2.default.createElement('div', { className: 'drag-mask' }),
				_react2.default.createElement('iframe', { ref: (0, _utils.collectRef)(this.props, 'view_frame'),
					src: this.props.settings.view.src })
			);
		}
	}]);

	return View;
}(_react.Component);

View.propTypes = {
	settings: _react.PropTypes.object,
	onMount: _react.PropTypes.func,
	refCollector: _react.PropTypes.func
};

exports.default = View;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _commonPropTypes = __webpack_require__(34);

var _componentUtils = __webpack_require__(126);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DropDown(props) {
	var label = props.field.label || props.field.name;

	return _react2.default.createElement(
		'div',
		{ className: 'field' },
		_react2.default.createElement(
			'label',
			null,
			label
		),
		_react2.default.createElement(
			'select',
			{
				type: 'text',
				name: props.field.name,
				onChange: props.onChange,
				value: props.value,
				ref: props.refCollector },
			(0, _componentUtils.optionValueSet)(props.field.options)
		)
	);
}

DropDown.propTypes = _commonPropTypes.field;

exports.default = DropDown;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _commonPropTypes = __webpack_require__(34);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function TextField(props) {
	var label = props.field.label || props.field.name;

	return _react2.default.createElement(
		'div',
		{ className: 'field' },
		_react2.default.createElement(
			'label',
			null,
			label
		),
		_react2.default.createElement('input', {
			type: 'text',
			name: props.field.name,
			placeholder: props.field.placeholder,
			onChange: props.onChange,
			maxLength: props.field.data.maxlength,
			value: props.value,
			ref: props.refCollector })
	);
}

TextField.propTypes = _commonPropTypes.field;

exports.default = TextField;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _interact = __webpack_require__(69);

var _interact2 = _interopRequireDefault(_interact);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.interact = _interact2.default;

/**
 * Handles draggable/droppable items.
 * @class
 */
var DragDrop = function DragDrop(canvas, settings) {
	var callbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	this._canvas = canvas;
	this.settings = settings;
	this._callbacks = callbacks;

	this.ui = {
		drag: [],
		drop: []
	};
};

DragDrop.prototype = {
	addDragable: function addDragable(element) {
		var _this = this;

		var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		var dragable = new Dragable(element);

		// duplicate settings
		settings = Object.assign({}, settings);

		// make the element draggable
		dragable.setDragable(settings).on('dragstart', function () {
			_this._canvas.classList.add(_this.settings.classes.is_dragging);
			element.classList.add(_this.settings.classes.item_dragging);
		}).on('dragend', function () {
			_this._canvas.classList.remove(_this.settings.classes.is_dragging);
			element.classList.remove(_this.settings.classes.item_dragging);

			if (typeof _this._callbacks.dragEnd === 'function') {
				_this._callbacks.dragEnd(element, data);
			}
		});

		this.ui.drag.push(this._createInstance(element, dragable));
	},

	addDropable: function addDropable(element) {
		var _this2 = this;

		var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		var dropable = new Dropable(element);

		dropable.setDropable(settings).on('dropactivate', function (event) {
			// add active dropzone feedback
			event.target.classList.add(_this2.settings.classes.dropzone_is_active);
		}).on('dragenter', function (event) {
			// feedback the possibility of a drop
			event.target.classList.add(_this2.settings.classes.dropzone_is_target);
			// event.relatedTarget.classList.add('can-drop');
			// event.relatedTarget.textContent = 'Dragged in';
		}).on('dragleave', function (event) {
			// remove the drop feedback style
			event.target.classList.remove(_this2.settings.classes.dropzone_is_target);
			// event.relatedTarget.classList.remove('can-drop');
			// event.relatedTarget.textContent = 'Dragged out';
		}).on('drop', function (event) {
			if (typeof _this2._callbacks.drop === 'function') {
				_this2._callbacks.drop(event.relatedTarget, event.target, data);
			}
		}).on('dropdeactivate', function (event) {
			// remove active dropzone feedback
			event.target.classList.remove(_this2.settings.classes.dropzone_is_active);
			event.target.classList.remove(_this2.settings.classes.dropzone_is_target);
		});

		this.ui.drop.push(this._createInstance(element, dropable));
	},

	resetDragPosition: function resetDragPosition(element) {
		if (element = this.getDragInstance(element)) {
			element.instance.resetPosition();
		}
	},

	getDragInstance: function getDragInstance(element) {
		return this.ui.drag.find(function (item) {
			return item.element === element;
		});
	},

	_createInstance: function _createInstance(element, instance) {
		return {
			element: element,
			instance: instance
		};
	}
};

/*
 * Generically handles the dragging and dropping of individual DOM nodes.
 * Uses interact.js (http://interactjs.io)
 */
var Dragable = function Dragable(element) {
	this._element = element;

	this._x = 0;
	this._y = 0;
};

Dragable.prototype = {
	/**
  * Set up a draggable item.
  */
	setDragable: function setDragable(settings) {
		var _this3 = this;

		return (0, _interact2.default)(this._element).draggable(settings).on('dragmove', settings.onDragMove || function (event) {
			_this3._x += event.dx;
			_this3._y += event.dy;

			_this3._element.style.webkitTransform = _this3._element.style.transform = 'translate(' + _this3._x + 'px, ' + _this3._y + 'px)';
		});
	},

	resetPosition: function resetPosition() {
		this._x = 0;
		this._y = 0;

		this._element.style.webkitTransform = this._element.style.transform = 'translate(0, 0)';
	}
};

/*
 * Generically handles drop zones in the DOM.
 * Uses interact.js (http://interactjs.io)
 */
var Dropable = function Dropable(element) {
	this._element = element;
};

Dropable.prototype = {
	/**
  * Set up a draggable item.
  */
	setDropable: function setDropable(settings) {
		return (0, _interact2.default)(this._element).dropzone(settings);
	}
};

exports.default = DragDrop;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Takes multiple functions and returns a function which invokes them consecutively
 * with the same argument signature: (prop) `value`, `propname`, `droplet_name`, `droplet_type`.
 */
function chain() {
	var args = Array.prototype.slice.call(arguments);

	return function (value, propname, droplet_name, droplet_type) {
		var _this = this;

		var test = true;

		// run each function in the chain
		args.forEach(function (fn) {
			if (!fn.apply(_this, [value, propname, droplet_name, droplet_type])) {
				test = false;
			}
		});

		return test;
	};
}

/**
 * Asserts the `test` value is truthy. In the case that it fails, an Error is thrown.
 * @param {boolean} test - Test expression result
 * @param {string} propname - The name of the property being tested
 * @param {string} message - The message, in case of failure. Will be appended to a general
 * error message.
 * @param {string} [droplet_name] - The name of the Droplet being tested
 * @param {string} [toplet_type] - The dropletType attribute of the Droplet being tested
 */
function assert(test, propname, message, droplet_name, droplet_type) {
	var error, prop_id;

	if (!test) {
		if (droplet_name) {
			prop_id = '"' + droplet_name + '"' + (droplet_type ? ' (' + droplet_type + ')' : '');
		}

		error = 'Error in Droplet' + (prop_id ? ' ' + prop_id + ' ' : ' ') + 'prop "' + propname + '". ' + message;
		throw new Error(error);
	} else {
		return true;
	}
}

function isRequired(value, prop, droplet_name, droplet_type) {
	return assert(typeof value !== 'undefined', prop, 'Value is required.', droplet_name, droplet_type);
}

function stringNotEmpty(value, prop, droplet_name, droplet_type) {
	return assert(typeof value !== 'undefined' && value !== '', prop, 'Value cannot be empty.', droplet_name, droplet_type);
}

function string(value, prop, droplet_name, droplet_type) {
	return assert(typeof value === 'undefined' || typeof value === 'string', prop, 'Value must be a string.', droplet_name, droplet_type);
}

string.isRequired = chain(string, isRequired);
string.notEmpty = chain(string, stringNotEmpty);
string.notEmpty.isRequired = chain(string, stringNotEmpty, isRequired);

function object(value, prop, droplet_name, droplet_type) {
	return assert(typeof value === 'undefined' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object', prop, 'Value must be an object.', droplet_name, droplet_type);
}

object.isRequired = chain(object, isRequired);

function array(value, prop, droplet_name, droplet_type) {
	return assert(Array.isArray(value), prop, 'Value must be an array.', droplet_name, droplet_type);
}

array.isRequired = chain(array, isRequired);

function arrayOf() {}

arrayOf.string = chain(
// test for an array
array,
// test array values are all strings
function (value, prop, droplet_name, droplet_type) {
	var test = true,
	    a;

	for (a = 0; a < value.length; a += 1) {
		test = test ? typeof value[a] === 'string' : test;
	}

	return assert(test, prop, 'Value must be an array containing only strings', droplet_name, droplet_type);
});

arrayOf.string.isRequired = chain(arrayOf.string, isRequired);

exports.default = {
	_chain: chain,
	_assert: assert,
	string: string,
	object: object,
	array: array,
	arrayOf: arrayOf,
	isRequired: isRequired,
	stringNotEmpty: stringNotEmpty
};

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _constants = __webpack_require__(8);

var _actions = __webpack_require__(37);

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Handle production of tour dialogs.
 * @param {UI} parent - Parent UI class instance.
 * @class
 */
var Tour = function Tour(parent) {
	this._parent = parent;
};

Tour.prototype = {
	/**
  * Produce the tour introduction.
  */
	intro: function intro() {
		return this._parent._showDialog(_constants.dialogModes.GENERAL, this._parent.dialogs.intro).then(this._parent._hideDialog.bind(this._parent));
	},

	/**
  * Starts the tour (but will continue if paused).
  */
	start: function start() {
		return this._progressTour();
	},

	/**
  * Starts or progreses the tour (by one dialog).
  * @private
  */
	_progressTour: function _progressTour() {
		var _this = this;

		var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

		var state;

		// get next tour item from state or default
		if (index === null) {
			state = this._parent._store.getState().UI;
			index = state.tour_stage !== null ? state.tour_stage + 1 : 0;
		}

		if (this._parent.dialogs.tour.length - 1 >= index) {
			this._setTourStage(index);
			return this._showTourElement(index).then(function (dialog) {
				_this._parent._hideDialog();

				// if action is pause, will pause the tour by doing nothing
				if (dialog.action === 'cancel') {
					// end the tour
					_this._setTourStage(null);
				} else if (dialog.action !== 'pause') {
					// progress the tour
					_this._progressTour(index + 1);
				}
			});
		} else {
			// end of tour - set stage to null and hide dialog
			this._setTourStage(null);
			return this._parent._hideDialog();
		}
	},

	/**
  * Show a specific indexed element of the tour.
  * @private
  */
	_showTourElement: function _showTourElement(index) {
		return this._parent._showDialog(_constants.dialogModes.TOUR, this._parent.dialogs.tour[index]);
	},


	/**
  * Set the tour stage index (using Redux).
  * @private
  */
	_setTourStage: function _setTourStage(stage) {
		this._parent._store.dispatch(_actions2.default.setTourStage(stage));
	}
};

exports.default = Tour;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(72);

var _reactRedux = __webpack_require__(15);

var _popper = __webpack_require__(70);

var _popper2 = _interopRequireDefault(_popper);

var _DragDrop = __webpack_require__(152);

var _DragDrop2 = _interopRequireDefault(_DragDrop);

var _Communicator = __webpack_require__(47);

var _Communicator2 = _interopRequireDefault(_Communicator);

var _Tour = __webpack_require__(154);

var _Tour2 = _interopRequireDefault(_Tour);

var _Template = __webpack_require__(36);

var _Template2 = _interopRequireDefault(_Template);

var _Icon = __webpack_require__(16);

var _CanvasContainer = __webpack_require__(128);

var _CanvasContainer2 = _interopRequireDefault(_CanvasContainer);

var _actions = __webpack_require__(37);

var _actions2 = _interopRequireDefault(_actions);

var _dialogs = __webpack_require__(77);

var _dialogs2 = _interopRequireDefault(_dialogs);

var _constants = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Handles User Interface components and acts as the main controller.
 * @class
 */
var UI = function UI(parent, settings, refs, data, store, template) {
	/**
  * @private
  */
	this._parent = parent;

	/**
  * Settings as defined when instantiating. Inherits from {@link App.defaults}
  */
	this.settings = settings;

	/**
  * @private
  */
	this._refs = refs;

	/**
  * @private
  */
	this._data = data;

	/**
  * @private
  */
	this._store = store;

	/**
  * @private
  */
	this._template = template;

	/**
  * Dialog objects for use with {@link App#dialog}
  */
	this.dialogs = (0, _dialogs2.default)(settings);

	// UI class specific data entries
	this._data.UI = {
		dragdrop: {
			// droplets dragdrop class instance
			droplets: {}
		},

		// the current viewport width
		vp_width: 0,

		// the drag handle position
		dragHandlePosition: 0,

		// has the drag handle been moved?
		dragHandleMoved: false
	};

	this._comms = new _Communicator2.default('app', window.location.origin, {
		message: this._handleAppMessage.bind(this)
	});

	this._tour = new _Tour2.default(this);

	// set up library methods for passing to React components
	this.libraryMethods = {
		getDropletById: this.getDropletById.bind(this),
		setUIPopperAttachment: this._setUIPopperAttachment.bind(this),
		zoneDetachAttachment: this.zoneDetachAttachment.bind(this),
		zoneGetAttachment: this.zoneGetAttachment.bind(this),
		isValidDrop: this._isValidDrop.bind(this),
		tools: {
			dialog: this._parent.dialog.bind(this._parent),
			hideDialog: this._hideDialog.bind(this),
			startTour: this._tour.start.bind(this._tour),
			reset: this._parent.reset.bind(this._parent),
			updateView: this._updateView.bind(this)
		}
	};

	// perform bindings for methods commonly used within promises
	this._hideDialog = this._hideDialog.bind(this);
	this._showDialog = this._showDialog.bind(this);

	// show introduction (or not)
	if (this.settings.showIntro) {
		this._tour.intro();
	}

	// general queues
	this.queues = {
		dragdropBindings: []
	};

	window.addEventListener('resize', this._handleWindowResize.bind(this));
}; /**
    * @typedef DialogData
    * @property {string} title - The title of the dialog.
    * @property {array|string} message - Either a single string or an array of strings, defining
    * each paragraph of the dialog message. Basic HTML is allowed.
    * @property {FormButton[]|undefined} buttons - An array of FormButton buttons, or leave undefined
    * to use the default "OK" button.
    */


UI.prototype = {
	/**
  * Sends render() call to the React canvas.
  * @private
  */
	render: function render() {
		this._canvas = (0, _reactDom.render)(_react2.default.createElement(
			_reactRedux.Provider,
			{ store: this._store },
			_react2.default.createElement(_CanvasContainer2.default, {
				data: this._data,
				settings: this.settings,
				refCollector: this._refCollector.bind(this),
				onMount: this._mountEvent.bind(this),
				onAttachmentClick: this._handleAttachmentClick.bind(this),
				onDropletEvent: this._handleDropletEvent.bind(this),
				onDropZoneEvent: this._handleDropZoneEvent.bind(this),
				onDragHandleEvent: this._handleDragHandleEvent.bind(this),
				onButtonClick: this._handleButtonClick.bind(this),
				lib: this.libraryMethods })
		), this._refs.ui.app);
	},

	/**
  * Handles messages sent via the Communicator class (mainly from the View class).
  * @param {object} message - Data, as sent by the originator
  * @param {string} id - Message ID.
  * @private
  */
	_handleAppMessage: function _handleAppMessage(message, id) {
		switch (message.cmd) {
			case 'dialog':
				// a dialog is being requested
				this._showCommunicatorDialog(message.data.title, message.data.message, message.data.buttons, id);
				break;
		}
	},

	/**
  * @param {string} mode - One of the dialogModes modes.
  * @param {DialogData} data - Relevant data to store for the dialog to use.
  * @returns {DialogPromise} a Promise which will resolve with the dialog results.
  * @description
  *	Displays a dialog element. In this case that no callbacks (`onDialogComplete` or
  * `onDialogCancel` are defined, a Promise is returned, the resolve/reject methods
  * of which denote completion or cancellation of the dialog.
  * @private
  */
	_showDialog: function _showDialog(mode, data) {
		var _this = this;

		return new Promise(function (resolve) {
			_this._store.dispatch(_actions2.default.setDialogMode(mode, data, function (data, action, action_data) {
				resolve({ data: data, action: action, action_data: action_data });
			}, function () {
				resolve({ action: 'cancel' });
			}));
		});
	},

	/**
  * @description
  * Hides the dialog (after a short timeout) - uses state comparison to ensure
  * the dialog being hidden isn't a new one.
  * @private
  */
	_hideDialog: function _hideDialog() {
		var state = this._store.getState().UI.dialog;

		window.setTimeout(function () {
			var inner_state = this._store.getState().UI.dialog;

			if (state.id === inner_state.id) {
				// still the same dialog - close it
				this._store.dispatch(_actions2.default.setDialogMode(_constants.dialogModes.NONE));
			}
		}.bind(this), 300);
	},

	_showCommunicatorDialog: function _showCommunicatorDialog(title, message, buttons, comms_id) {
		var _this2 = this;

		this._showDialog(_constants.dialogModes.GENERAL, {
			title: title,
			message: message,
			buttons: buttons
		}).then(function (dialog) {
			_this2._hideDialog();

			if (dialog) {
				// submit/custom callback
				_this2._comms.send('view', {
					cmd: _constants.messageCommands.DIALOG_CALLBACK,
					data: dialog.data,
					action: dialog.action,
					action_data: dialog.action_data
				}, comms_id);
			} else {
				// cancel callback
				_this2._comms.send('view', {
					cmd: _constants.messageCommands.DIALOG_CALLBACK
				}, comms_id);
			}
		});
	},


	/**
  * @param {string} collection - The element's collection name.
  * @param {HTMLElement} element - The element being collected.
  * @param {string} key - The collection's key name.
  * Element reference collector. Collects DOM elements from React components.
  * Bind an element reference using the ref attribute and collectRef from utils.js
  * @private
  */
	_refCollector: function _refCollector(collection, element, key) {
		if (element !== null) {
			if (typeof key === 'string') {
				if (typeof this._refs.components[collection] === 'undefined') {
					this._refs.components[collection] = {};
				}

				this._refs.components[collection][key] = element;
			} else {
				this._refs.components[collection] = element;
			}
		}
	},

	/**
  * @param {string} collection - The element's collection name.
  * @param {string} key - The collection's key name.
  * @description
  * Captures mount events from React components by collection/key identifiers.
  * Identifiers are the same as the ones stored with App#_refCollector
  * @private
  */
	_mountEvent: function _mountEvent(collection, key) {
		if (this._getReferencedElement(collection, key)) {
			// valid component mounted
			switch (collection) {
				case 'canvas':
					// add drag binding for the drag handle
					this._queueDragDropBinding('drag', 'drag_handle', null, {
						onDragMove: this._handleDragHandleEvent.bind(this)
					});

					// process all drag/drop bindings
					this._setDragDropBindings();
					this._refs.mounted.canvas = true;
					break;

				case 'template':
					// this._queueDragDropBinding('drop', collection, key);
					this._refs.mounted.template = true;
					break;

				case 'droplet':
					// this._queueDragDropBinding('drag', collection, key);
					break;

				case 'dropzone':
					// this._queueDragDropBinding('drop', 'dropzone_target', key);
					break;

				case 'view_frame':
					this._comms.registerGuestAddress('view', this._refs.components[collection].contentWindow);

					this._refs.mounted.view_frame = true;
			}

			if (this._refs.mounted.canvas && this._refs.mounted.template && this._refs.mounted.view_frame) {
				// all required refs mounted - set active
				this._store.dispatch(_actions2.default.setUIState(_constants.uiStates.ACTIVE));

				// run initial size calculations
				this._handleWindowResize();
			}
		} else {
			throw new Error('Component mount event called but ref was not collected. ' + 'component: ' + collection + (key ? '/' + key : ''));
		}
	},

	/**
  * @param {string} type - Either 'drag' or 'drop'.
  * @param {string} collection - The ref collection.
  * @param {string} key - The ref key, within the collection.
  * @param {ojbect} settings - The settings for the interaction.
  * @description
  * Queues a drag/drop DOM binding till the mount event for the Canvas component.
  * This is done because the canvas is relied upon as the container for dragging.
  * @private
  */
	_queueDragDropBinding: function _queueDragDropBinding(type, collection, key, settings) {
		if (this._refs.components.canvas) {
			// canvas already exists - immediately bind
			this._setDragDropBindings([{ type: type, collection: collection, key: key, settings: settings }]);
		} else {
			// push to queue
			this.queues.dragdropBindings.push({ type: type, collection: collection, key: key, settings: settings });
		}
	},

	/**
  * Processes queued up drag/drop bindings created by UI#_queueDragDropBindings.
  * @param {array} [queue] - The bindings queue.
  * @private
  */
	_setDragDropBindings: function _setDragDropBindings() {
		var _this3 = this;

		var queue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.queues.dragdropBindings;

		// bind dragDrop handlers to the elements in the queue
		this._data.UI.dragdrop.droplets = new _DragDrop2.default(this._refs.components.canvas, this.settings, {
			drop: this._handleDropletDrop.bind(this),
			dragEnd: function dragEnd(element) {
				_this3._data.UI.dragdrop.droplets.resetDragPosition(element);
			}
		});

		queue.forEach(function (item) {
			var ref = _this3._getReferencedElement(item.collection, item.key),
			    data;

			if (item.collection === 'dropzone_target') {
				data = {
					zone_id: item.key
				};
			}

			// create a DragDrop instance and assign to the pallet item data
			if (item.type === 'drag') {
				_this3._data.UI.dragdrop.droplets.addDragable(ref, item.settings, data);
			} else if (item.type === 'drop') {
				_this3._data.UI.dragdrop.droplets.addDropable(ref, Object.deepAssign({}, {
					accept: _this3.settings.selectors.droplet
				}, item.settings), data);
			}
		});
	},

	/**
  * Handles drops of droplets into drop zones. Will attach to the zone
  * if the drop is valid.
  * @param {HTMLElement} element - The element being dragged.
  * @param {HTMLElement} target - The target being dropped onto.
  * @param {object} data - data object, as set with addDragable/addDropable.
  * @private
  */
	_handleDropletDrop: function _handleDropletDrop(element, target, data) {
		var drop_zone = this.getDropZoneById(data.zone_id),
		    droplet = this.getDropletById(element.id);

		return this.attachDropletToDropZone(droplet, drop_zone);
	},

	/**
  * Handle a click on a Drop Zone attachment item. May produce an editor window.
  * @param {Droplet} droplet - The Droplet.
  * @param {DropZone} drop_zone - The Drop Zone.
  * @param {number} attachment_index - The Drop Zone's attachment index, if it applies.
  * @private
  */
	_handleAttachmentClick: function _handleAttachmentClick(droplet, drop_zone, attachment_index) {
		var _this4 = this;

		var state = this._store.getState();

		if (state.UI.active_droplet_id === '') {
			// only allow editing if there is no droplet placement occuring
			this._showDialog(_constants.dialogModes.EDIT_DROPLET, {
				droplet_id: droplet.id,
				zone_id: drop_zone.id,
				attachment_index: attachment_index
			}).then(function (dialog) {
				_this4._hideDialog();

				if (dialog.action === 'remove_droplet') {
					_this4.zoneDetachAttachment(dialog.action_data.zone_id, dialog.action_data.attachment_index);
				} else if (dialog.action !== 'cancel') {
					_this4._commitDropletIntoDropZone.apply(_this4, [dialog.data]);
				}
			}.bind(this));
		}
	},

	/**
  * Handles events being fired from a Droplet
  * @param {ReactEvent} event - The event object.
  * @param {Droplet} droplet - The Droplet.
  * @private
  */
	_handleDropletEvent: function _handleDropletEvent(event, droplet) {
		var state;

		if (event.type === 'click') {
			state = this._store.getState();

			if (state.UI.active_droplet_id !== droplet.id) {
				this._store.dispatch(_actions2.default.setActiveDroplet(droplet.id));
			} else {
				this._store.dispatch(_actions2.default.setActiveDroplet(''));
			}
		}
	},

	/**
  * Handles events being fired from a Drop Zone.
  * @param {ReactEvent} event - The event object.
  * @param {DropZone} drop_zone - The Drop Zone.
  * @private
  */
	_handleDropZoneEvent: function _handleDropZoneEvent(event, drop_zone) {
		var state = this._store.getState(),
		    droplet;

		if (event.type === 'click' && state.UI.active_droplet_id !== '' && (droplet = this.getDropletById(state.UI.active_droplet_id))) {
			this.attachDropletToDropZone(droplet, drop_zone);
		}
	},

	/**
  * Handles events from the drag handle (between template and view containers).
  * @param {ReactEvent} event - The event object.
  * @private
  */
	_handleDragHandleEvent: function _handleDragHandleEvent(event) {
		var width;

		switch (event.type) {
			case 'mouseenter':
			case 'mouseleave':
				if (!this._data.UI.dragHandleMoved) {
					if (event.type === 'mouseenter') {
						this._store.dispatch(_actions2.default.setTooltipContent('Drag handle', '<b>Drag</b> this handle to resize the template and the view.' + ' <b>Press</b> to toggle the full page view.', _Icon.GLYPHS.RESIZE_WIDTH));
						this._store.dispatch(_actions2.default.showTooltip(this._getReferencedElement('drag_handle'), {
							placement: 'left',
							modifiers: {
								flip: ['left', 'right']
							}
						}));
					} else {
						this._store.dispatch(_actions2.default.hideTooltip());
					}
				}
				break;

			case 'dragmove':
				// incrememt dragHandlePosition based on x delta from interact instance
				this._data.UI.dragHandlePosition += event.dx;

				if (!this._data.UI.dragHandleMoved) {
					// remove the tooltip, in case it's still around
					this._data.UI.dragHandleMoved = true;
					this._store.dispatch(_actions2.default.hideTooltip());
				}

				// figure out handle position in % of the screen and convert it to percent,
				// then send straight to _setTemplateViewRatio function
				this._setTemplateViewRatio((this._data.UI.drag_handle_x + this._data.UI.dragHandlePosition) / this._data.UI.vp_width * 100);

				break;

			case 'mouseup':
			case 'touchend':
				if (this._data.UI.dragHandlePosition < 5 && this._data.UI.dragHandlePosition > -5) {
					// little movement - assume a click/tap occured
					width = this._getReferencedElement('drag_handle').offsetWidth;

					if (this._data.UI.drag_handle_x < width) {
						// set to 50/50
						this._setTemplateViewRatio(50);
					} else {
						// set to 0/100
						this._setTemplateViewRatio(0);
					}
				}

				// update metrics whenever we're stopping
				this._handleWindowResize();

				break;
		}
	},

	/**
  * Updates various metrics when the window has been resized
  * @private
  */
	_handleWindowResize: function _handleWindowResize() {
		this._data.UI.drag_handle_x = this._getReferencedElement('drag_handle').offsetLeft;
		this._data.UI.vp_width = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);

		// reset dragHandlePosition because the metrics have changed
		this._data.UI.dragHandlePosition = 0;
	},

	/**
  * Generically handles the click of any button within the UI.
  * @param {HTMLElement} button - The button being clicked.
  * @param {ReactEvent} event - The event object.
  */
	_handleButtonClick: function _handleButtonClick(button, event) {
		var offset = {},
		    rect,
		    circle;

		if (button && event && event.pageX && event.pageY && (circle = button.querySelector(this.settings.selectors.button_circle))) {
			// get metrics and offset by scroll
			rect = button.getBoundingClientRect();
			rect.leftScrolled = rect.left + window.pageXOffset;
			rect.topScrolled = rect.top + window.pageYOffset;

			// calculate cursor offset on the button
			offset.left = event.pageX - (rect.left + window.pageXOffset);
			offset.top = event.pageY - (rect.top + window.pageYOffset);

			// position the circle based on the pointer position on the button
			circle.classList.remove(this.settings.classes.button_animate);
			circle.style.left = offset.left - circle.offsetWidth / 2 + 'px';
			circle.style.top = offset.top - circle.offsetHeight / 2 + 'px';
			circle.classList.add(this.settings.classes.button_animate);
		}
	},

	/**
  * @param {number} ratio - % ratio for the template
  * @description
  * Sets the template/view ratio by giving the template container a % width and
  * adjusting the view container accordingly.
  * @private
  */
	_setTemplateViewRatio: function _setTemplateViewRatio(ratio) {
		this._refs.components.template.style.flexBasis = ratio + '%';
		this._refs.components.view.style.flexBasis = Math.abs(ratio - 100) + '%';
	},

	/**
  * Checks to see if a Droplet drop on a Drop Zone is valid. I.e. it can be dropped.
  * @param {Droplet} droplet - The Droplet being dropped.
  * @param {DropZone} drop_zone - The Drop Zone being dropped into.
  * @private
  */
	_isValidDrop: function _isValidDrop(droplet, drop_zone) {
		return drop_zone.willAccept(droplet, this._store);
	},

	/**
  * Optionally displays an editing dialog and then attaches the Droplet to a Drop Zone.
  * @param {Droplet} droplet - The Droplet to attach
  * @param {DropZone} drop_zone - The Drop Zone to attach it to.
  */
	attachDropletToDropZone: function attachDropletToDropZone(droplet, drop_zone) {
		var _this5 = this;

		// clear active droplet
		this._store.dispatch(_actions2.default.setActiveDroplet(''));

		// check if valid drop
		if (this._isValidDrop(droplet, drop_zone)) {
			if (droplet.editable) {
				// show edit dialog before adding the attachment
				this._showDialog(_constants.dialogModes.EDIT_DROPLET, {
					droplet_id: droplet.id,
					zone_id: drop_zone.id,
					attachment_index: null
				}).then(function (dialog) {
					_this5._hideDialog();

					if (dialog.action === 'submit') {
						_this5._commitDropletIntoDropZone.apply(_this5, [dialog.data]);
						_this5._postDropletAttachment(droplet, dialog.data);
					}
				});
			} else {
				// add attachment without dialog
				this.zoneAddAttachment(drop_zone.id, droplet.id, droplet.data);

				this._postDropletAttachment(droplet, droplet.data);
			}

			return true;
		} else {
			if (this.settings.dropZone.warnOnBadPlacement) {
				this._showDialog(_constants.dialogModes.GENERAL, this.dialogs.dropletBadPlacement).then(this._hideDialog);
			}

			return false;
		}
	},

	/**
  * Perform actions after Droplet attachment.
  * @param {Droplet} droplet - The Droplet instance.
  * @param {object} data - The Droplet data to be set into the Drop Zone.
  * @private
  */
	_postDropletAttachment: function _postDropletAttachment(droplet, data) {
		var state = this._store.getState(),
		    keys = Object.keys(state.zones),
		    notice = false,
		    key,
		    droplet_output;

		// should we display a "first droplet" notice?
		if (this.settings.dropZone.noticeOnFirstPlacement && !state.app.first_valid_drop && keys.length > 0) {
			// set first droplet state
			this._store.dispatch(_actions2.default.completeFirstDrop());

			// format the droplet for display
			droplet_output = _Template2.default.entities(_Template2.default.renderDroplet(droplet, Object.deepAssign({}, droplet.data, data), null, false));

			// show dialog
			this._showDialog(_constants.dialogModes.GENERAL, this.dialogs.firstDropletDrop(droplet_output)).then(this._hideDialog);
		}

		// should we display a "last droplet" notice?
		if (this.settings.dropZone.noticeOnLastPlacement && !state.app.last_valid_drop && keys.length === this._data.pallet.length) {
			notice = true;

			// check zones all have placements
			for (key in state.zones) {
				if (state.zones[key].attachments.length === 0) {
					notice = false;
					break;
				}
			}

			if (notice) {
				// show set last drop state
				this._store.dispatch(_actions2.default.completeLastDrop());

				// show dialog
				this._showDialog(_constants.dialogModes.GENERAL, this.dialogs.lastDropletDrop).then(this._hideDialog);
			}
		}
	},

	/**
  * @param {object} data - The Droplet data to be set into the Drop Zone.
  * @description
  * Called after editing dialog has been completed, either adds a new
  * Drop Zone attachment or edits an existing one.
  * @private
  */
	_commitDropletIntoDropZone: function _commitDropletIntoDropZone(data) {
		var dialog = this._store.getState().UI.dialog;

		// reset dialog state to nothing
		this._hideDialog();

		// droplet being edited prior to or during attatchment
		if (dialog.data.attachment_index === null) {
			// no attachment index - this is a new drop
			this.zoneAddAttachment(dialog.data.zone_id, dialog.data.droplet_id, data);
		} else {
			this.zoneEditAttachment(dialog.data.zone_id, dialog.data.attachment_index, data);
		}
	},

	/**
  * Adds a Drop Zone attachment.
  * @param {string} zone_id - The Drop Zone ID.
  * @param {string} droplet_id - The Droplet ID.
  * @param {object} data - The droplet data to be set into the Drop Zone.
  */
	zoneAddAttachment: function zoneAddAttachment(zone_id, droplet_id, data) {
		this._store.dispatch(_actions2.default.zoneAddAttachment(zone_id, droplet_id, true, data));

		if (this.settings.view.autoUpdate) {
			this._updateView();
		}
	},

	/**
  * Edits an existing Drop Zone attachment at `attachment_index` index.
  * @param {string} zone_id - The Drop Zone ID.
  * @param {number} attachment_index - The existing attachment index.
  * @param {object} data - The new droplet data to be replaced into the Drop Zone.
  */
	zoneEditAttachment: function zoneEditAttachment(zone_id, attachment_index, data) {
		this._store.dispatch(_actions2.default.zoneEditAttachment(zone_id, attachment_index, data));

		if (this.settings.view.autoUpdate) {
			this._updateView();
		}
	},

	/**
  * Detaches a Droplet attachment from a Drop Zone by its `attachment_index` index.
  * @param {string} zone_id - Drop Zone ID.
  * @param {number} attachment_index - The existing attachment index.
  */
	zoneDetachAttachment: function zoneDetachAttachment(zone_id, attachment_index) {
		this._store.dispatch(_actions2.default.zoneDetachAttachment(zone_id, attachment_index));
	},

	/**
  * Retrieve a zone's attachment by its `attachment_index` index.
  * @param {string} zone_id - Drop Zone ID.
  * @param {number} attachment_index - The existing attachment index.
  */
	zoneGetAttachment: function zoneGetAttachment(zone_id, attachment_index) {
		var zone,
		    state = this._store.getState();

		if (state.zones && (zone = state.zones[zone_id]) && zone.attachments && zone.attachments.length > attachment_index) {
			return zone.attachments[attachment_index];
		}

		return null;
	},

	/**
  * Sends a key the View frame for updating.
  */
	_updateView: function _updateView() {
		var state = this._store.getState();

		this._comms.send('view', {
			cmd: _constants.messageCommands.RELOAD,
			data: {
				markup: this._template.renderAsHTML(state.zones)
			}
		});
	},

	/**
  * Obtains an element stored in the internal refs collection
  */
	_getReferencedElement: function _getReferencedElement(collection, key) {
		var ref;

		if ((typeof key === 'undefined' || !key) && (ref = this._refs.components[collection]) || (ref = this._refs.components[collection][key])) {
			return ref;
		} else {
			throw new Error('Referenced element at ' + collection + '(' + key + ') could not be found.');
		}
	},

	/**
  * Retrieves a Droplet instance by its ID.
  * @param {string} id - ID of the Droplet to retrieve.
  */
	getDropletById: function getDropletById(id) {
		return this._data.pallet.find(function (element) {
			return element.id === id;
		});
	},

	/**
  * Retrieves a Drop Zone instance by its ID.
  * @param {string} id - ID of the Drop Zone to retrieve.
  */
	getDropZoneById: function getDropZoneById(id) {
		return this._data.drop_zones[id] || null;
	},

	/**
  * @param {HTMLElement} attachment - The element to attach to.
  * @param {HTMLElement} element - The element being attached.
  * @param {object} options - The popper `options` object (see link).
  * @description
  * Using 'popper', sets the an attachment from the `attachment` node to an `element`
  * defining the "popup" to be displayed.
  * @see https://popper.js.org/popper-documentation.html#new_Popper_new
  * @private
  */
	_setUIPopperAttachment: function _setUIPopperAttachment(attachment, element, options) {
		var attached;

		if (attachment instanceof window.HTMLElement) {
			attached = attachment;
		} else if (attachment && attachment.selector) {
			attached = document.querySelector(attachment.selector);
		}

		if (attached) {
			return new _popper2.default(attached, element, attachment.options || options);
		} else {
			throw new Error('_setUIPopperAttachment: Attachment or selector could not be found.');
		}
	}
};

exports.default = UI;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// JS Polyfills - doesn't export anything, just modifies existing Object specs
Object.deepAssign = function (target, varArgs) {
	'use strict';

	var to, from, index, key;

	if (target == null) {
		// TypeError if undefined or null
		throw new TypeError('Cannot convert undefined or null to object');
	}

	to = typeof varArgs !== 'undefined' && Array.isArray(varArgs) && arguments.length === 2 ? Array(target) : // arrays to retain their identity
	Object(target); // otherwise use an object

	for (index = 1; index < arguments.length; index++) {
		from = arguments[index];

		if (from != null || typeof from === 'undefined') {
			for (key in from) {
				if (from.hasOwnProperty(key)) {
					if (_typeof(from[key]) === 'object' && from[key] != null) {
						to[key] = Object.deepAssign(Array.isArray(from[key]) ? [] : {}, to[key], from[key]);
					} else {
						to[key] = from[key];
					}
				}
			}
		}
	}

	return to;
};

/**
 * Curry implementation for functions
 */
Function.prototype.curry = function () {
	var args = Array.prototype.slice.call(arguments),
	    fn = this;

	return function () {
		// return result of original function with curried arguments before invocation arguments
		return fn.apply(null, args.concat(Array.prototype.slice.call(arguments)));
	};
};

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _redux = __webpack_require__(33);

var _defaultState = __webpack_require__(76);

var _defaultState2 = _interopRequireDefault(_defaultState);

var _constants = __webpack_require__(8);

var _Storage = __webpack_require__(80);

var _Storage2 = _interopRequireDefault(_Storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dialog_id = 0,
    storage = new _Storage2.default('tag_app');

/**
 * Sets application state values.
 * @private
 */
function app() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _defaultState2.default.app;
	var action = arguments[1];

	var active, newstate, key;

	switch (action.type) {
		// set ui state
		case _constants.actionTypes.UI_STATE:
			// set 'active' flag based on the ui_state value
			switch (action.ui_state) {
				case _constants.uiStates.ACTIVE:
					active = true;
					break;

				default:
					active = false;
			}

			newstate = Object.assign({}, state, {
				ui_state: action.ui_state,
				active: active
			});

			return storeState(newstate, 'app');

		case _constants.actionTypes.RESET_APP:
			newstate = Object.assign({}, state, {
				first_valid_drop: false,
				last_valid_drop: false
			});

			return storeState(newstate, 'app');

		case _constants.actionTypes.COMPLETE_FIRST_DROP:
		case _constants.actionTypes.COMPLETE_LAST_DROP:
			if (action.type === _constants.actionTypes.COMPLETE_FIRST_DROP) {
				newstate = Object.assign({}, state, {
					first_valid_drop: true
				});
			} else {
				newstate = Object.assign({}, state, {
					last_valid_drop: true
				});
			}

			return storeState(newstate, 'app');

		default:
			return state;
	}
}

/**
 * Sets drop zone state values
 * @private
 */
function zones() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _defaultState2.default.zones;
	var action = arguments[1];

	var zones = Object.assign({}, state);

	switch (action.type) {
		case _constants.actionTypes.ZONE_ADD_ATTACHMENT:
			if (!zones[action.id]) {
				zones[action.id] = {
					attachments: []
				};
			}

			// attach the droplet
			zones[action.id].attachments.push({
				droplet_id: action.droplet_id,
				data: action.data
			});

			break;

		case _constants.actionTypes.ZONE_EDIT_ATTACHMENT:
			if (zones[action.id].attachments[action.attachment_index]) {
				zones[action.id].attachments[action.attachment_index].data = action.data;
			}

			break;

		case _constants.actionTypes.ZONE_DETACH_ATTACHMENT:
			// detach the attachment by index
			if (action.attachment_index !== null && action.attachment_index < zones[action.id].attachments.length) {
				zones[action.id].attachments.splice(action.attachment_index, 1);
			}

			break;

		case _constants.actionTypes.ZONE_CLEAR_ALL_ATTACHMENTS:
			zones = {};
			break;

		default:
			return state;
	}

	return storeState(zones, 'zones');
}

/**
 * Sets UI state values. This state collection is non persistant and will not be stored
 * within local/session storage. Due to that fact, it is safe to place circular references,
 * functions and large quantities of data in here.
 * @private
 */
function UI() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _defaultState2.default.UI;
	var action = arguments[1];

	switch (action.type) {
		case _constants.actionTypes.SET_DIALOG_MODE:
			return Object.assign({}, state, {
				dialog: {
					mode: action.mode,
					data: action.data,
					onDialogComplete: action.onDialogComplete,
					onDialogCancel: action.onDialogCancel,
					overlay: typeof action.overlay !== 'undefined' ? action.overlay : true,
					attachment: action.attachment,
					id: 'dialog-' + ++dialog_id
				}
			});

		case _constants.actionTypes.SET_TOUR_STAGE:
			return Object.assign({}, state, {
				tour_stage: action.stage
			});

		case _constants.actionTypes.SET_ACTIVE_DROPLET:
			// set the active droplet (i.e. the one that will be "dropped" when a
			// drop zone is next clicked
			return Object.assign({}, state, {
				active_droplet_id: action.droplet_id
			});

		case _constants.actionTypes.SHOW_TOOLTIP:
		case _constants.actionTypes.HIDE_TOOLTIP:
			if (action.type === _constants.actionTypes.SHOW_TOOLTIP) {
				return Object.assign({}, state, {
					tooltip: {
						show: true,
						attachment: action.attachment,
						options: action.options,
						content: state.tooltip.content,
						title: state.tooltip.title,
						iconGlyph: state.tooltip.iconGlyph
					}
				});
			} else {
				return Object.assign({}, state, {
					tooltip: {
						show: false,
						attachment: null,
						options: null,
						content: '',
						title: '',
						iconGlyph: ''
					}
				});
			}

		case _constants.actionTypes.SET_TOOLTIP_CONTENT:
			return Object.assign({}, state, {
				tooltip: {
					show: state.tooltip.show,
					content: action.content,
					title: action.title,
					iconGlyph: action.iconGlyph
				}
			});

		default:
			return state;
	}
}

/**
 * Stores state into local/session storage for recall on reloading the app.
 * @private
 */
function storeState(state, key) {
	var current_state = storage.get('state'),
	    new_state;

	new_state = Object.assign({}, _defaultState2.default, current_state);
	new_state[key] = Object.assign({}, state);
	new_state.UI = null;

	storage.set('state', new_state);

	return state;
}

exports.default = (0, _redux.combineReducers)({
	app: app,
	zones: zones,
	UI: UI
});

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(158)
var ieee754 = __webpack_require__(178)
var isArray = __webpack_require__(180)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(46)))

/***/ }),
/* 160 */,
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(162)(undefined);
// imports
exports.push([module.i, "@import url(//fonts.googleapis.com/css?family=Fira+Mono|Muli:400,700);", ""]);

// module
exports.push([module.i, "/* reset */\n* {\n  box-sizing: border-box; }\n\nhtml, body, div, span, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\nabbr, address, cite, code,\ndel, dfn, em, img, ins, kbd, q, samp,\nsmall, strong, sub, sup, var,\nb, i,\ndl, dt, dd, ol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section, summary,\ntime, mark, audio, video {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  outline: 0;\n  font-size: 100%;\n  vertical-align: baseline;\n  background: transparent;\n  min-height: 0;\n  min-width: 0; }\n\nbody {\n  line-height: 1; }\n\narticle, aside, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section {\n  display: block; }\n\nnav ul {\n  list-style: none; }\n\nblockquote, q {\n  quotes: none; }\n\nblockquote:before, blockquote:after,\nq:before, q:after {\n  content: '';\n  content: none; }\n\na {\n  margin: 0;\n  padding: 0;\n  font-size: 100%;\n  vertical-align: baseline;\n  background: transparent; }\n\n/* change colours to suit your needs */\nins {\n  background-color: #ff9;\n  color: #000;\n  text-decoration: none; }\n\n/* change colours to suit your needs */\nmark {\n  background-color: #ff9;\n  color: #000;\n  font-style: italic;\n  font-weight: bold; }\n\ndel {\n  text-decoration: line-through; }\n\nabbr[title], dfn[title] {\n  border-bottom: 1px dotted;\n  cursor: help; }\n\ntable {\n  border-collapse: collapse;\n  border-spacing: 0; }\n\n/* change border colour to suit your needs */\nhr {\n  display: block;\n  height: 1px;\n  border: 0;\n  border-top: 1px solid #cccccc;\n  margin: 1em 0;\n  padding: 0; }\n\ninput, select {\n  vertical-align: middle; }\n\nbody {\n  font-family: \"Muli\", sans-serif;\n  line-height: 140%;\n  color: #333; }\n\nh1 {\n  font-size: 24px;\n  font-size: 1.5rem; }\n\nh2 {\n  font-size: 22px;\n  font-size: 1.375rem; }\n\nh3 {\n  font-size: 20px;\n  font-size: 1.25rem; }\n\np {\n  margin: .75em 0;\n  font-size: 16px;\n  font-size: 1rem; }\n\np:first-child {\n  margin-top: 0; }\n\np:last-child {\n  margin-bottom: 0; }\n\ncode {\n  font: 16px/120% \"Fira Mono\", monospace; }\n  code span {\n    font-size: 12px;\n    font-size: 0.75rem; }\n\n.view iframe {\n  z-index: 1; }\n\n.overlay,\n.view .drag-mask {\n  z-index: 2; }\n\n.droplet,\n.drag-handle {\n  z-index: 3; }\n\n.dialog {\n  z-index: 4; }\n  .dialog .dialog-container[x-placement] .arrow:before {\n    z-index: 6; }\n  .dialog .dialog-container[x-placement] .arrow:after {\n    z-index: 5; }\n\n.tooltip {\n  z-index: 10; }\n  .tooltip .arrow:before {\n    z-index: 12; }\n  .tooltip .arrow:after {\n    z-index: 11; }\n\n.button:after {\n  z-index: 1; }\n\n.button span {\n  z-index: 2; }\n\n.logo {\n  letter-spacing: 1px; }\n  .logo b {\n    color: #192fce; }\n\n* {\n  user-select: none; }\n\n:not(svg) {\n  cursor: default; }\n\n:focus {\n  outline: none; }\n\n::-moz-focus-inner {\n  border: 0; }\n\n.hidden {\n  display: none; }\n\n/* main layout */\nbody {\n  background-color: #fff; }\n\n.app,\n.tag-canvas {\n  position: absolute;\n  overflow: auto;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  right: 0; }\n\n.tag-canvas {\n  display: flex;\n  flex-direction: column; }\n  .tag-canvas header {\n    flex-shrink: 0; }\n  .tag-canvas .main {\n    display: flex;\n    flex-grow: 1; }\n    .tag-canvas .main > *:not(.drag-handle) {\n      flex-basis: 50%; }\n    .tag-canvas .main .drag-handle {\n      flex-basis: 20px; }\n  .tag-canvas .pallet {\n    flex-shrink: 0; }\n\nheader {\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid #ccc;\n  padding: 5px 10px;\n  background: linear-gradient(to bottom, #f3f3f3 0%, #f1f1f1 100%); }\n  header .logo {\n    margin-right: 1em; }\n  header p {\n    margin: 0; }\n  header .toolbar {\n    margin-left: auto; }\n\n.toolbar ul {\n  list-style: none;\n  display: flex;\n  padding: 0; }\n  .toolbar ul li {\n    margin-left: 5px;\n    padding-left: 5px; }\n    .toolbar ul li.separator {\n      margin-left: 7.5px;\n      padding-left: 9.5px;\n      border-left: 2px solid #ccc; }\n    .toolbar ul li.run .button {\n      border-color: #319f2e;\n      color: #319f2e; }\n      .toolbar ul li.run .button .circle {\n        background-color: #319f2e; }\n      .toolbar ul li.run .button:hover > span {\n        color: #fff;\n        background-color: #51cc4d; }\n\n.toolbar .button {\n  font-weight: bolder;\n  font-size: 14px;\n  font-size: 0.875rem; }\n  .toolbar .button span {\n    background-color: #fff; }\n\n.template {\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  border-right: 1px solid #ccc;\n  background-color: #fcfdcc; }\n  .template .template-inner {\n    overflow: auto;\n    flex-grow: 1; }\n  .template pre {\n    margin: 10px;\n    line-height: 130%;\n    -moz-tab-size: 3;\n    tab-size: 3; }\n    .template pre * {\n      user-select: text;\n      cursor: text; }\n  .template .hljs {\n    font-size: 1.125em;\n    line-height: 130%; }\n    .template .hljs .drop-zone .hljs-string {\n      color: white; }\n  .template .instruction {\n    display: block;\n    flex-shrink: 0;\n    margin: 0;\n    padding: 5px;\n    color: #fff;\n    background-color: #6172ec; }\n\n.view {\n  position: relative;\n  border-left: 1px solid #ccc; }\n  .view iframe,\n  .view .drag-mask {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%; }\n  .view .drag-mask {\n    visibility: hidden;\n    background-color: #fff; }\n\n.dragging .view .drag-mask {\n  visibility: visible;\n  opacity: .7; }\n\n.pallet {\n  display: flex;\n  flex-wrap: wrap;\n  border-top: 1px solid #ccc;\n  padding: 5px 10px;\n  background-color: #eee; }\n  .pallet .droplet {\n    margin: 5px 10px 5px 0; }\n\nbutton::-moz-focus-inner {\n  padding: 0;\n  border: 0; }\n\n.button {\n  -webkit-appearance: none;\n  display: block;\n  border: 0;\n  padding: 0;\n  text-decoration: none;\n  font-size: 14px;\n  font-size: 0.875rem;\n  color: #333;\n  background-color: transparent;\n  cursor: pointer; }\n  .button > span {\n    display: block;\n    overflow: hidden;\n    position: relative;\n    border-radius: 3px;\n    border: 1px solid #ccc;\n    padding: 5px 10px; }\n  .button:hover > span,\n  .button:focus > span {\n    transform: translate(-2px, -2px);\n    box-shadow: 2px 2px rgba(0, 0, 0, 0.2);\n    cursor: pointer;\n    background-color: #eee; }\n  .button span.circle {\n    position: absolute;\n    transform: scale(0);\n    opacity: .7;\n    left: 0;\n    top: 0;\n    width: 100%;\n    padding-top: 100%;\n    border-radius: 50%;\n    background-color: #a0a0a0;\n    pointer-events: none; }\n    .button span.circle.animate {\n      animation: button-circle-out 0.6s cubic-bezier(0.77, 0, 0.175, 1); }\n  .button .icon {\n    margin: 0 5px 1px 0;\n    vertical-align: middle; }\n\n.pseudo-button {\n  display: inline-block;\n  border: 1px solid #ccc;\n  border-radius: 3px;\n  padding: 1px 5px;\n  color: #4d4d4d; }\n  .pseudo-button > * {\n    vertical-align: middle; }\n  .pseudo-button svg {\n    margin-bottom: .15em; }\n  .pseudo-button.run {\n    color: #51cc4d;\n    fill: #51cc4d; }\n\n@keyframes button-circle-out {\n  100% {\n    transform: scale(6);\n    opacity: 0; } }\n\n.drop-zone {\n  display: inline-block;\n  font-family: \"Fira Mono\", monospace; }\n  .drop-zone .target-outer {\n    display: inline-block;\n    position: relative; }\n  .drop-zone .target b {\n    border-radius: 3px;\n    padding: 2px 5px;\n    background-color: #6172ec;\n    line-height: 120%;\n    color: white; }\n  .drop-zone .target.hidden {\n    display: none; }\n  .drop-zone .attachments > * {\n    display: inline-block;\n    margin: 1px;\n    border-radius: 3px;\n    padding: 1px;\n    background-color: #51cc4d; }\n  .drop-zone .attachments .element {\n    display: block; }\n\n.drop-zone.accept .target b,\n.droplet-active .drop-zone.will-accept .target:hover b {\n  background-color: #51cc4d; }\n\n.drop-zone.decline .target b,\n.droplet-active .drop-zone.will-decline .target:hover b {\n  background-color: #ff515c; }\n\n.drop-zone:not(.possible-target) .dropzone-attachment:hover {\n  color: #fff;\n  background-color: #319f2e;\n  cursor: pointer; }\n\n.droplet-active .drop-zone .target b {\n  cursor: pointer;\n  background-color: #192fce; }\n\n.droplet-active .drop-zone .target:hover b {\n  box-shadow: 2px 2px rgba(0, 0, 0, 0.2); }\n\n.droplet {\n  -webkit-appearance: none;\n  border: 0;\n  height: 35px;\n  padding: 0;\n  text-decoration: none;\n  cursor: pointer; }\n  .droplet .label {\n    transition: background-color 0.15s cubic-bezier(0.77, 0, 0.175, 1), color 0.15s cubic-bezier(0.77, 0, 0.175, 1), border-color 0.15s cubic-bezier(0.77, 0, 0.175, 1), opacity 0.5s cubic-bezier(0.77, 0, 0.175, 1);\n    display: flex;\n    align-items: center;\n    opacity: 1;\n    border-radius: 3px;\n    border: 1px solid #a0a0a0;\n    border-left-width: 5px;\n    height: 35px;\n    padding: 5px 10px;\n    line-height: 120%;\n    font-size: 14px;\n    font-size: 0.875rem;\n    background-color: #fff;\n    color: #333;\n    cursor: pointer; }\n    .droplet .label .icon {\n      transition: fill 0.15s cubic-bezier(0.77, 0, 0.175, 1);\n      margin-right: .5em; }\n  .droplet.active .label {\n    color: #fff;\n    background-color: #a0a0a0; }\n    .droplet.active .label .icon {\n      fill: #fff; }\n  .droplet.item-dragging .label {\n    opacity: 0.5;\n    box-shadow: 2px 2px rgba(0, 0, 0, 0.2); }\n  .droplet.type-text .label {\n    border-color: #2f9ed8; }\n  .droplet.type-text:hover .label {\n    color: #2f9ed8; }\n  .droplet.type-text.active .label {\n    color: #fff;\n    border-color: #1d719d;\n    background-color: #1d719d; }\n  .droplet.type-attribute .label {\n    border-color: #51cc4d; }\n  .droplet.type-attribute:hover .label {\n    color: #51cc4d; }\n  .droplet.type-attribute.active .label {\n    color: #fff;\n    border-color: #319f2e;\n    background-color: #319f2e; }\n  .droplet.type-element .label {\n    border-color: #c044f1; }\n  .droplet.type-element:hover .label {\n    color: #c044f1; }\n  .droplet.type-element.active .label {\n    color: #fff;\n    border-color: #a010d8;\n    background-color: #a010d8; }\n\n.dialog {\n  position: fixed;\n  display: none;\n  justify-content: center;\n  align-items: center;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  background: #ccc;\n  /* The Fallback */\n  background: rgba(204, 204, 204, 0.7); }\n  .dialog.visible {\n    display: flex; }\n  .dialog.no-overlay.visible {\n    pointer-events: none;\n    background: none; }\n  .dialog .dialog-container {\n    pointer-events: auto;\n    box-shadow: 4px 4px rgba(0, 0, 0, 0.1);\n    border: 1px solid #a0a0a0;\n    max-width: 500px;\n    background-color: #fbfbfb; }\n  .dialog .dialog-heading {\n    padding: 20px;\n    border-bottom: 1px solid #ccc; }\n    .dialog .dialog-heading .icon {\n      margin-right: .5em; }\n    .dialog .dialog-heading p:nth-of-type(n+2) {\n      font-size: 14px;\n      font-size: 0.875rem; }\n  .dialog .button {\n    font-size: 16px;\n    font-size: 1rem; }\n    .dialog .button > span {\n      padding: 7.5px 15px; }\n\n.popup[x-placement^=\"top\"] {\n  margin-bottom: 20px; }\n\n.popup[x-placement^=\"bottom\"] {\n  margin-top: 20px; }\n\n.popup[x-placement^=\"right\"] {\n  margin-left: 20px; }\n\n.popup[x-placement^=\"left\"] {\n  margin-right: 20px; }\n\n.popup[x-placement] .arrow {\n  position: absolute;\n  overflow: hidden;\n  width: 40px;\n  height: 40px; }\n  .popup[x-placement] .arrow:before, .popup[x-placement] .arrow:after {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 0;\n    border: 20px solid #fbfbfb; }\n  .popup[x-placement] .arrow:after {\n    border: 22px solid #a0a0a0; }\n\n.popup[x-placement^=\"top\"] .arrow,\n.popup[x-placement^=\"bottom\"] .arrow {\n  height: 20px; }\n\n.popup[x-placement^=\"left\"] .arrow,\n.popup[x-placement^=\"right\"] .arrow {\n  width: 20px; }\n\n.popup[x-placement^=\"top\"] .arrow {\n  bottom: -20px;\n  margin-left: -10px; }\n  .popup[x-placement^=\"top\"] .arrow:before {\n    border-color: #fbfbfb transparent transparent transparent; }\n  .popup[x-placement^=\"top\"] .arrow:after {\n    left: -2px;\n    top: -1px;\n    border-color: #a0a0a0 transparent transparent transparent; }\n\n.popup[x-placement^=\"bottom\"] .arrow {\n  top: -20px;\n  margin-left: -10px; }\n  .popup[x-placement^=\"bottom\"] .arrow:before {\n    top: -20px;\n    border-color: transparent transparent #fbfbfb transparent; }\n  .popup[x-placement^=\"bottom\"] .arrow:after {\n    left: -2px;\n    top: -21px;\n    border-color: transparent transparent #a0a0a0 transparent; }\n\n.popup[x-placement^=\"left\"] .arrow {\n  right: -20px; }\n  .popup[x-placement^=\"left\"] .arrow:before {\n    border-color: transparent transparent transparent #fbfbfb; }\n  .popup[x-placement^=\"left\"] .arrow:after {\n    left: -1px;\n    top: -2px;\n    border-color: transparent transparent transparent #a0a0a0; }\n\n.popup[x-placement^=\"right\"] .arrow {\n  left: -20px; }\n  .popup[x-placement^=\"right\"] .arrow:before {\n    left: auto;\n    right: 0;\n    border-color: transparent #fbfbfb transparent transparent; }\n  .popup[x-placement^=\"right\"] .arrow:after {\n    left: auto;\n    right: -1px;\n    top: -2px;\n    border-color: transparent #a0a0a0 transparent transparent; }\n\n.popup code {\n  display: block;\n  box-shadow: 2px 2px rgba(0, 0, 0, 0.2);\n  margin: 1em 0;\n  width: 100%;\n  padding: 5px;\n  word-wrap: break-word;\n  font-size: 12px;\n  font-size: 0.75rem;\n  background-color: #fcfdcc; }\n\nform fieldset:not(.buttons) {\n  padding: 0 20px;\n  margin: 10px 0; }\n\nform fieldset.buttons {\n  text-align: right;\n  border-top: 1px solid #ccc;\n  padding: 20px; }\n  form fieldset.buttons button {\n    display: inline-block;\n    margin: 0 .25em; }\n    form fieldset.buttons button.pull-left {\n      float: left; }\n\nform legend {\n  font-weight: bolder; }\n\nform .field {\n  display: flex;\n  align-items: center;\n  margin: 10px 0; }\n  form .field label {\n    width: 40%; }\n\ninput,\nselect,\nbutton {\n  font-family: \"Muli\", sans-serif; }\n\ninput,\nselect {\n  user-select: all;\n  font-size: 14px;\n  font-size: 0.875rem;\n  padding: 5px; }\n\nbutton {\n  position: relative; }\n  button.primary, button.danger {\n    font-weight: bolder; }\n  button.primary > span {\n    border-color: #6172ec;\n    color: #6172ec; }\n  button.primary .circle {\n    background-color: #1d35e4; }\n  button.primary:hover > span,\n  button.primary:focus > span {\n    color: #fff;\n    background-color: #7886ef; }\n  button.danger > span {\n    border-color: #ff515c;\n    color: #ff515c; }\n  button.danger .circle {\n    background-color: #ff0514; }\n  button.danger:hover > span,\n  button.danger:focus > span {\n    color: #fff;\n    background-color: #ff6b74; }\n\n.icon {\n  pointer-events: none; }\n  .icon use {\n    fill: currentColor; }\n\n.drag-handle {\n  position: relative;\n  background-color: #eee;\n  cursor: col-resize; }\n  .drag-handle:after {\n    content: '';\n    transition: all 0.15s cubic-bezier(0.77, 0, 0.175, 1);\n    position: absolute;\n    box-sizing: border-box;\n    left: 50%;\n    top: 50%;\n    margin-top: -25px;\n    margin-left: -4px;\n    width: 8px;\n    height: 50px;\n    border-left: 2px solid #ccc;\n    border-right: 2px solid #ccc; }\n  .drag-handle:hover, .drag-handle.item-dragging {\n    background-color: #f4f4f4; }\n  .drag-handle:hover:after, .drag-handle.item-dragging:after {\n    height: 100px;\n    margin-top: -50px; }\n\n.tooltip {\n  position: absolute;\n  max-width: 400px; }\n  .tooltip .content {\n    box-shadow: 4px 4px rgba(0, 0, 0, 0.1);\n    padding: 10px;\n    background-color: #fbfbfb; }\n    .tooltip .content h2 {\n      font-size: 18px;\n      font-size: 1.125rem; }\n      .tooltip .content h2 .icon {\n        margin-right: .5em;\n        vertical-align: middle;\n        fill: #192fce; }\n  .tooltip .arrow:after {\n    display: none; }\n", ""]);

// exports


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap) {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
  var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

  return '/*# ' + data + ' */';
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(159).Buffer))

/***/ }),
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 179 */,
/* 180 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */
/***/ (function(module, exports) {

(function(host) {

  var properties = {
    browser: [
      [/msie ([\.\_\d]+)/, "ie"],
      [/trident\/.*?rv:([\.\_\d]+)/, "ie"],
      [/firefox\/([\.\_\d]+)/, "firefox"],
      [/chrome\/([\.\_\d]+)/, "chrome"],
      [/version\/([\.\_\d]+).*?safari/, "safari"],
      [/mobile safari ([\.\_\d]+)/, "safari"],
      [/android.*?version\/([\.\_\d]+).*?safari/, "com.android.browser"],
      [/crios\/([\.\_\d]+).*?safari/, "chrome"],
      [/opera/, "opera"],
      [/opera\/([\.\_\d]+)/, "opera"],
      [/opera ([\.\_\d]+)/, "opera"],
      [/opera mini.*?version\/([\.\_\d]+)/, "opera.mini"],
      [/opios\/([a-z\.\_\d]+)/, "opera"],
      [/blackberry/, "blackberry"],
      [/blackberry.*?version\/([\.\_\d]+)/, "blackberry"],
      [/bb\d+.*?version\/([\.\_\d]+)/, "blackberry"],
      [/rim.*?version\/([\.\_\d]+)/, "blackberry"],
      [/iceweasel\/([\.\_\d]+)/, "iceweasel"],
      [/edge\/([\.\d]+)/, "edge"]
    ],
    os: [
      [/linux ()([a-z\.\_\d]+)/, "linux"],
      [/mac os x/, "macos"],
      [/mac os x.*?([\.\_\d]+)/, "macos"],
      [/os ([\.\_\d]+) like mac os/, "ios"],
      [/openbsd ()([a-z\.\_\d]+)/, "openbsd"],
      [/android/, "android"],
      [/android ([a-z\.\_\d]+);/, "android"],
      [/mozilla\/[a-z\.\_\d]+ \((?:mobile)|(?:tablet)/, "firefoxos"],
      [/windows\s*(?:nt)?\s*([\.\_\d]+)/, "windows"],
      [/windows phone.*?([\.\_\d]+)/, "windows.phone"],
      [/windows mobile/, "windows.mobile"],
      [/blackberry/, "blackberryos"],
      [/bb\d+/, "blackberryos"],
      [/rim.*?os\s*([\.\_\d]+)/, "blackberryos"]
    ],
    device: [
      [/ipad/, "ipad"],
      [/iphone/, "iphone"],
      [/lumia/, "lumia"],
      [/htc/, "htc"],
      [/nexus/, "nexus"],
      [/galaxy nexus/, "galaxy.nexus"],
      [/nokia/, "nokia"],
      [/ gt\-/, "galaxy"],
      [/ sm\-/, "galaxy"],
      [/xbox/, "xbox"],
      [/(?:bb\d+)|(?:blackberry)|(?: rim )/, "blackberry"]
    ]
  };

  var UNKNOWN = "Unknown";

  var propertyNames = Object.keys(properties);

  function Sniffr() {
    var self = this;

    propertyNames.forEach(function(propertyName) {
      self[propertyName] = {
        name: UNKNOWN,
        version: [],
        versionString: UNKNOWN
      };
    });
  }

  function determineProperty(self, propertyName, userAgent) {
    properties[propertyName].forEach(function(propertyMatcher) {
      var propertyRegex = propertyMatcher[0];
      var propertyValue = propertyMatcher[1];

      var match = userAgent.match(propertyRegex);

      if (match) {
        self[propertyName].name = propertyValue;

        if (match[2]) {
          self[propertyName].versionString = match[2];
          self[propertyName].version = [];
        } else if (match[1]) {
          self[propertyName].versionString = match[1].replace(/_/g, ".");
          self[propertyName].version = parseVersion(match[1]);
        } else {
          self[propertyName].versionString = UNKNOWN;
          self[propertyName].version = [];
        }
      }
    });
  }

  function parseVersion(versionString) {
    return versionString.split(/[\._]/).map(function(versionPart) {
      return parseInt(versionPart);
    });
  }

  Sniffr.prototype.sniff = function(userAgentString) {
    var self = this;
    var userAgent = (userAgentString || navigator.userAgent || "").toLowerCase();

    propertyNames.forEach(function(propertyName) {
      determineProperty(self, propertyName, userAgent);
    });
  };


  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Sniffr;
  } else {
    host.Sniffr = new Sniffr();
    host.Sniffr.sniff(navigator.userAgent);
  }
})(this);


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
	}),
	getHeadElement = memoize(function () {
		return document.head || document.getElementsByTagName("head")[0];
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [],
	fixUrls = __webpack_require__(293);

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the bottom of <head>.
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var head = getHeadElement();
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			head.insertBefore(styleElement, head.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			head.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		head.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	options.attrs.type = "text/css";

	attachTagAttrs(styleElement, options.attrs);
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	attachTagAttrs(linkElement, options.attrs);
	insertStyleElement(options, linkElement);
	return linkElement;
}

function attachTagAttrs(element, attrs) {
	Object.keys(attrs).forEach(function (key) {
		element.setAttribute(key, attrs[key]);
	});
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement, options);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls){
		css = fixUrls(css);
	}

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 293 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	var fixedCss = css.replace(/url *\( *(.+?) *\)/g, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(161);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(292)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../css-loader/index.js!../../../sass-loader/lib/loader.js!./main.scss", function() {
			var newContent = require("!!../../../css-loader/index.js!../../../sass-loader/lib/loader.js!./main.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */
/***/ (function(module, exports, __webpack_require__) {


var sprite = __webpack_require__(18);
var image = "<symbol viewBox=\"0 0 8 8\" id=\"icon-compass\" > <path d=\"M4 0c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4zm0 1c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm2 1l-3 1-1 3 3-1 1-3zm-2 1.5c.28 0 .5.22.5.5s-.22.5-.5.5-.5-.22-.5-.5.22-.5.5-.5z\"/> </symbol>";
module.exports = sprite.add(image, "icon-compass");

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {


var sprite = __webpack_require__(18);
var image = "<symbol viewBox=\"0 0 8 8\" id=\"icon-lightbulb\" > <path d=\"M3.41 0a.5.5 0 0 0-.13.06l-3 1.5a.5.5 0 1 0 .44.88l3-1.5a.5.5 0 0 0-.31-.94zm1 1.5a.5.5 0 0 0-.13.06l-4 2a.5.5 0 1 0 .44.88l4-2a.5.5 0 0 0-.31-.94zm0 2a.5.5 0 0 0-.13.06l-3 1.5a.5.5 0 0 0 .22.94h2a.5.5 0 0 0 .16-1l1.06-.56a.5.5 0 0 0-.31-.94zm-2.56 3.5a.5.5 0 0 0 .16 1h1a.5.5 0 1 0 0-1h-1a.5.5 0 0 0-.09 0 .5.5 0 0 0-.06 0z\" transform=\"translate(1)\"/> </symbol>";
module.exports = sprite.add(image, "icon-lightbulb");

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {


var sprite = __webpack_require__(18);
var image = "<symbol viewBox=\"0 0 8 8\" id=\"icon-loop-circular\" > <path d=\"M4 0c-1.65 0-3 1.35-3 3h-1l1.5 2 1.5-2h-1c0-1.11.89-2 2-2v-1zm2.5 1l-1.5 2h1c0 1.11-.89 2-2 2v1c1.65 0 3-1.35 3-3h1l-1.5-2z\" transform=\"translate(0 1)\"/> </symbol>";
module.exports = sprite.add(image, "icon-loop-circular");

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {


var sprite = __webpack_require__(18);
var image = "<symbol viewBox=\"0 0 8 8\" id=\"icon-media-play\" > <path d=\"M0 0v6l6-3-6-3z\" transform=\"translate(1 1)\"/> </symbol>";
module.exports = sprite.add(image, "icon-media-play");

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {


var sprite = __webpack_require__(18);
var image = "<symbol viewBox=\"0 0 8 8\" id=\"icon-puzzle-piece\" > <path d=\"M3 0c-.28 0-.54.1-.72.28-.18.18-.28.44-.28.72 0 .28.18.48.28.72.03.06.03.16.03.28h-2.31v6h2.31c0-.12-.01-.22-.03-.28-.1-.24-.28-.44-.28-.72 0-.28.1-.54.28-.72.18-.18.44-.28.72-.28.28 0 .54.1.72.28.18.18.28.44.28.72 0 .28-.18.48-.28.72-.03.06-.03.16-.03.28h2.31v-2.31c.12 0 .22.01.28.03.24.1.44.28.72.28.28 0 .54-.1.72-.28.18-.18.28-.44.28-.72 0-.28-.1-.54-.28-.72-.18-.18-.44-.28-.72-.28-.28 0-.48.18-.72.28-.06.03-.16.03-.28.03v-2.31h-2.31c0-.12.01-.22.03-.28.1-.24.28-.44.28-.72 0-.28-.1-.54-.28-.72-.18-.18-.44-.28-.72-.28z\"/> </symbol>";
module.exports = sprite.add(image, "icon-puzzle-piece");

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {


var sprite = __webpack_require__(18);
var image = "<symbol viewBox=\"0 0 8 8\" id=\"icon-resize-width\" > <path d=\"M3 0l-3 2.5 3 2.5v-2h2v2l3-2.5-3-2.5v2h-2v-2z\" transform=\"translate(0 1)\"/> </symbol>";
module.exports = sprite.add(image, "icon-resize-width");

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {


var sprite = __webpack_require__(18);
var image = "<symbol viewBox=\"0 0 8 8\" id=\"icon-tag\" > <path d=\"M0 0v3l5 5 3-3-5-5h-3zm2 1c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1z\"/> </symbol>";
module.exports = sprite.add(image, "icon-tag");

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {


var sprite = __webpack_require__(18);
var image = "<symbol viewBox=\"0 0 8 8\" id=\"icon-text\" > <path d=\"M0 0v2h.5c0-.55.45-1 1-1h1.5v5.5c0 .28-.22.5-.5.5h-.5v1h4v-1h-.5c-.28 0-.5-.22-.5-.5v-5.5h1.5c.55 0 1 .45 1 1h.5v-2h-8z\"/> </symbol>";
module.exports = sprite.add(image, "icon-text");

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

var Sniffr = __webpack_require__(291);

/**
 * List of SVG attributes to fix url target in them
 * @type {string[]}
 */
var fixAttributes = [
  'clipPath',
  'colorProfile',
  'src',
  'cursor',
  'fill',
  'filter',
  'marker',
  'markerStart',
  'markerMid',
  'markerEnd',
  'mask',
  'stroke'
];

/**
 * Query to find'em
 * @type {string}
 */
var fixAttributesQuery = '[' + fixAttributes.join('],[') + ']';
/**
 * @type {RegExp}
 */
var URI_FUNC_REGEX = /^url\((.*)\)$/;

/**
 * Convert array-like to array
 * @param {Object} arrayLike
 * @returns {Array.<*>}
 */
function arrayFrom(arrayLike) {
  return Array.prototype.slice.call(arrayLike, 0);
}

/**
 * Handles forbidden symbols which cannot be directly used inside attributes with url(...) content.
 * Adds leading slash for the brackets
 * @param {string} url
 * @return {string} encoded url
 */
function encodeUrlForEmbedding(url) {
  return url.replace(/\(|\)/g, "\\$&");
}

/**
 * Replaces prefix in `url()` functions
 * @param {Element} svg
 * @param {string} currentUrlPrefix
 * @param {string} newUrlPrefix
 */
function baseUrlWorkAround(svg, currentUrlPrefix, newUrlPrefix) {
  var nodes = svg.querySelectorAll(fixAttributesQuery);

  if (!nodes) {
    return;
  }

  arrayFrom(nodes).forEach(function (node) {
    if (!node.attributes) {
      return;
    }

    arrayFrom(node.attributes).forEach(function (attribute) {
      var attributeName = attribute.localName.toLowerCase();

      if (fixAttributes.indexOf(attributeName) !== -1) {
        var match = URI_FUNC_REGEX.exec(node.getAttribute(attributeName));

        // Do not touch urls with unexpected prefix
        if (match && match[1].indexOf(currentUrlPrefix) === 0) {
          var referenceUrl = encodeUrlForEmbedding(newUrlPrefix + match[1].split(currentUrlPrefix)[1]);
          node.setAttribute(attributeName, 'url(' + referenceUrl + ')');
        }
      }
    });
  });
}

/**
 * Because of Firefox bug #353575 gradients and patterns don't work if they are within a symbol.
 * To workaround this we move the gradient definition outside the symbol element
 * @see https://bugzilla.mozilla.org/show_bug.cgi?id=353575
 * @param {Element} svg
 */
var FirefoxSymbolBugWorkaround = function (svg) {
  var defs = svg.querySelector('defs');

  var moveToDefsElems = svg.querySelectorAll('symbol linearGradient, symbol radialGradient, symbol pattern');
  for (var i = 0, len = moveToDefsElems.length; i < len; i++) {
    defs.appendChild(moveToDefsElems[i]);
  }
};

/**
 * Fix for browser (IE, maybe other too) which are throwing 'WrongDocumentError'
 * if you insert an element which is not part of the document
 * @see http://stackoverflow.com/questions/7981100/how-do-i-dynamically-insert-an-svg-image-into-html#7986519
 * @param {Element} svg
 */
function importSvg(svg) {
  try {
    if (document.importNode) {
      return document.importNode(svg, true);
    }
  } catch(e) {}

  return svg;
}

/**
 * @type {string}
 */
var DEFAULT_URI_PREFIX = '#';

/**
 * @type {string}
 */
var xLinkHref = 'xlink:href';
/**
 * @type {string}
 */
var xLinkNS = 'http://www.w3.org/1999/xlink';
/**
 * @type {string}
 */
var svgOpening = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="' + xLinkNS + '"';
/**
 * @type {string}
 */
var svgClosing = '</svg>';
/**
 * @type {string}
 */
var contentPlaceHolder = '{content}';

/**
 * Representation of SVG sprite
 * @constructor
 */
function Sprite() {
  var baseElement = document.getElementsByTagName('base')[0];
  var currentUrl = window.location.href.split('#')[0];
  var baseUrl = baseElement && baseElement.href;
  this.urlPrefix = baseUrl && baseUrl !== currentUrl ? currentUrl + DEFAULT_URI_PREFIX : DEFAULT_URI_PREFIX;

  var sniffr = new Sniffr();
  sniffr.sniff();
  this.browser = sniffr.browser;
  this.content = [];

  if (this.browser.name !== 'ie' && baseUrl) {
    window.addEventListener('spriteLoaderLocationUpdated', function (e) {
      var currentPrefix = this.urlPrefix;
      var newUrlPrefix = e.detail.newUrl.split(DEFAULT_URI_PREFIX)[0] + DEFAULT_URI_PREFIX;
      baseUrlWorkAround(this.svg, currentPrefix, newUrlPrefix);
      this.urlPrefix = newUrlPrefix;

      if (this.browser.name === 'firefox' || this.browser.name === 'edge' || this.browser.name === 'chrome' && this.browser.version[0] >= 49) {
        var nodes = arrayFrom(document.querySelectorAll('use[*|href]'));
        nodes.forEach(function (node) {
          var href = node.getAttribute(xLinkHref);
          if (href && href.indexOf(currentPrefix) === 0) {
            node.setAttributeNS(xLinkNS, xLinkHref, newUrlPrefix + href.split(DEFAULT_URI_PREFIX)[1]);
          }
        });
      }
    }.bind(this));
  }
}

Sprite.styles = ['position:absolute', 'width:0', 'height:0'];

Sprite.spriteTemplate = function(){ return svgOpening + ' style="'+ Sprite.styles.join(';') +'"><defs>' + contentPlaceHolder + '</defs>' + svgClosing; }
Sprite.symbolTemplate = function() { return svgOpening + '>' + contentPlaceHolder + svgClosing; }

/**
 * @type {Array<String>}
 */
Sprite.prototype.content = null;

/**
 * @param {String} content
 * @param {String} id
 */
Sprite.prototype.add = function (content, id) {
  if (this.svg) {
    this.appendSymbol(content);
  }

  this.content.push(content);

  return DEFAULT_URI_PREFIX + id;
};

/**
 *
 * @param content
 * @param template
 * @returns {Element}
 */
Sprite.prototype.wrapSVG = function (content, template) {
  var svgString = template.replace(contentPlaceHolder, content);

  var svg = new DOMParser().parseFromString(svgString, 'image/svg+xml').documentElement;
  var importedSvg = importSvg(svg);

  if (this.browser.name !== 'ie' && this.urlPrefix) {
    baseUrlWorkAround(importedSvg, DEFAULT_URI_PREFIX, this.urlPrefix);
  }

  return importedSvg;
};

Sprite.prototype.appendSymbol = function (content) {
  var symbol = this.wrapSVG(content, Sprite.symbolTemplate()).childNodes[0];

  this.svg.querySelector('defs').appendChild(symbol);
  if (this.browser.name === 'firefox') {
    FirefoxSymbolBugWorkaround(this.svg);
  }
};

/**
 * @returns {String}
 */
Sprite.prototype.toString = function () {
  var wrapper = document.createElement('div');
  wrapper.appendChild(this.render());
  return wrapper.innerHTML;
};

/**
 * @param {HTMLElement} [target]
 * @param {Boolean} [prepend=true]
 * @returns {HTMLElement} Rendered sprite node
 */
Sprite.prototype.render = function (target, prepend) {
  target = target || null;
  prepend = typeof prepend === 'boolean' ? prepend : true;

  var svg = this.wrapSVG(this.content.join(''), Sprite.spriteTemplate());

  if (this.browser.name === 'firefox') {
    FirefoxSymbolBugWorkaround(svg);
  }

  if (target) {
    if (prepend && target.childNodes[0]) {
      target.insertBefore(svg, target.childNodes[0]);
    } else {
      target.appendChild(svg);
    }
  }

  this.svg = svg;

  return svg;
};

module.exports = Sprite;


/***/ }),
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var App = __webpack_require__(122).default;

var app = new App({
	onElementRender: function onElementRender(markup, droplet, zone, is_output) {
		if (droplet.name === 'Letter button' && is_output) {
			markup.innerHTML = '<span>' + markup.innerHTML + '</span>';
		}

		return markup;
	}
});

app.load('templates/default.html', 'templates/pallet.json').catch(function (error) {
	console.error(error);
});

/***/ })
],[313]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2Fzc2V0cy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL0ljb24uanN4Iiwid2VicGFjazovLy8uL34vc3ZnLXNwcml0ZS1sb2FkZXIvbGliL3dlYi9nbG9iYWwtc3ByaXRlLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvbGliL0Ryb3Bab25lLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvbGliL0Ryb3BsZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9hc3NldHMvY29tbW9uLXByb3AtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9saWIvRm9ybUZpZWxkLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvbGliL1RlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvc3RhdGUvYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2xpYi9Db21tdW5pY2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9hc3NldHMvZGVmYXVsdC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2Fzc2V0cy9kaWFsb2dzLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy9kaWFsb2dzL0RpYWxvZ0hlYWRpbmcuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9Gb3JtLmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2xpYi9TdG9yYWdlLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvbGliL2FqYXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9JbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2Fzc2V0cy9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvY29tcG9uZW50LXV0aWxzLmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvY29udGFpbmVycy9DYW52YXMuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy9jb250YWluZXJzL0NhbnZhc0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvY29udGFpbmVycy9EaWFsb2dDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lcnMvSGVhZGVyQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy9jb250YWluZXJzL1BhbGxldENvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvY29udGFpbmVycy9UZW1wbGF0ZUNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvY29udGFpbmVycy9Ub29sdGlwQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy9kaWFsb2dzL0RpYWxvZy5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2RpYWxvZ3MvRGlhbG9nRWRpdERyb3BsZXQuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy9kaWFsb2dzL0RpYWxvZ0dlbmVyYWwuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9CdXR0b24uanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9Ecm9wWm9uZS5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL0Ryb3Bab25lQXR0YWNobWVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL0Ryb3Bab25lQXR0YWNobWVudExpc3QuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9Ecm9wWm9uZVRhcmdldC5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL0Ryb3BsZXQuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9GaWVsZHNldC5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL0hlYWRlci5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL1BhbGxldC5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL1RlbXBsYXRlLmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvVG9vbGJhci5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL1Rvb2x0aXAuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9WaWV3LmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvZmllbGRzL0Ryb3BEb3duLmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvZmllbGRzL1RleHRGaWVsZC5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9saWIvRHJhZ0Ryb3AuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9saWIvUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvbGliL1RvdXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9saWIvVUkuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvbGliL3BvbHlmaWxscy5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL3N0YXRlL3JlZHVjZXJzLmpzIiwid2VicGFjazovLy8uL34vYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvc3R5bGVzL21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmlmZnIvc3JjL3NuaWZmci5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL3N0eWxlcy9tYWluLnNjc3M/Y2I1NyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvY29tcGFzcy5zdmciLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9pbWcvc3ZnL2xpZ2h0YnVsYi5zdmciLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9pbWcvc3ZnL2xvb3AtY2lyY3VsYXIuc3ZnIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvaW1nL3N2Zy9tZWRpYS1wbGF5LnN2ZyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvcHV6emxlLXBpZWNlLnN2ZyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvcmVzaXplLXdpZHRoLnN2ZyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvdGFnLnN2ZyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvdGV4dC5zdmciLCJ3ZWJwYWNrOi8vLy4vfi9zdmctc3ByaXRlLWxvYWRlci9saWIvd2ViL3Nwcml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdGFnLmpzIl0sIm5hbWVzIjpbImFjdGlvblR5cGVzIiwiVUlfU1RBVEUiLCJaT05FX0FERF9BVFRBQ0hNRU5UIiwiWk9ORV9FRElUX0FUVEFDSE1FTlQiLCJaT05FX0RFVEFDSF9BVFRBQ0hNRU5UIiwiWk9ORV9DTEVBUl9BTExfQVRUQUNITUVOVFMiLCJTRVRfRElBTE9HX01PREUiLCJTRVRfQUNUSVZFX0RST1BMRVQiLCJTRVRfVE9VUl9TVEFHRSIsIlNIT1dfVE9PTFRJUCIsIkhJREVfVE9PTFRJUCIsIlNFVF9UT09MVElQX0NPTlRFTlQiLCJDT01QTEVURV9GSVJTVF9EUk9QIiwiQ09NUExFVEVfTEFTVF9EUk9QIiwiUkVTRVRfQVBQIiwiZGlhbG9nTW9kZXMiLCJOT05FIiwiR0VORVJBTCIsIkVESVRfRFJPUExFVCIsIlRPVVIiLCJ1aVN0YXRlcyIsIklOSVRJQUxJU0lORyIsIkFDVElWRSIsIm1lc3NhZ2VDb21tYW5kcyIsIlJFTE9BRCIsIlJFU0VUIiwiRElBTE9HIiwiRElBTE9HX0NBTExCQUNLIiwiZXJyb3JDb2RlcyIsIk5PVF9BX0RST1BMRVQiLCJzZXRMYWJlbHMiLCJ2YWx1ZSIsImF0dHJzIiwidGFnTmFtZSIsImlubmVySFRNTCIsInJlZ2lzdGVyR2VuZXJhbEV2ZW50IiwiY29tcG9uZW50IiwiaWQiLCJpbmZvIiwiYXJncyIsImFyZ3VtZW50cyIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJwcm9wcyIsIm9uRXZlbnQiLCJhcHBseSIsImNvbmNhdCIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiYmluZCIsImNvbGxlY3RSZWYiLCJjb2xsZWN0aW9uIiwia2V5IiwicmVmIiwicmVmQ29sbGVjdG9yIiwiRXJyb3IiLCJ2YWxpZGF0ZVByb3BLZXlzIiwicmVxdWlyZSIsImEiLCJsZW5ndGgiLCJoYXNPd25Qcm9wZXJ0eSIsInVuZGVmaW5lZCIsImVzY2FwZVJlZ0V4cCIsInN0ciIsInJlcGxhY2UiLCJyYXdNYXJrdXAiLCJodG1sIiwiX19odG1sIiwiY2hlY2tTdG9yYWdlIiwidHlwZSIsInN0b3JhZ2UiLCJ3aW5kb3ciLCJ4Iiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJlIiwic3RydWN0Q29tcGFyZSIsInRlc3QiLCJleHBlY3RlZCIsInJlc3VsdCIsImlzQXJyYXkiLCJJY29uIiwiR0xZUEhTIiwiVEVYVCIsIlBVWlpMRV9QSUVDRSIsIlRBRyIsIkNPTVBBU1MiLCJMT09QX0NJUkNVTEFSIiwiTUVESUFfUExBWSIsIkxJR0hUQlVMQiIsIlJFU0laRV9XSURUSCIsImNsYXNzTmFtZSIsImdseXBoIiwid2lkdGgiLCJoZWlnaHQiLCJkZWZhdWx0UHJvcHMiLCJwcm9wVHlwZXMiLCJudW1iZXIiLCJzdHJpbmciLCJEcm9wWm9uZSIsImRyb3Bfem9uZV9pZCIsImRhdGEiLCJ0YWciLCJhdHRhY2htZW50SWQiLCJtYXhBdHRhY2htZW50cyIsIndpbGxBY2NlcHQiLCJkcm9wbGV0Iiwic3RvcmUiLCJjdXJyZW50X2F0dGFjaG1lbnRzIiwic3RhdGUiLCJnZXRTdGF0ZSIsInpvbmVzIiwiYXR0YWNobWVudHMiLCJhdHRhY2htZW50SWRzIiwiaW5kZXhPZiIsImZldGNoWm9uZSIsIm1hcmt1cCIsIm1hdGNoIiwiem9uZSIsIl9yZV96b25lcyIsImV4ZWMiLCJjaGVja1N5bnRheCIsImQiLCJzeW50YXhfcmUiLCJyZV9zdHJ1Y3R1cmUiLCJyZV9pZCIsInNueXRheEZhdWx0IiwicmVfcXR5IiwicGFyc2VGbG9hdCIsIm1lc3NhZ2UiLCJjaGFyIiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsIkRyb3BsZXQiLCJkcm9wbGV0X2lkIiwic2V0dGluZ3MiLCJfb3JpZ2luYWxTZXR0aW5ncyIsIk9iamVjdCIsImRlZXBBc3NpZ24iLCJuYW1lIiwiZHJvcGxldFR5cGUiLCJpbml0IiwiX3ZhbGlkYXRlQW5kU2V0IiwiX3NldEV4dHJhRmllbGRzIiwidmFsdWVzIiwiY29udGV4dCIsImZvckVhY2giLCJQcm9wVHlwZXMiLCJfdmFsaWRhdGVFZGl0YWJsZVNldCIsInByb3AiLCJkcm9wbGV0X25hbWUiLCJkcm9wbGV0X3R5cGUiLCJhdHRyaWJ1dGUiLCJhdHRya2V5IiwicHJvcF9lcnJvciIsIl9hc3NlcnQiLCJlZGl0YWJsZUF0dHJpYnV0ZXMiLCJfdmFsaWRhdGVFZGl0YWJsZUl0ZW0iLCJpdGVtIiwiZXJyb3JfcHJlZml4IiwiZWRpdGFibGVGaWVsZFR5cGVzIiwidmFsaWRhdGVEYXRhQXR0cmlidXRlIiwiaXNSZXF1aXJlZCIsIm5vdEVtcHR5IiwiYXJyYXlPZiIsIm9iamVjdCIsImVkaXRhYmxlIiwiZ3VpZGFuY2UiLCJmaWVsZCIsImZ1bmMiLCJpbnN0YW5jZU9mIiwib25lT2ZUeXBlIiwib25DaGFuZ2UiLCJkaWFsb2ciLCJvbkRpYWxvZ0NhbmNlbCIsIm9uRGlhbG9nQ29tcGxldGUiLCJvbkJ1dHRvbkNsaWNrIiwibGliIiwiRm9ybUZpZWxkIiwiX3NldE5hbWVBbmRUeXBlIiwidmFsaWRUeXBlcyIsIl9kYXRhIiwicmVxdWlyZWQiLCJvcHRpb25zIiwicGxhY2Vob2xkZXIiLCJsYWJlbCIsIl92YWxpZGF0ZU9wdGlvbnNTZXR0aW5nIiwiX3ZhbGlkYXRlVmFsdWVTZXR0aW5nIiwibWF4bGVuZ3RoIiwiVGVtcGxhdGUiLCJwYXJlbnQiLCJfcGFyZW50IiwiX2Ryb3Bfem9uZXMiLCJfdGVtcGxhdGUiLCJfbWF4X3pvbmVzIiwibG9hZCIsInVybCIsImdldCIsInRoZW4iLCJyZXNwb25zZSIsInRleHQiLCJfbWFya3VwIiwiY2F0Y2giLCJjcmVhdGUiLCJlbnRpdGllcyIsIl9jcmVhdGVEcm9wWm9uZXMiLCJjb3VudGVyIiwiX2NyZWF0ZVRlbXBsYXRlQXJyYXkiLCJkcm9wX3pvbmVzIiwidGVtcGxhdGUiLCJzYW5kYm94IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwibm9kZSIsImNoaWxkTm9kZXMiLCJub2RlVHlwZSIsIk5vZGUiLCJURVhUX05PREUiLCJwdXNoIiwiY29udGVudCIsInRleHRDb250ZW50IiwiRUxFTUVOVF9OT0RFIiwiZGF0YXNldCIsInJlbmRlckFzSFRNTCIsImF0dGFjaG1lbnQiLCJfVUkiLCJnZXREcm9wbGV0QnlJZCIsInJlbmRlckRyb3BsZXQiLCJnZXREcm9wWm9uZUJ5SWQiLCJvbkVsZW1lbnRSZW5kZXIiLCJkcm9wX3pvbmUiLCJpc19vdXRwdXQiLCJvdXRwdXQiLCJyZW5kZXJFbGVtZW50RHJvcGxldCIsInJlbmRlclRleHREcm9wbGV0IiwicmVuZGVyQXR0cmlidXRlRHJvcGxldCIsImF0dHIiLCJvcGVuIiwiam9pbiIsInZvaWRUYWdzIiwiY2xvc2UiLCJpIiwiY2hhckNvZGVBdCIsInNldFVJU3RhdGUiLCJ1aV9zdGF0ZSIsInJlc2V0QXBwIiwiY29tcGxldGVGaXJzdERyb3AiLCJjb21wbGV0ZUxhc3REcm9wIiwic2V0QWN0aXZlRHJvcGxldCIsInNldERpYWxvZ01vZGUiLCJtb2RlIiwiem9uZUFkZEF0dGFjaG1lbnQiLCJhdHRhY2hlZCIsInpvbmVFZGl0QXR0YWNobWVudCIsImF0dGFjaG1lbnRfaW5kZXgiLCJ6b25lRGV0YWNoQXR0YWNobWVudCIsInpvbmVDbGVhckFsbEF0dGFjaG1lbnRzIiwic2V0VG91clN0YWdlIiwic3RhZ2UiLCJzaG93VG9vbHRpcCIsImhpZGVUb29sdGlwIiwic2V0VG9vbHRpcENvbnRlbnQiLCJ0aXRsZSIsImljb25HbHlwaCIsIkNvbW11bmljYXRvciIsIm9yaWdpbiIsImNhbGxiYWNrcyIsIl9zZXR0aW5ncyIsIl9ndWVzdHMiLCJfcXVldWUiLCJtZXNzYWdlX2luZGV4IiwiX29yaWdpbiIsIl9jYWxsYmFja3MiLCJhc3NpZ24iLCJhZGRFdmVudExpc3RlbmVyIiwiX3JlY2VpdmVNZXNzYWdlIiwiX3NlbmRQaW5nIiwicGluZyIsIl9jcmVhdGVNZXNzYWdlIiwib3BlbmVyIiwidG9wIiwiX3Bvc3QiLCJfc2VuZFBvbmciLCJwb25nIiwicmVnaXN0ZXJHdWVzdEFkZHJlc3MiLCJkZXN0IiwiX3NldEd1ZXN0RGF0YSIsInRpbWVyIiwiY2xlYXJJbnRlcnZhbCIsImxpdmUiLCJzZW5kIiwidG8iLCJndWVzdCIsIl9nZXRHdWVzdEJ5SWQiLCJfZ2VuZXJhdGVTZW5kSWQiLCJfYWRkVG9RdWV1ZSIsIl9zZW5kUXVldWUiLCJfZ2V0R3Vlc3RCeU5vZGUiLCJwb3N0TWVzc2FnZSIsIm9yaWdpbmFsRXZlbnQiLCJzb3VyY2UiLCJsb2NhdGlvbiIsIl9zZXRHdWVzdExpdmUiLCJvcmlnaW5hbE1lc3NhZ2UiLCJob3N0IiwicHJlZml4IiwicGVyZm9ybWFuY2UiLCJjIiwiciIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsImFwcCIsImFjdGl2ZSIsImZpcnN0X3ZhbGlkX2Ryb3AiLCJsYXN0X3ZhbGlkX2Ryb3AiLCJVSSIsIm92ZXJsYXkiLCJhY3RpdmVfZHJvcGxldF9pZCIsInRvdXJfc3RhZ2UiLCJ0b29sdGlwIiwic2hvdyIsImNyZWF0ZURpYWxvZ3MiLCJ0b3VyRGlhbG9nTW9kaWZpZXJzIiwiYXJyb3ciLCJlbGVtZW50IiwidG91ckJ1dHRvbnMiLCJwcm9jZWVkIiwidHJ5X2l0IiwiZW5kIiwiaW50cm8iLCJyZXNldFN0YXRlIiwiYnV0dG9ucyIsImRyb3BsZXRCYWRQbGFjZW1lbnQiLCJmaXJzdERyb3BsZXREcm9wIiwiZHJvcGxldF9vdXRwdXQiLCJsYXN0RHJvcGxldERyb3AiLCJ0b3VyIiwiZHJvcFpvbmUiLCJzZWxlY3RvciIsInBsYWNlbWVudCIsIm1vZGlmaWVycyIsImZpbmlzaCIsIkRpYWxvZ0hlYWRpbmciLCJub3RlcyIsImljb24iLCJub3RlIiwiaW5kZXgiLCJGb3JtIiwiZm9ybVZhbHVlcyIsInVpIiwicmVmcyIsImZpZWxkcyIsImZpZWxkU2V0cyIsInNldCIsImVsZW1lbnRDaGFuZ2UiLCJub2RlcyIsImNvbGxlY3RGaWVsZFJlZiIsImxlZ2VuZCIsInZhbHVlc19zdGF0ZSIsInNldHMiLCJzZXRTdGF0ZSIsInByb3h5X2V2ZW50Iiwib25TdWJtaXQiLCJidXR0b24iLCJidXR0b25fZGF0YSIsImIiLCJmb2N1cyIsImNsaWNrX2Z1bmN0aW9uIiwiYmx1ciIsIm9uQ2FuY2VsIiwib25DbGljayIsImNvbGxlY3RCdXR0b25SZWYiLCJjb21wb25lbnRPblN1Ym1pdCIsImdldEJ1dHRvbnMiLCJzaGFwZSIsImFycmF5IiwiSlNPTiIsImxvY2FsU3RvcmFnZSIsInNlc3Npb25TdG9yYWdlIiwiU3RvcmFnZSIsInN0b3JhZ2VFbmFibGVkIiwiZGVmYXVsdF92YWx1ZSIsImdldEl0ZW0iLCJwYXJzZSIsInN0cmluZ2lmeSIsIkFwcCIsImRlZmF1bHRzIiwiX2luaXQiLCJkaWFsb2dzIiwiaGlkZURpYWxvZyIsIl9yZWZzIiwicXVlcnlTZWxlY3RvciIsIm1vdW50ZWQiLCJjb21wb25lbnRzIiwicGFsbGV0IiwiX2xvYWRQYWxsZXQiLCJzdG9yZWRfc3RhdGUiLCJfdmFsaWRhdGVfc3RhdGUiLCJfc3RvcmUiLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIiwiYWN0aW9uc0JsYWNrbGlzdCIsInJlbmRlciIsImRpc3BhdGNoIiwiUHJvbWlzZSIsInJlamVjdCIsIl9yZXF1aXJlVUkiLCJfc2hvd0RpYWxvZyIsIl9oaWRlRGlhbG9nIiwic3RhcnRUb3VyIiwiX3RvdXIiLCJzdGFydCIsInJlc2V0IiwiX2NvbW1zIiwiY21kIiwidXBkYXRlVmlldyIsIl91cGRhdGVWaWV3IiwiY2xhc3NlcyIsImNhbnZhcyIsImNhbnZhc19hY3RpdmUiLCJkcm9wbGV0X2FjdGl2ZSIsImlzX2RyYWdnaW5nIiwiaXRlbV9kcmFnZ2luZyIsImRyb3B6b25lX3RhcmdldCIsImRyb3B6b25lX2lzX2FjdGl2ZSIsImRyb3B6b25lX2lzX3RhcmdldCIsInRleHRfZWxlbWVudCIsImhpZGRlbiIsImJ1dHRvbl9hbmltYXRlIiwicG9wdXAiLCJpbm5lciIsImRyb3B6b25lIiwicG9zc2libGVfdGFyZ2V0Iiwid2lsbF9hY2NlcHQiLCJ3aWxsX2RlY2xpbmUiLCJtYWluIiwidmlzaWJsZSIsImNvbnRhaW5lciIsImhlYWRpbmciLCJub19vdmVybGF5IiwidG9vbGJhciIsInNlcGFyYXRvciIsInNlbGVjdG9ycyIsImJ1dHRvbl9jaXJjbGUiLCJpbml0aWFsX2ZsZXhfYmFzaXMiLCJ2aWV3Iiwic3JjIiwiYXV0b1VwZGF0ZSIsIndhcm5PbkJhZFBsYWNlbWVudCIsIm5vdGljZU9uRmlyc3RQbGFjZW1lbnQiLCJub3RpY2VPbkxhc3RQbGFjZW1lbnQiLCJtZXRob2QiLCJzaG93SW50cm8iLCJQUk9EVUNUSU9OIiwib3B0aW9uVmFsdWVTZXQiLCJDYW52YXMiLCJvbk1vdW50Iiwib25BdHRhY2htZW50Q2xpY2siLCJvbkRyb3Bab25lRXZlbnQiLCJvbkRyYWdIYW5kbGVFdmVudCIsIm9uRHJvcGxldEV2ZW50Iiwic2V0VUlQb3BwZXJBdHRhY2htZW50IiwiYW55Iiwic3RhdGVfdG9vbHRpcCIsIm1hcFN0YXRlVG9Qcm9wcyIsIkNhbnZhc0NvbnRhaW5lciIsIkRpYWxvZ0NvbnRhaW5lciIsImRpYWxvZ19tb2RlIiwiSGVhZGVyQ29udGFpbmVyIiwiYWN0aXZlRHJvcGxldElkIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwiUGFsbGV0Q29udGFpbmVyIiwiYWN0aXZlRHJvcGxldElEIiwiVGVtcGxhdGVDb250YWluZXIiLCJUb29sdGlwQ29udGFpbmVyIiwiRGlhbG9nQ29tcG9uZW50cyIsIkRpYWxvZyIsImRpYWxvZ1JlZiIsInBvcHBlciIsImRlc3Ryb3kiLCJDb21wb25lbnQiLCJoZWFkaW5nc0J5VHlwZSIsIkRpYWxvZ0VkaXREcm9wbGV0IiwiZGV0YWNoQXR0YWNobWVudCIsImFjdGlvbiIsImFjdGlvbl9kYXRhIiwiZHJvcGxldF92YWx1ZXMiLCJ6b25lX2lkIiwiZmllbGRzZXRzIiwiZmllbGRzZXQiLCJ6b25lR2V0QXR0YWNobWVudCIsImdldEZpZWxkc2V0cyIsIkRpYWxvZ0dlbmVyYWwiLCJCdXR0b24iLCJEcm9wWm9uZUNvbXBvbmVudCIsIm15cmVmcyIsImNsYXNzTmFtZXMiLCJhY3RpdmVBdHRhY2htZW50cyIsIkRyb3Bab25lQXR0YWNobWVudCIsImF0dGFjaG1lbnRJbmRleCIsIkRyb3Bab25lQXR0YWNobWVudExpc3QiLCJhdHRhY2htZW50Q2xpY2siLCJjaGlsZHJlbiIsInJlbmRlckFjdGl2ZUF0dGFjaG1lbnRzIiwiRHJvcFpvbmVUYXJnZXQiLCJkcm9wbGV0VHlwZVRvR2x5cGhzIiwiRHJvcGxldENvbXBvbmVudCIsInRvb2x0aXBfY2FjaGUiLCJjb2xsZWN0b3IiLCJsb2ciLCJib29sIiwiRmllbGRDb21wb25lbnRzIiwiRmllbGRzZXQiLCJ0YXJnZXQiLCJvbkZpZWxkVXBkYXRlIiwiSGVhZGVyIiwiUGFsbGV0IiwiaXRlbXMiLCJnZXRJdGVtcyIsImRyb3B6b25lX2lkIiwiaXNWYWxpZERyb3AiLCJnZXREcm9wWm9uZUNsYXNzTmFtZXMiLCJnZXRab25lQXR0YWNobWVudHMiLCJnZXRJbnN0cnVjdGlvbiIsImdldFRlbXBsYXRlIiwiVG9vbGJhciIsImJ1dHRvblJlZnMiLCJ0b29scyIsInJlZ2lzdGVyQnV0dG9uUmVmIiwicmVnaXN0ZXJCdXR0b25DbGljayIsImdldFRvb2xiYXJCdXR0b25zIiwiVG9vbHRpcCIsInVwZGF0ZUF0dGFjaG1lbnQiLCJmbGlwIiwiYXR0YWNoZXIiLCJWaWV3IiwiRHJvcERvd24iLCJUZXh0RmllbGQiLCJpbnRlcmFjdCIsIkRyYWdEcm9wIiwiX2NhbnZhcyIsImRyYWciLCJkcm9wIiwiYWRkRHJhZ2FibGUiLCJkcmFnYWJsZSIsIkRyYWdhYmxlIiwic2V0RHJhZ2FibGUiLCJvbiIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZSIsImRyYWdFbmQiLCJfY3JlYXRlSW5zdGFuY2UiLCJhZGREcm9wYWJsZSIsImRyb3BhYmxlIiwiRHJvcGFibGUiLCJzZXREcm9wYWJsZSIsInJlbGF0ZWRUYXJnZXQiLCJyZXNldERyYWdQb3NpdGlvbiIsImdldERyYWdJbnN0YW5jZSIsImluc3RhbmNlIiwicmVzZXRQb3NpdGlvbiIsImZpbmQiLCJfZWxlbWVudCIsIl94IiwiX3kiLCJkcmFnZ2FibGUiLCJvbkRyYWdNb3ZlIiwiZHgiLCJkeSIsInN0eWxlIiwid2Via2l0VHJhbnNmb3JtIiwidHJhbnNmb3JtIiwiY2hhaW4iLCJwcm9wbmFtZSIsImZuIiwiYXNzZXJ0IiwicHJvcF9pZCIsInN0cmluZ05vdEVtcHR5IiwiX2NoYWluIiwiVG91ciIsIl9wcm9ncmVzc1RvdXIiLCJfc2V0VG91clN0YWdlIiwiX3Nob3dUb3VyRWxlbWVudCIsImRyYWdkcm9wIiwiZHJvcGxldHMiLCJ2cF93aWR0aCIsImRyYWdIYW5kbGVQb3NpdGlvbiIsImRyYWdIYW5kbGVNb3ZlZCIsIl9oYW5kbGVBcHBNZXNzYWdlIiwibGlicmFyeU1ldGhvZHMiLCJfc2V0VUlQb3BwZXJBdHRhY2htZW50IiwiX2lzVmFsaWREcm9wIiwicXVldWVzIiwiZHJhZ2Ryb3BCaW5kaW5ncyIsIl9oYW5kbGVXaW5kb3dSZXNpemUiLCJfcmVmQ29sbGVjdG9yIiwiX21vdW50RXZlbnQiLCJfaGFuZGxlQXR0YWNobWVudENsaWNrIiwiX2hhbmRsZURyb3BsZXRFdmVudCIsIl9oYW5kbGVEcm9wWm9uZUV2ZW50IiwiX2hhbmRsZURyYWdIYW5kbGVFdmVudCIsIl9oYW5kbGVCdXR0b25DbGljayIsIl9zaG93Q29tbXVuaWNhdG9yRGlhbG9nIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJpbm5lcl9zdGF0ZSIsImNvbW1zX2lkIiwiX2dldFJlZmVyZW5jZWRFbGVtZW50IiwiX3F1ZXVlRHJhZ0Ryb3BCaW5kaW5nIiwiX3NldERyYWdEcm9wQmluZGluZ3MiLCJjb250ZW50V2luZG93Iiwidmlld19mcmFtZSIsInF1ZXVlIiwiX2hhbmRsZURyb3BsZXREcm9wIiwiYWNjZXB0IiwiYXR0YWNoRHJvcGxldFRvRHJvcFpvbmUiLCJfY29tbWl0RHJvcGxldEludG9Ecm9wWm9uZSIsIl9zZXRUZW1wbGF0ZVZpZXdSYXRpbyIsImRyYWdfaGFuZGxlX3giLCJvZmZzZXRXaWR0aCIsIm9mZnNldExlZnQiLCJtYXgiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImlubmVyV2lkdGgiLCJvZmZzZXQiLCJyZWN0IiwiY2lyY2xlIiwicGFnZVgiLCJwYWdlWSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnRTY3JvbGxlZCIsImxlZnQiLCJwYWdlWE9mZnNldCIsInRvcFNjcm9sbGVkIiwicGFnZVlPZmZzZXQiLCJvZmZzZXRIZWlnaHQiLCJyYXRpbyIsImZsZXhCYXNpcyIsImFicyIsIl9wb3N0RHJvcGxldEF0dGFjaG1lbnQiLCJrZXlzIiwibm90aWNlIiwiSFRNTEVsZW1lbnQiLCJ2YXJBcmdzIiwiZnJvbSIsIlR5cGVFcnJvciIsIkZ1bmN0aW9uIiwiY3VycnkiLCJkaWFsb2dfaWQiLCJuZXdzdGF0ZSIsInN0b3JlU3RhdGUiLCJzcGxpY2UiLCJjdXJyZW50X3N0YXRlIiwibmV3X3N0YXRlIiwiZGVmYXVsdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFJQTs7OztBQUlPLElBQU1BLG9DQUFjO0FBQzFCQyxXQUFVLFVBRGdCO0FBRTFCQyxzQkFBcUIscUJBRks7QUFHMUJDLHVCQUFzQixzQkFISTtBQUkxQkMseUJBQXdCLHdCQUpFO0FBSzFCQyw2QkFBNEIsNEJBTEY7QUFNMUJDLGtCQUFpQixpQkFOUztBQU8xQkMscUJBQW9CLG9CQVBNO0FBUTFCQyxpQkFBZ0IsZ0JBUlU7QUFTMUJDLGVBQWMsY0FUWTtBQVUxQkMsZUFBYyxjQVZZO0FBVzFCQyxzQkFBcUIscUJBWEs7QUFZMUJDLHNCQUFxQixxQkFaSztBQWExQkMscUJBQW9CLG9CQWJNO0FBYzFCQyxZQUFXO0FBZGUsQ0FBcEI7O0FBaUJQOzs7QUFHTyxJQUFNQyxvQ0FBYztBQUMxQkMsT0FBTSxNQURvQjtBQUUxQkMsVUFBUyxTQUZpQjtBQUcx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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzV2REE7QUFDQTtBQUNBLCtGQUFnRzs7QUFFaEc7QUFDQSx5Q0FBMEMsMkJBQTJCLEVBQUUsbWJBQW1iLGNBQWMsZUFBZSxjQUFjLGVBQWUsb0JBQW9CLDZCQUE2Qiw0QkFBNEIsa0JBQWtCLGlCQUFpQixFQUFFLFVBQVUsbUJBQW1CLEVBQUUsOEZBQThGLG1CQUFtQixFQUFFLFlBQVkscUJBQXFCLEVBQUUsbUJBQW1CLGlCQUFpQixFQUFFLDZEQUE2RCxnQkFBZ0Isa0JBQWtCLEVBQUUsT0FBTyxjQUFjLGVBQWUsb0JBQW9CLDZCQUE2Qiw0QkFBNEIsRUFBRSxrREFBa0QsMkJBQTJCLGdCQUFnQiwwQkFBMEIsRUFBRSxtREFBbUQsMkJBQTJCLGdCQUFnQix1QkFBdUIsc0JBQXNCLEVBQUUsU0FBUyxrQ0FBa0MsRUFBRSw2QkFBNkIsOEJBQThCLGlCQUFpQixFQUFFLFdBQVcsOEJBQThCLHNCQUFzQixFQUFFLHVEQUF1RCxtQkFBbUIsZ0JBQWdCLGNBQWMsa0NBQWtDLGtCQUFrQixlQUFlLEVBQUUsbUJBQW1CLDJCQUEyQixFQUFFLFVBQVUsc0NBQXNDLHNCQUFzQixnQkFBZ0IsRUFBRSxRQUFRLG9CQUFvQixzQkFBc0IsRUFBRSxRQUFRLG9CQUFvQix3QkFBd0IsRUFBRSxRQUFRLG9CQUFvQix1QkFBdUIsRUFBRSxPQUFPLG9CQUFvQixvQkFBb0Isb0JBQW9CLEVBQUUsbUJBQW1CLGtCQUFrQixFQUFFLGtCQUFrQixxQkFBcUIsRUFBRSxVQUFVLDZDQUE2QyxFQUFFLGVBQWUsc0JBQXNCLHlCQUF5QixFQUFFLGtCQUFrQixlQUFlLEVBQUUsaUNBQWlDLGVBQWUsRUFBRSw2QkFBNkIsZUFBZSxFQUFFLGFBQWEsZUFBZSxFQUFFLDBEQUEwRCxpQkFBaUIsRUFBRSx5REFBeUQsaUJBQWlCLEVBQUUsY0FBYyxnQkFBZ0IsRUFBRSw0QkFBNEIsa0JBQWtCLEVBQUUsMkJBQTJCLGtCQUFrQixFQUFFLG1CQUFtQixlQUFlLEVBQUUsa0JBQWtCLGVBQWUsRUFBRSxXQUFXLHdCQUF3QixFQUFFLGFBQWEscUJBQXFCLEVBQUUsT0FBTyxzQkFBc0IsRUFBRSxlQUFlLG9CQUFvQixFQUFFLFlBQVksa0JBQWtCLEVBQUUsd0JBQXdCLGNBQWMsRUFBRSxhQUFhLGtCQUFrQixFQUFFLDZCQUE2QiwyQkFBMkIsRUFBRSx3QkFBd0IsdUJBQXVCLG1CQUFtQixZQUFZLFdBQVcsY0FBYyxhQUFhLEVBQUUsaUJBQWlCLGtCQUFrQiwyQkFBMkIsRUFBRSx3QkFBd0IscUJBQXFCLEVBQUUsdUJBQXVCLG9CQUFvQixtQkFBbUIsRUFBRSwrQ0FBK0Msd0JBQXdCLEVBQUUsc0NBQXNDLHlCQUF5QixFQUFFLHlCQUF5QixxQkFBcUIsRUFBRSxZQUFZLGtCQUFrQix3QkFBd0Isa0NBQWtDLHNCQUFzQixxRUFBcUUsRUFBRSxrQkFBa0Isd0JBQXdCLEVBQUUsY0FBYyxnQkFBZ0IsRUFBRSxxQkFBcUIsd0JBQXdCLEVBQUUsaUJBQWlCLHFCQUFxQixrQkFBa0IsZUFBZSxFQUFFLG9CQUFvQix1QkFBdUIsd0JBQXdCLEVBQUUsZ0NBQWdDLDJCQUEyQiw0QkFBNEIsb0NBQW9DLEVBQUUsa0NBQWtDLDhCQUE4Qix1QkFBdUIsRUFBRSw0Q0FBNEMsb0NBQW9DLEVBQUUsaURBQWlELHNCQUFzQixvQ0FBb0MsRUFBRSxzQkFBc0Isd0JBQXdCLG9CQUFvQix3QkFBd0IsRUFBRSwyQkFBMkIsNkJBQTZCLEVBQUUsZUFBZSxrQkFBa0IsMkJBQTJCLHFCQUFxQixpQ0FBaUMsOEJBQThCLEVBQUUsK0JBQStCLHFCQUFxQixtQkFBbUIsRUFBRSxtQkFBbUIsbUJBQW1CLHdCQUF3Qix1QkFBdUIsa0JBQWtCLEVBQUUsdUJBQXVCLDBCQUEwQixxQkFBcUIsRUFBRSxxQkFBcUIseUJBQXlCLHdCQUF3QixFQUFFLCtDQUErQyxxQkFBcUIsRUFBRSw0QkFBNEIscUJBQXFCLHFCQUFxQixnQkFBZ0IsbUJBQW1CLGtCQUFrQixnQ0FBZ0MsRUFBRSxXQUFXLHVCQUF1QixnQ0FBZ0MsRUFBRSx1Q0FBdUMseUJBQXlCLGNBQWMsYUFBYSxrQkFBa0IsbUJBQW1CLEVBQUUsc0JBQXNCLHlCQUF5Qiw2QkFBNkIsRUFBRSxnQ0FBZ0Msd0JBQXdCLGdCQUFnQixFQUFFLGFBQWEsa0JBQWtCLG9CQUFvQiwrQkFBK0Isc0JBQXNCLDJCQUEyQixFQUFFLHNCQUFzQiw2QkFBNkIsRUFBRSw4QkFBOEIsZUFBZSxjQUFjLEVBQUUsYUFBYSw2QkFBNkIsbUJBQW1CLGNBQWMsZUFBZSwwQkFBMEIsb0JBQW9CLHdCQUF3QixnQkFBZ0Isa0NBQWtDLG9CQUFvQixFQUFFLG9CQUFvQixxQkFBcUIsdUJBQXVCLHlCQUF5Qix5QkFBeUIsNkJBQTZCLHdCQUF3QixFQUFFLG1EQUFtRCx1Q0FBdUMsNkNBQTZDLHNCQUFzQiw2QkFBNkIsRUFBRSx5QkFBeUIseUJBQXlCLDBCQUEwQixrQkFBa0IsY0FBYyxhQUFhLGtCQUFrQix3QkFBd0IseUJBQXlCLGdDQUFnQywyQkFBMkIsRUFBRSxtQ0FBbUMsMEVBQTBFLEVBQUUsbUJBQW1CLDBCQUEwQiw2QkFBNkIsRUFBRSxvQkFBb0IsMEJBQTBCLDJCQUEyQix1QkFBdUIscUJBQXFCLG1CQUFtQixFQUFFLHdCQUF3Qiw2QkFBNkIsRUFBRSx3QkFBd0IsMkJBQTJCLEVBQUUsd0JBQXdCLHFCQUFxQixvQkFBb0IsRUFBRSxrQ0FBa0MsVUFBVSwwQkFBMEIsaUJBQWlCLEVBQUUsRUFBRSxnQkFBZ0IsMEJBQTBCLDBDQUEwQyxFQUFFLDhCQUE4Qiw0QkFBNEIseUJBQXlCLEVBQUUsMEJBQTBCLHlCQUF5Qix1QkFBdUIsZ0NBQWdDLHdCQUF3QixtQkFBbUIsRUFBRSwrQkFBK0Isb0JBQW9CLEVBQUUsaUNBQWlDLDRCQUE0QixrQkFBa0IseUJBQXlCLG1CQUFtQixnQ0FBZ0MsRUFBRSxzQ0FBc0MscUJBQXFCLEVBQUUsMEZBQTBGLDhCQUE4QixFQUFFLDRGQUE0Riw4QkFBOEIsRUFBRSxpRUFBaUUsZ0JBQWdCLDhCQUE4QixvQkFBb0IsRUFBRSwwQ0FBMEMsb0JBQW9CLDhCQUE4QixFQUFFLGdEQUFnRCwyQ0FBMkMsRUFBRSxjQUFjLDZCQUE2QixjQUFjLGlCQUFpQixlQUFlLDBCQUEwQixvQkFBb0IsRUFBRSxxQkFBcUIsd05BQXdOLG9CQUFvQiwwQkFBMEIsaUJBQWlCLHlCQUF5QixnQ0FBZ0MsNkJBQTZCLG1CQUFtQix3QkFBd0Isd0JBQXdCLHNCQUFzQiwwQkFBMEIsNkJBQTZCLGtCQUFrQixzQkFBc0IsRUFBRSw2QkFBNkIsK0RBQStELDJCQUEyQixFQUFFLDRCQUE0QixrQkFBa0IsZ0NBQWdDLEVBQUUsb0NBQW9DLG1CQUFtQixFQUFFLG1DQUFtQyxtQkFBbUIsNkNBQTZDLEVBQUUsK0JBQStCLDRCQUE0QixFQUFFLHFDQUFxQyxxQkFBcUIsRUFBRSxzQ0FBc0Msa0JBQWtCLDRCQUE0QixnQ0FBZ0MsRUFBRSxvQ0FBb0MsNEJBQTRCLEVBQUUsMENBQTBDLHFCQUFxQixFQUFFLDJDQUEyQyxrQkFBa0IsNEJBQTRCLGdDQUFnQyxFQUFFLGtDQUFrQyw0QkFBNEIsRUFBRSx3Q0FBd0MscUJBQXFCLEVBQUUseUNBQXlDLGtCQUFrQiw0QkFBNEIsZ0NBQWdDLEVBQUUsYUFBYSxvQkFBb0Isa0JBQWtCLDRCQUE0Qix3QkFBd0IsWUFBWSxhQUFhLFdBQVcsY0FBYyxxQkFBcUIsK0RBQStELEVBQUUscUJBQXFCLG9CQUFvQixFQUFFLGdDQUFnQywyQkFBMkIsdUJBQXVCLEVBQUUsK0JBQStCLDJCQUEyQiw2Q0FBNkMsZ0NBQWdDLHVCQUF1QixnQ0FBZ0MsRUFBRSw2QkFBNkIsb0JBQW9CLG9DQUFvQyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBRSxrREFBa0Qsd0JBQXdCLDRCQUE0QixFQUFFLHFCQUFxQixzQkFBc0Isc0JBQXNCLEVBQUUsOEJBQThCLDRCQUE0QixFQUFFLGtDQUFrQyx3QkFBd0IsRUFBRSxxQ0FBcUMscUJBQXFCLEVBQUUsb0NBQW9DLHNCQUFzQixFQUFFLG1DQUFtQyx1QkFBdUIsRUFBRSxnQ0FBZ0MsdUJBQXVCLHFCQUFxQixnQkFBZ0IsaUJBQWlCLEVBQUUseUVBQXlFLGtCQUFrQix5QkFBeUIsY0FBYyxhQUFhLGVBQWUsaUNBQWlDLEVBQUUsc0NBQXNDLGlDQUFpQyxFQUFFLGtGQUFrRixpQkFBaUIsRUFBRSxrRkFBa0YsZ0JBQWdCLEVBQUUseUNBQXlDLGtCQUFrQix1QkFBdUIsRUFBRSxnREFBZ0QsZ0VBQWdFLEVBQUUsK0NBQStDLGlCQUFpQixnQkFBZ0IsZ0VBQWdFLEVBQUUsNENBQTRDLGVBQWUsdUJBQXVCLEVBQUUsbURBQW1ELGlCQUFpQixnRUFBZ0UsRUFBRSxrREFBa0QsaUJBQWlCLGlCQUFpQixnRUFBZ0UsRUFBRSwwQ0FBMEMsaUJBQWlCLEVBQUUsaURBQWlELGdFQUFnRSxFQUFFLGdEQUFnRCxpQkFBaUIsZ0JBQWdCLGdFQUFnRSxFQUFFLDJDQUEyQyxnQkFBZ0IsRUFBRSxrREFBa0QsaUJBQWlCLGVBQWUsZ0VBQWdFLEVBQUUsaURBQWlELGlCQUFpQixrQkFBa0IsZ0JBQWdCLGdFQUFnRSxFQUFFLGlCQUFpQixtQkFBbUIsMkNBQTJDLGtCQUFrQixnQkFBZ0IsaUJBQWlCLDBCQUEwQixvQkFBb0IsdUJBQXVCLDhCQUE4QixFQUFFLGlDQUFpQyxvQkFBb0IsbUJBQW1CLEVBQUUsMkJBQTJCLHNCQUFzQiwrQkFBK0Isa0JBQWtCLEVBQUUsa0NBQWtDLDRCQUE0QixzQkFBc0IsRUFBRSw4Q0FBOEMsb0JBQW9CLEVBQUUsaUJBQWlCLHdCQUF3QixFQUFFLGlCQUFpQixrQkFBa0Isd0JBQXdCLG1CQUFtQixFQUFFLHVCQUF1QixpQkFBaUIsRUFBRSw2QkFBNkIsc0NBQXNDLEVBQUUsb0JBQW9CLHFCQUFxQixvQkFBb0Isd0JBQXdCLGlCQUFpQixFQUFFLFlBQVksdUJBQXVCLEVBQUUsbUNBQW1DLDBCQUEwQixFQUFFLDJCQUEyQiw0QkFBNEIscUJBQXFCLEVBQUUsNEJBQTRCLGdDQUFnQyxFQUFFLGlFQUFpRSxrQkFBa0IsZ0NBQWdDLEVBQUUsMEJBQTBCLDRCQUE0QixxQkFBcUIsRUFBRSwyQkFBMkIsZ0NBQWdDLEVBQUUsK0RBQStELGtCQUFrQixnQ0FBZ0MsRUFBRSxXQUFXLHlCQUF5QixFQUFFLGVBQWUseUJBQXlCLEVBQUUsa0JBQWtCLHVCQUF1QiwyQkFBMkIsdUJBQXVCLEVBQUUsd0JBQXdCLGtCQUFrQiw0REFBNEQseUJBQXlCLDZCQUE2QixnQkFBZ0IsZUFBZSx3QkFBd0Isd0JBQXdCLGlCQUFpQixtQkFBbUIsa0NBQWtDLG1DQUFtQyxFQUFFLG9EQUFvRCxnQ0FBZ0MsRUFBRSxnRUFBZ0Usb0JBQW9CLHdCQUF3QixFQUFFLGNBQWMsdUJBQXVCLHFCQUFxQixFQUFFLHVCQUF1Qiw2Q0FBNkMsb0JBQW9CLGdDQUFnQyxFQUFFLDRCQUE0Qix3QkFBd0IsNEJBQTRCLEVBQUUsb0NBQW9DLDZCQUE2QixpQ0FBaUMsd0JBQXdCLEVBQUUsMkJBQTJCLG9CQUFvQixFQUFFOztBQUUzdWY7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYzs7QUFFbkU7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBOzs7Ozs7OztBQ25GQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7O0FDckhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7OztBQ3pRQSxJQUFNc0UsTUFBTSxtQkFBQTNVLENBQVEsR0FBUixFQUFtQnlsQixPQUEvQjs7QUFFQSxJQUFJeFYsTUFBTSxJQUFJMEUsR0FBSixDQUFRO0FBQ2pCOUosa0JBQWlCLHlCQUFTbEgsTUFBVCxFQUFpQlYsT0FBakIsRUFBMEJZLElBQTFCLEVBQWdDa0gsU0FBaEMsRUFBMkM7QUFDM0QsTUFBSTlILFFBQVFrQyxJQUFSLEtBQWlCLGVBQWpCLElBQW9DNEYsU0FBeEMsRUFBbUQ7QUFDbERwSCxVQUFPcEYsU0FBUCxHQUFtQixXQUFXb0YsT0FBT3BGLFNBQWxCLEdBQThCLFNBQWpEO0FBQ0E7O0FBRUQsU0FBT29GLE1BQVA7QUFDQTtBQVBnQixDQUFSLENBQVY7O0FBVUFzTSxJQUFJdEgsSUFBSixDQUNDLHdCQURELEVBRUMsdUJBRkQsRUFHRU8sS0FIRixDQUdRLFVBQUN4RSxLQUFELEVBQVc7QUFDbEJDLFNBQVFELEtBQVIsQ0FBY0EsS0FBZDtBQUNBLENBTEQsRSIsImZpbGUiOiJtYWluLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBhc3NldHMvY29uc3RhbnRzXG4gKi9cblxuLyoqXG4gKiBBY3Rpb24gdHlwZXNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBhY3Rpb25UeXBlcyA9IHtcblx0VUlfU1RBVEU6ICd1aS1zdGF0ZScsXG5cdFpPTkVfQUREX0FUVEFDSE1FTlQ6ICd6b25lLWFkZC1hdHRhY2htZW50Jyxcblx0Wk9ORV9FRElUX0FUVEFDSE1FTlQ6ICd6b25lLWVkaXQtYXR0YWNobWVudCcsXG5cdFpPTkVfREVUQUNIX0FUVEFDSE1FTlQ6ICd6b25lLWRldGFjaC1hdHRhY2htZW50Jyxcblx0Wk9ORV9DTEVBUl9BTExfQVRUQUNITUVOVFM6ICd6b25lLWNsZWFyLWFsbC1hdHRhY2htZW50cycsXG5cdFNFVF9ESUFMT0dfTU9ERTogJ3NldC1kaWFsb2ctbW9kZScsXG5cdFNFVF9BQ1RJVkVfRFJPUExFVDogJ3NldC1hY3RpdmUtZHJvcGxldCcsXG5cdFNFVF9UT1VSX1NUQUdFOiAnc2V0LXRvdXItc3RhZ2UnLFxuXHRTSE9XX1RPT0xUSVA6ICdzaG93LXRvb2x0aXAnLFxuXHRISURFX1RPT0xUSVA6ICdoaWRlLXRvb2x0aXAnLFxuXHRTRVRfVE9PTFRJUF9DT05URU5UOiAnc2V0LXRvb2x0aXAtY29udGVudCcsXG5cdENPTVBMRVRFX0ZJUlNUX0RST1A6ICdjb21wbGV0ZS1maXJzdC1kcm9wJyxcblx0Q09NUExFVEVfTEFTVF9EUk9QOiAnY29tcGxldGUtbGFzdC1kcm9wJyxcblx0UkVTRVRfQVBQOiAncmVzZXQtYXBwJ1xufTtcblxuLyoqXG4gKiBEaWFsb2cgbW9kZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGRpYWxvZ01vZGVzID0ge1xuXHROT05FOiAnbm9uZScsXG5cdEdFTkVSQUw6ICdnZW5lcmFsJyxcblx0RURJVF9EUk9QTEVUOiAnZWRpdC1kcm9wbGV0Jyxcblx0VE9VUjogJ3RvdXInXG59O1xuXG5leHBvcnQgY29uc3QgdWlTdGF0ZXMgPSB7XG5cdElOSVRJQUxJU0lORzogJ2luaXRpYWxpc2luZycsXG5cdEFDVElWRTogJ2FjdGl2ZSdcbn07XG5cbmV4cG9ydCBjb25zdCBtZXNzYWdlQ29tbWFuZHMgPSB7XG5cdFJFTE9BRDogJ3JlbG9hZCcsXG5cdFJFU0VUOiAncmVzZXQnLFxuXHRESUFMT0c6ICdkaWFsb2cnLFxuXHRESUFMT0dfQ0FMTEJBQ0s6ICdkaWFsb2ctY2FsbGJhY2snXG59O1xuXG5leHBvcnQgY29uc3QgZXJyb3JDb2RlcyA9IHtcblx0Tk9UX0FfRFJPUExFVDogJ0EgdmFsaWQgRHJvcGxldCBpbnN0YW5jZSBtdXN0IGJlIHBhc3NlZCB0byBEcm9wWm9uZSN3aWxsQWNjZXB0Lidcbn07XG5cbmV4cG9ydCBjb25zdCBzZXRMYWJlbHMgPSB7XG5cdHZhbHVlOiAnVmFsdWUnLFxuXHRhdHRyczogJ0F0dHJpYnV0ZXMnLFxuXHR0YWdOYW1lOiAnVGFnIG5hbWUnLFxuXHRpbm5lckhUTUw6ICdIVE1MIGNvbnRlbnQnXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvYXNzZXRzL2NvbnN0YW50cy5qcyIsImV4cG9ydCBjb25zdCByZWdpc3RlckdlbmVyYWxFdmVudCA9IGZ1bmN0aW9uKGNvbXBvbmVudCwgaWQsIGluZm8pIHtcblx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRpZiAodHlwZW9mIGNvbXBvbmVudC5wcm9wcy5vbkV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjb21wb25lbnQucHJvcHMub25FdmVudC5hcHBseShjb21wb25lbnQsIFtldmVudCwgaW5mbywgaWRdLmNvbmNhdChcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMylcblx0XHRcdCkpO1xuXHRcdH1cblx0fS5iaW5kKHRoaXMpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbGxlY3RSZWYgPSBmdW5jdGlvbihwcm9wcywgY29sbGVjdGlvbiwga2V5KSB7XG5cdHJldHVybiBmdW5jdGlvbihyZWYpIHtcblx0XHRpZiAodHlwZW9mIHByb3BzLnJlZkNvbGxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cHJvcHMucmVmQ29sbGVjdG9yKGNvbGxlY3Rpb24sIHJlZiwga2V5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQncmVmIGNvbGxlY3Rpb24gdXNlZCBidXQgbm8gY29sbGVjdG9yIGhhcyBiZWVuIHNldCB1cCBmb3IgJyArXG5cdFx0XHRcdGNvbGxlY3Rpb24gKyAoa2V5ID8gJy8nICsga2V5IDogJycpXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGZvciB2YWxpZGF0aW5nIHNwZWNpZmljIGtleXMgd2l0aGluIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlUHJvcEtleXMgPSBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdHJldHVybiBmdW5jdGlvbihwcm9wcywga2V5LCBjb21wb25lbnQpIHtcblx0XHR2YXIgYTtcblxuXHRcdGZvciAoYSA9IDA7IGEgPCByZXF1aXJlLmxlbmd0aDsgYSArPSAxKSB7XG5cdFx0XHRpZiAoIXByb3BzW2tleV0uaGFzT3duUHJvcGVydHkocmVxdWlyZVthXSkgJiZcblx0XHRcdFx0cHJvcHNba2V5XVtyZXF1aXJlW2FdXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J1Byb3BcdGAnICsga2V5ICsgJ2AgZG9lcyBub3QgY29udGFpbiBkZWZpbml0aW9uIGAnICsgcmVxdWlyZVthXSArXG5cdFx0XHRcdFx0XHQnYCBpbiAnICsgY29tcG9uZW50ICsgJyBjb21wb25lbnQuJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbi8qKlxuICogRXNjYXBlcyBhIHN0cmluZyBmb3IgdXNlIGFzIGEgbWF0Y2ggd2l0aGluIGEgcmVnZXhcbiAqIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNDQ2MTcwL2VzY2FwZS1zdHJpbmctZm9yLXVzZS1pbi1qYXZhc2NyaXB0LXJlZ2V4LzY5Njk0ODYjNjk2OTQ4NlxuICovXG5leHBvcnQgY29uc3QgZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24oc3RyKSB7XG5cdHJldHVybiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csICdcXCQmJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmF3TWFya3VwID0gZnVuY3Rpb24oaHRtbCkge1xuXHRyZXR1cm4geyBfX2h0bWw6IGh0bWwgfTtcbn07XG5cblxuLyoqXG4gKiBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfU3RvcmFnZV9BUEkvVXNpbmdfdGhlX1dlYl9TdG9yYWdlX0FQSS5cbiAqIENoZWNrcyBpZiBsb2NhbFN0b3JhZ2Ugd29ya3MuXG4gKiAobG9jYWxTdG9yYWdlIGNhbiBiZSBkaXNhYmxlZCB1c2luZyBzZWN1cml0eSBwb2xpY2llcyBvciBwcml2YXRlIGJyb3dzaW5nIG1vZGVzKVxuICovXG5leHBvcnQgY29uc3QgY2hlY2tTdG9yYWdlID0gZnVuY3Rpb24odHlwZSkge1xuXHR0cnkge1xuXHRcdHZhciBzdG9yYWdlID0gd2luZG93W3R5cGVdLFxuXHRcdFx0eCA9ICdfX3RhZ19zdG9yYWdlX3Rlc3RfXyc7XG5cdFx0c3RvcmFnZS5zZXRJdGVtKHgsIHgpO1xuXHRcdHN0b3JhZ2UucmVtb3ZlSXRlbSh4KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvdmlkZXMgbG9vc2UgY29tcGFyaXNvbiBvZiB0aGUga2V5cyBvZiB0d28gb2JqZWN0cy5cbiAqIElmIHRoZSB2YWx1ZSBvZiBhIGtleSBpcyBhbiBhcnJheSwgdGhlIHRlc3Qgb2JqZWN0J3Mga2V5IGlzIGFsc28gY29uZmlybWVkIHRvIGJlIHRoZSBzYW1lIHR5cGUuXG4gKiBJZiB0aGUgYWx1ZSBvZiBhIGtleSBpcyBhbiBvYmplY3QsIGl0IGlzIHRlc3RlZCByZWN1cnNpdmVseS5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0ZXN0IC0gVGVzdCBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBleHBlY3RlZCAtIEV4cGVjdGVkIHJlc3VsdFxuICovXG5leHBvcnQgY29uc3Qgc3RydWN0Q29tcGFyZSA9IGZ1bmN0aW9uKHRlc3QsIGV4cGVjdGVkKSB7XG5cdHZhciByZXN1bHQgPSB0cnVlLFxuXHRcdGtleTtcblxuXHRpZiAodHlwZW9mIHRlc3QgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmb3IgKGtleSBpbiBleHBlY3RlZCkge1xuXHRcdGlmIChleHBlY3RlZC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRpZiAodHlwZW9mIGV4cGVjdGVkW2tleV0gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkW2tleV0pKSB7XG5cdFx0XHRcdFx0Ly8gZXhwZWN0ZWQgdmFsdWUgaXMgYW4gYXJyYXlcblx0XHRcdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkodGVzdFtrZXldKSkge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGV4cGVjdCB2YWx1ZSBpcyBhbiBvYmplY3Rcblx0XHRcdFx0XHRpZiAoKGtleSBpbiB0ZXN0KSkge1xuXHRcdFx0XHRcdFx0Ly8ga2V5IGV4aXN0cyBpbiB0ZXN0XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSBzdHJ1Y3RDb21wYXJlKHRlc3Rba2V5XSwgZXhwZWN0ZWRba2V5XSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gdmFsdWUgaXMgKHByb2JhYmx5KSBzY2FsYXJcblx0XHRcdFx0aWYgKCEoa2V5IGluIHRlc3QpKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBpZiB0aGUgcmVzdWx0IGlzIGZhbHNlIGF0IGFueSBwb2ludCwganVzdCBicmVhayBoZXJlXG5cdFx0aWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvbGliL3V0aWxzLmpzIiwiLyoqXG4gKiBAbW9kdWxlIGNvbXBvbmVudHMvdmlld3MvSWNvblxuICovXG5pbXBvcnQgUmVhY3QsIHsgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEljb24gZ2x5cGhzIGF2YWlsYWJsZSBmb3IgdXNlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFRFWFRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBQVVpaTEVfUElFQ0VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBUQUdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBDT01QQVNTXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTE9PUF9DSVJDVUxBUlxuICogQHByb3BlcnR5IHtzdHJpbmd9IE1FRElBX1BMQVlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBMSUdIVEJVTEJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBSRVNJWkVfV0lEVEhcbiAqL1xuZXhwb3J0IGNvbnN0IEdMWVBIUyA9IHtcblx0VEVYVDogcmVxdWlyZSgnLi4vLi4vaW1nL3N2Zy90ZXh0LnN2ZycpLFxuXHRQVVpaTEVfUElFQ0U6IHJlcXVpcmUoJy4uLy4uL2ltZy9zdmcvcHV6emxlLXBpZWNlLnN2ZycpLFxuXHRUQUc6IHJlcXVpcmUoJy4uLy4uL2ltZy9zdmcvdGFnLnN2ZycpLFxuXHRDT01QQVNTOiByZXF1aXJlKCcuLi8uLi9pbWcvc3ZnL2NvbXBhc3Muc3ZnJyksXG5cdExPT1BfQ0lSQ1VMQVI6IHJlcXVpcmUoJy4uLy4uL2ltZy9zdmcvbG9vcC1jaXJjdWxhci5zdmcnKSxcblx0TUVESUFfUExBWTogcmVxdWlyZSgnLi4vLi4vaW1nL3N2Zy9tZWRpYS1wbGF5LnN2ZycpLFxuXHRMSUdIVEJVTEI6IHJlcXVpcmUoJy4uLy4uL2ltZy9zdmcvbGlnaHRidWxiLnN2ZycpLFxuXHRSRVNJWkVfV0lEVEg6IHJlcXVpcmUoJy4uLy4uL2ltZy9zdmcvcmVzaXplLXdpZHRoLnN2ZycpLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIEljb24ocHJvcHMpIHtcblx0dmFyIGNsYXNzTmFtZSA9IHByb3BzLmdseXBoLnJlcGxhY2UoL14jLywgJycpO1xuXG5cdHJldHVybiAoXG5cdFx0PHN2ZyBjbGFzc05hbWU9XCJpY29uXCIgd2lkdGg9e3Byb3BzLndpZHRofSBoZWlnaHQ9e3Byb3BzLmhlaWdodH0+XG5cdFx0XHQ8dXNlIHhsaW5rSHJlZj17cHJvcHMuZ2x5cGh9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfS8+XG5cdFx0PC9zdmc+XG5cdCk7XG59XG5cbkljb24uZGVmYXVsdFByb3BzID0ge1xuXHR3aWR0aDogMTYsXG5cdGhlaWdodDogMTZcbn07XG5cbkljb24ucHJvcFR5cGVzID0ge1xuXHR3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcblx0aGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuXHRnbHlwaDogUHJvcFR5cGVzLnN0cmluZyxcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL0ljb24uanN4IiwidmFyIFNwcml0ZSA9IHJlcXVpcmUoJy4vc3ByaXRlJyk7XG52YXIgZ2xvYmFsU3ByaXRlID0gbmV3IFNwcml0ZSgpO1xuXG5pZiAoZG9jdW1lbnQuYm9keSkge1xuICBnbG9iYWxTcHJpdGUuZWxlbSA9IGdsb2JhbFNwcml0ZS5yZW5kZXIoZG9jdW1lbnQuYm9keSk7XG59IGVsc2Uge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgIGdsb2JhbFNwcml0ZS5lbGVtID0gZ2xvYmFsU3ByaXRlLnJlbmRlcihkb2N1bWVudC5ib2R5KTtcbiAgfSwgZmFsc2UpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFNwcml0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdmctc3ByaXRlLWxvYWRlci9saWIvd2ViL2dsb2JhbC1zcHJpdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBEcm9wbGV0IGZyb20gJy4vRHJvcGxldCc7XG5pbXBvcnQgeyBlcnJvckNvZGVzIH0gZnJvbSAnLi4vYXNzZXRzL2NvbnN0YW50cyc7XG5cbnZhciBEcm9wWm9uZSwgZHJvcF96b25lX2lkID0gMDtcblxuLyoqXG4gKiBAY2xhc3NcbiAqL1xuRHJvcFpvbmUgPSBmdW5jdGlvbihkYXRhID0ge30sIHRhZykge1xuXHR0aGlzLnRhZyA9IHRhZztcblx0dGhpcy5pZCA9ICdkcm9wX3pvbmVfJyArICsrZHJvcF96b25lX2lkO1xuXHR0aGlzLmF0dGFjaG1lbnRJZCA9IGRhdGEuYXR0YWNobWVudElkO1xuXHR0aGlzLm1heEF0dGFjaG1lbnRzID0gKHR5cGVvZiBkYXRhLm1heEF0dGFjaG1lbnRzICE9PSAndW5kZWZpbmVkJyA/IGRhdGEubWF4QXR0YWNobWVudHMgOiAxKTtcbn07XG5cbkRyb3Bab25lLnByb3RvdHlwZSA9IHtcblx0LyoqXG5cdCAqIFRlc3QgaWYgdGhlIERyb3Bab25lIGluc3RhbmNlIHdpbGwgYWNjZXB0IGEgbmV3IGRyb3BsZXQuIFRoZSB0ZXN0IGxvb2tzIGF0IHRoZVxuXHQgKiBtYXhpbXVtIG51bWJlciBvZiBhdHRhY2htZW50cyBhbmQgYXR0YWNobWVudCBlbGlnaWJpbGl0eSBiYXNlZCBvbiBhdHRhY2htZW50SWRcblx0ICovXG5cdHdpbGxBY2NlcHQ6IGZ1bmN0aW9uKGRyb3BsZXQsIHN0b3JlKSB7XG5cdFx0dmFyIGN1cnJlbnRfYXR0YWNobWVudHMgPSAwLFxuXHRcdFx0c3RhdGU7XG5cblx0XHRpZiAoIShkcm9wbGV0IGluc3RhbmNlb2YgRHJvcGxldCkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihlcnJvckNvZGVzLk5PVF9BX0RST1BMRVQpO1xuXHRcdH1cblxuXHRcdGlmIChzdG9yZSkge1xuXHRcdFx0Ly8gc3RvcmUgZXhpc3RzIC0gZ2V0IHN0YXRlIChhbmQgY3VycmVudCBudW1iZXIgb2YgYXR0YWNobWVudHMpXG5cdFx0XHRzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cblx0XHRcdGlmIChzdGF0ZS56b25lc1t0aGlzLmlkXSAmJiBzdGF0ZS56b25lc1t0aGlzLmlkXS5hdHRhY2htZW50cykge1xuXHRcdFx0XHRjdXJyZW50X2F0dGFjaG1lbnRzID0gc3RhdGUuem9uZXNbdGhpcy5pZF0uYXR0YWNobWVudHMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRlc3QgYXR0YWNobWVudCBjb3VudFxuXHRcdGlmICh0aGlzLm1heEF0dGFjaG1lbnRzICE9PSAwICYmIGN1cnJlbnRfYXR0YWNobWVudHMgPT09IHRoaXMubWF4QXR0YWNobWVudHMpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyB0ZXN0IGF0dGFjaG1lbnRJZCBlbGlnaWJpbGl0eVxuXHRcdGlmICh0aGlzLmF0dGFjaG1lbnRJZCAhPT0gJyonICYmXG5cdFx0XHRkcm9wbGV0LmF0dGFjaG1lbnRJZHMuaW5kZXhPZih0aGlzLmF0dGFjaG1lbnRJZCkgPT09IC0xKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbi8qKlxuICogTWF0Y2hlcyBhIGRyb3Agem9uZSB3aXRoaW4gdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqIENhbiBiZSB1c2VkIG1vcmUgdGhhbiBvbmNlIG9uIHRoZSBzYW1lIG1hcmt1cCwgYW5kIHdpbGwgaW50ZXJuYWxseSBpbmNyZW1lbnQgdGhyb3VnaCB0aGUgZGF0YS5cbiAqL1xuRHJvcFpvbmUuZmV0Y2hab25lID0gZnVuY3Rpb24obWFya3VwKSB7XG5cdHZhciBtYXRjaCwgem9uZTtcblxuXHQvLyBrZWVwIGxvb2tpbmcgZm9yIGEgdmFsaWQgZHJvcCB6b25lIC0gcmVwb3J0IG9uIHRoZSBiYWQgb25lc1xuXHR3aGlsZSAoKG1hdGNoID0gRHJvcFpvbmUuX3JlX3pvbmVzLmV4ZWMobWFya3VwKSkgIT09IG51bGwpIHtcblx0XHRpZiAobWF0Y2ggIT09IG51bGwgJiYgKHpvbmUgPSBEcm9wWm9uZS5jaGVja1N5bnRheChtYXRjaFswXSkpKSB7XG5cdFx0XHQvLyByZXR1cm4gaXRcblx0XHRcdHJldHVybiBuZXcgRHJvcFpvbmUoe1xuXHRcdFx0XHRhdHRhY2htZW50SWQ6IHpvbmUuYXR0YWNobWVudElkLFxuXHRcdFx0XHRtYXhBdHRhY2htZW50czogem9uZS5tYXhBdHRhY2htZW50c1xuXHRcdFx0fSwgbWF0Y2hbMF0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDaGVja3MgYW5kIHJlcG9ydHMgb24gc3ludGF4IGVycm9ycyB3aXRoaW4gYSBzdXBwbGllZCB0YWcuXG4gKi9cbkRyb3Bab25lLmNoZWNrU3ludGF4ID0gZnVuY3Rpb24odGFnKSB7XG5cdHZhciBkO1xuXG5cdGlmICgoZCA9IHRhZy5tYXRjaChEcm9wWm9uZS5zeW50YXhfcmUucmVfc3RydWN0dXJlKSkgIT09IG51bGwgJiYgZFsxXSAhPT0gbnVsbCkge1xuXHRcdC8vIGNoZWNrIGlkIHBvcnRpb25cblx0XHRpZiAoIWRbMl0gfHwgIURyb3Bab25lLnN5bnRheF9yZS5yZV9pZC50ZXN0KGRbMl0pKSB7XG5cdFx0XHRyZXR1cm4gRHJvcFpvbmUuc255dGF4RmF1bHQoXG5cdFx0XHRcdGRbMV0sXG5cdFx0XHRcdCdJbnZhbGlkIHN5bnRheC4gSUQgbXVzdCBlaXRoZXIgc3RhcnQgd2l0aCBhIGxldHRlciBhbmQgb25seSBjb250YWluJyArXG5cdFx0XHRcdCcgbGV0dGVycywgbnVtYmVycywgYW5kIHRoZSB1bmRlc2NvcmUgKF8pIGNoYXJhY3Rlciwgb3IgYmUgYW4gYXN0ZXJpc2sgKCopICcgK1xuXHRcdFx0XHQndG8gc3BlY2lmeSBhbnkgYXR0YWNobWVudCBJRC4nLFxuXHRcdFx0XHRkWzJdXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIGNoZWNrIHF1YW50aXR5IHBvcnRpb25cblx0XHRpZiAoXG5cdFx0XHRkWzRdICYmXG5cdFx0XHQoXG5cdFx0XHRcdCFEcm9wWm9uZS5zeW50YXhfcmUucmVfcXR5LnRlc3QoZFs0XSkgfHxcblx0XHRcdFx0KGRbNF0gPCAxIHx8IGRbNF0gPiAxMDApXG5cdFx0XHQpXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gRHJvcFpvbmUuc255dGF4RmF1bHQoXG5cdFx0XHRcdGRbMV0sXG5cdFx0XHRcdCdJbnZhbGlkIHN5bnRheC4gUXVhbnRpdHkgbXVzdCBiZSBhIHZhbGlkIG51bWJlciBhbmQgYmV0d2VlbiAxIGFuZCAxMDAsICcgK1xuXHRcdFx0XHRcdCdvciB0aGUgYXN0ZXJpc2sgKCopIGNoYXJhY3RlciB0byBzcGVjaWZ5IHVubGltaXRlZCB1cCB0byB0aGUgaW50ZXJuYWwgbWF4aW11bS4nLFxuXHRcdFx0XHRkWzRdXG5cdFx0XHQpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gRHJvcFpvbmUuc255dGF4RmF1bHQodGFnLCAnSW52YWxpZCBzeW50YXguJyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGF0dGFjaG1lbnRJZDogZFsyXSxcblx0XHRtYXhBdHRhY2htZW50czogKGRbNF0gPT09ICcqJyA/IDAgOiAocGFyc2VGbG9hdChkWzRdKSB8fCAxKSlcblx0fTtcbn07XG5cbkRyb3Bab25lLnNueXRheEZhdWx0ID0gZnVuY3Rpb24oc3RyLCBtZXNzYWdlLCBjaGFyKSB7XG5cdHZhciBlcnJvcjtcblxuXHRpZiAoY2hhcikge1xuXHRcdC8vIGVzY2FwZSAlIHN5bWJvbHNcblx0XHRzdHIgPSBzdHIucmVwbGFjZSgnJScsICclJScpO1xuXHRcdGNoYXIgPSBjaGFyLnJlcGxhY2UoJyUnLCAnJSUnKTtcblxuXHRcdC8vIGFkZCBjb2xvdXJpbmdcblx0XHRzdHIgPSBzdHIucmVwbGFjZShjaGFyLCAnJWMkJiVjJyk7XG5cblx0XHRlcnJvciA9ICdFcnJvciB3aXRoIHN5bnRheCBpbiB0YWcgXCInICsgc3RyICsgJ1wiOiAnICsgbWVzc2FnZTtcblx0XHRjb25zb2xlLndhcm4oZXJyb3IsICdjb2xvcjogcmVkOycsICdjb2xvcjogaW5oZXJpdDsnKTtcblx0fSBlbHNlIHtcblx0XHQvLyBiYXNpYyBlcnJvciB3aXRoIG5vIGNvbG91cmluZ1xuXHRcdGVycm9yID0gJ0Vycm9yIHdpdGggc3ludGF4IGluIHRhZyBcIicgKyBzdHIgKyAnXCI6ICcgKyBtZXNzYWdlO1xuXHRcdGNvbnNvbGUud2FybihlcnJvcik7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERpc2NyaW1pbmF0aW5nIHJlZ2V4IGNvbGxlY3Rpb24gZm9yIHRlc3RpbmcgZHJvcCB6b25lcyB3aXRoIGV4cGxpY2l0IHN5bnRheC5cbiAqL1xuRHJvcFpvbmUuc3ludGF4X3JlID0ge1xuXHRyZV9zdHJ1Y3R1cmU6IC9eXFx7XFx7XFxzPygoW158XFxzXSspKFxcfChbXnxcXHNdKikpPylcXHM/XFx9XFx9JC8sXG5cdHJlX2lkOiAvXlthLXoqXVthLXowLTlfXSokL2ksXG5cdHJlX3F0eTogL15bMC05Kl0rJC9cbn07XG5cbi8qKlxuICogSW5jbHVzaXZlIHJlZ2V4IGZvciBjYXB0dXJpbmcgaW5kaXZpZHVhbCB6b25lcyB3aXRoIGJhc2ljIHN5bnRheFxuICovXG5Ecm9wWm9uZS5fcmVfem9uZXMgPSAvXFx7XFx7XFxzPyguKz8pKFxcfCguKj8pKT9cXHM/XFx9XFx9L2dpO1xuXG5leHBvcnQgZGVmYXVsdCBEcm9wWm9uZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2xpYi9Ecm9wWm9uZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIHNpbmdsZSBgZWRpdGFibGVgIGRlZmlpdGlvbiB0byBwcm9kdWNlIG9uZSBmaWVsZC5cbiAqIEB0eXBlZGVmIEVkaXRhYmxlSXRlbURlZmluaXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIC0gT25lIG9mICd0ZXh0JywgJ2xvbmd0ZXh0JywgJ2Ryb3Bkb3duJywgJ2NoZWNrYm94Jywgb3IgJ3JhZGlvJy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbH0gW3JlcXVpcmVkXSAtIFdoZXRoZXIgdGhlIGZpZWxkIG11c3QgYmUgZmlsbGVkIGluIG9yIG5vdC5cbiAqIEBwcm9wZXJ0eSB7bWl4ZWR9IFt2YWx1ZV0gLSBFaXRoZXIgYW4gYXJyYXkgb2YgdmFsdWVzLCBvciBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyXSAtIEluIHRoZSBjYXNlIG9mIGEgdGV4dCB2YWx1ZSwgdGhpcyB3aWxsIHNob3cgaW4gcGxhY2Ugb2YgZW1wdHkgdmFsdWVzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RlZF0gLSBJbiB0aGUgY2FzZSBvZiBhbiBhcnJheSB2YWx1ZSwgdGhpcyBzZXQgdGhlIHZhbHVlIGFzICdzZWxlY3RlZCcuXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuL1Byb3BUeXBlcyc7XG5pbXBvcnQgRm9ybUZpZWxkIGZyb20gJy4vRm9ybUZpZWxkJztcblxudmFyIERyb3BsZXQsIGRyb3BsZXRfaWQgPSAwO1xuXG4vKipcbiAqIEluZGl2aWR1YWwgZHJvcGxldCBjbGFzcy4gSGFuZGxlcyB2YWxpZGF0aW9uIG9mIHByb3BzIGluIGEgc2ltaWxhciBmYXNoaW9uIHRvXG4gKiBSZWFjdCwgYnV0IChwcm9iYWJseSkgd2l0aCBhIGxvdCBsZXNzIHN0eWxlLlxuICogQGNsYXNzXG4gKi9cbkRyb3BsZXQgPSBmdW5jdGlvbihzZXR0aW5ncyA9IHt9LCBpZCkge1xuXHRpZiAodHlwZW9mIGlkID09PSAnbnVtYmVyJykge1xuXHRcdHRoaXMuaWQgPSAnZHJvcGxldF8nICsgaWQ7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5pZCA9ICdkcm9wbGV0XycgKyArK2Ryb3BsZXRfaWQ7XG5cdH1cblxuXHR0aGlzLl9vcmlnaW5hbFNldHRpbmdzID0gT2JqZWN0LmRlZXBBc3NpZ24oe30sIHNldHRpbmdzKTtcblx0dGhpcy5kYXRhID0ge307XG5cdHRoaXMubmFtZSA9IG51bGw7XG5cdHRoaXMuZHJvcGxldFR5cGUgPSBudWxsO1xuXHR0aGlzLmF0dGFjaG1lbnRJZHMgPSBbXTtcblxuXHR0aGlzLmluaXQoKTtcbn07XG5cbkRyb3BsZXQucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogSW5pdGlhbGlzYXRpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHQvLyBzZXQgYmFzZSBwcm9wZXJ0aWVzIGZvciBhbGwgZHJvcGxldHNcblx0XHR0aGlzLl92YWxpZGF0ZUFuZFNldChbXG5cdFx0XHQnbmFtZScsXG5cdFx0XHQnZHJvcGxldFR5cGUnLFxuXHRcdFx0J2F0dGFjaG1lbnRJZHMnLFxuXHRcdFx0J2VkaXRhYmxlJyxcblx0XHRcdCdndWlkYW5jZSdcblx0XHRdLCB0aGlzKTtcblxuXHRcdC8vIGNoZWNrIGRyb3BsZXQgdHlwZSBpcyB2YWxpZFxuXHRcdHN3aXRjaCAodGhpcy5kcm9wbGV0VHlwZSkge1xuXHRcdGNhc2UgJ2VsZW1lbnQnOlxuXHRcdGNhc2UgJ3RleHQnOlxuXHRcdGNhc2UgJ2F0dHJpYnV0ZSc6XG5cdFx0XHR0aGlzLl9zZXRFeHRyYUZpZWxkcygpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdEcm9wbGV0IHR5cGUgJyArIHRoaXMuZHJvcGxldFR5cGUgKyAnIGlzIGludmFsaWQuJyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgdHlwZSBzcGVjaWZpYyBmaWVsZHMgZm9yIHZhbGlkYXRpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfc2V0RXh0cmFGaWVsZHM6IGZ1bmN0aW9uKCkge1xuXHRcdHN3aXRjaCAodGhpcy5kcm9wbGV0VHlwZSkge1xuXHRcdGNhc2UgJ3RleHQnOlxuXHRcdFx0dGhpcy5fdmFsaWRhdGVBbmRTZXQoWyd2YWx1ZSddLCB0aGlzLmRhdGEpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdlbGVtZW50Jzpcblx0XHRcdHRoaXMuX3ZhbGlkYXRlQW5kU2V0KFsnYXR0cnMnLCAndGFnTmFtZScsICdpbm5lckhUTUwnXSwgdGhpcy5kYXRhKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnYXR0cmlidXRlJzpcblx0XHRcdHRoaXMuX3ZhbGlkYXRlQW5kU2V0KFsna2V5JywgJ3ZhbHVlJ10sIHRoaXMuZGF0YSk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFZhbGlkYXRlcyAodXNpbmcgdGhlIFByb3BUeXBlIGZ1bmN0aW9ucykgYW5kIHNldHMgdGhlIGluc3RhbmNlIHZhbHVlc1xuXHQgKiBnaXZlbiB0aGUgZGVmaW5lZCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0X3ZhbGlkYXRlQW5kU2V0KHZhbHVlcywgY29udGV4dCkge1xuXHRcdHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuXHRcdFx0aWYgKERyb3BsZXQuUHJvcFR5cGVzLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoRHJvcGxldC5Qcm9wVHlwZXNbdmFsdWVdKFxuXHRcdFx0XHRcdFx0dGhpcy5fb3JpZ2luYWxTZXR0aW5nc1t2YWx1ZV0sXG5cdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHRcdHRoaXMuX29yaWdpbmFsU2V0dGluZ3MubmFtZSB8fCBudWxsLFxuXHRcdFx0XHRcdFx0dGhpcy5fb3JpZ2luYWxTZXR0aW5ncy5kcm9wbGV0VHlwZSB8fCBudWxsXG5cdFx0XHRcdFx0KSkge1xuXHRcdFx0XHRcdGNvbnRleHRbdmFsdWVdID0gdGhpcy5fb3JpZ2luYWxTZXR0aW5nc1t2YWx1ZV07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRHJvcGxldCBwcm9wZXJ0eSBcIicgKyB2YWx1ZSArICdcIiBkZWZpbml0aW9uIGRvZXMgbm90IGV4aXN0LicpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59O1xuXG4vKipcbiAqIERlc2lnbmVkIGFzIGEgUHJvcFR5cGUgdmFsaWRhdG9yIG11Y2ggbGlrZSBzdHJpbmcsIGlzUmVxdWlyZWQsIGFycmF5T2YgZXRjLCB0aGlzXG4gKiBmdW5jdGlvbiBzcGVjaWZpY2FsbHkgdGVzdHMgdGhlIHZhbGlkaXR5IG9mIHRoZSBgZWRpdGFibGVgIHByb3AgYW5kIGl0cyBjaGlsZHJlbi5cbiAqL1xuRHJvcGxldC5fdmFsaWRhdGVFZGl0YWJsZVNldCA9IGZ1bmN0aW9uKHZhbHVlLCBwcm9wLCBkcm9wbGV0X25hbWUsIGRyb3BsZXRfdHlwZSkge1xuXHR2YXIgYXR0cmlidXRlLCBrZXksIGF0dHJrZXksXG5cdFx0cHJvcF9lcnJvciA9ICdFcnJvciBpbiBEcm9wbGV0IHByb3AgJyArIGRyb3BsZXRfbmFtZSArICcgKCcgKyBwcm9wICsgJyk6JztcblxuXHQvLyBhbGxvdyB1bmRlZmluZWQgdmFsdWVzXG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyB0ZXN0aW5nIHRoZSBkcm9wbGV0IHZhbHVlXG5cdGlmIChQcm9wVHlwZXMuX2Fzc2VydChcblx0XHQodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyksIHByb3AsICdWYWx1ZSBtdXN0IGJlIGFuIG9iamVjdC4nLCBkcm9wbGV0X25hbWUsIGRyb3BsZXRfdHlwZVxuXHQpKSB7XG5cdFx0Ly8gY29udGludWUgdGVzdGluZ1xuXHRcdGZvciAoa2V5IGluIHZhbHVlKSB7XG5cdFx0XHQvLyB0ZXN0aW5nIGluZGl2aWR1YWwgYXR0cmlidXRlc1xuXHRcdFx0YXR0cmlidXRlID0gdmFsdWVba2V5XTtcblxuXHRcdFx0Ly8gYXR0cmlidXRlIGlzIHVucmVjb2duaXNlZCBvciBub3QgYW4gb2JqZWN0XG5cdFx0XHRpZiAoXG5cdFx0XHRcdERyb3BsZXQuZWRpdGFibGVBdHRyaWJ1dGVzLmluZGV4T2Yoa2V5KSA9PT0gLTEgfHxcblx0XHRcdFx0dHlwZW9mIGF0dHJpYnV0ZSAhPT0gJ29iamVjdCdcblx0XHRcdCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0cHJvcF9lcnJvciArICcgXCInICsga2V5ICsgJ1wiIGlzIG5vdCBhbiBlZGl0YWJsZSBhdHRyaWJ1dGUgb3IgaXMgb2YgdGhlIHdyb25nIHR5cGUnXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGF0dHJpYnV0ZSBpcyAnYXR0cnMnLCBidXQgaXMgbm90IGFuIG9iamVjdCBvZiBvYmplY3RzXG5cdFx0XHRpZiAoa2V5ID09PSAnYXR0cnMnKSB7XG5cdFx0XHRcdGZvciAoYXR0cmtleSBpbiBhdHRyaWJ1dGUpIHtcblx0XHRcdFx0XHREcm9wbGV0Ll92YWxpZGF0ZUVkaXRhYmxlSXRlbShhdHRya2V5LCBhdHRyaWJ1dGVbYXR0cmtleV0sIHByb3BfZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHREcm9wbGV0Ll92YWxpZGF0ZUVkaXRhYmxlSXRlbShrZXksIGF0dHJpYnV0ZSwgcHJvcF9lcnJvcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5Ecm9wbGV0Ll92YWxpZGF0ZUVkaXRhYmxlSXRlbSA9IGZ1bmN0aW9uKGl0ZW0sIGRhdGEsIGVycm9yX3ByZWZpeCkge1xuXHR2YXIgZXJyb3IgPSBlcnJvcl9wcmVmaXggKyBpdGVtICsgJyAtICc7XG5cblx0aWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvciArICdub3QgYW4gRWRpdGFibGVJdGVtRGVmaW5pdGlvbiBvYmplY3QnKTtcblx0fVxuXG5cdC8vIGNoZWNrIFwidHlwZVwiIGV4aXN0c1xuXHRpZiAodHlwZW9mIGRhdGEudHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3IgKyAnZG9lc27igJl0IGNvbnRhaW4g4oCYdHlwZeKAmSB2YWx1ZScpO1xuXHR9XG5cblx0Ly8gY2hlY2sgXCJ0eXBlXCIgaXMgdmFsaWRcblx0aWYgKERyb3BsZXQuZWRpdGFibGVGaWVsZFR5cGVzLmluZGV4T2YoZGF0YS50eXBlKSA9PT0gLTEpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3IgKyAnaW52YWxpZCB0eXBlIGF0dHJpYnV0ZSBcIicgKyBkYXRhLnR5cGUgKyAnXCInKTtcblx0fVxuXG5cdC8vIHJ1biBjaGVja3Mgb24gdGhlIGVkaXRhYmxlIGF0dHJpYnV0ZXMgdGhhdCBtYXRjaCBGb3JtRmllbGQgZGF0YSBhdHRyaWJ1dGVzXG5cdEZvcm1GaWVsZC52YWxpZGF0ZURhdGFBdHRyaWJ1dGUoZGF0YSwgaXRlbSwgZXJyb3JfcHJlZml4KTtcblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgcG9zc2libGUgcHJvcCB0eXBlcyBmb3IgRHJvcGxldHMuIFNvbWUgYXJlIGFsd2F5cyByZXF1aXJlZC5cbiAqIEBwcm9wIHtzdHJpbmd9IHZhbHVlIC0gRHJvcGxldCAndmFsdWUnLiBXaGVuIHVzZWQgYXMgYW4gYGF0dHJpYnV0ZWAgdHlwZSB2YWx1ZSwgY2FuIGJlXG4gKiBzZXQgdG8gYG51bGxgIHRvIGRlZmluZSBhIHZhbHVlLWxlc3MgYXR0cmlidXRlLlxuICogQHByb3Age3N0cmluZ30gbmFtZSAtIERyb3BsZXQgbmFtZSAodXNlZCBhcyBhIGxhYmVsKS5cbiAqIEBwcm9wIHtzdHJpbmdbXX0gYXR0YWNobWVudElkcyAtIERyb3Agem9uZSBhdHRhY2htZW50IElEcy5cbiAqIEBwcm9wIHtzdHJpbmd9IGRyb3BsZXRUeXBlIC0gRHJvcGxldCB0eXBlLiBPbmUgb2YgYGVsZW1lbnRgLCBgdGV4dGAgb3IgYGF0dHJpYnV0ZWAuXG4gKiBAcHJvcCB7b2JqZWN0fSBbYXR0cnNdIC0gRHJvcGxldCBhdHRyaWJ1dGVzLCBpbiB0aGUgY2FzZSBvZiB0aGUgYGVsZW1lbnRgIHR5cGUuXG4gKiBAcHJvcCB7c3RyaW5nfSB0YWduYW1lIC0gRHJvcGxldCB0YWdOYW1lIGF0dHJpYnV0ZSwgaS5lLiB0aGUgYWN0dWFsIEhUTUxFbGVtZW50IHVzZWQuXG4gKiBSZXF1cmVkIHdoZW4gdHlwZSBpcyBgZWxlbWVudGAuXG4gKiBAcHJvcCB7c3RyaW5nfSBpbm5lckhUTUwgLSBEcm9wbGV0J3MgaW5uZXJIVE1MLlxuICogQHByb3Age0VkaXRhYmxlSXRlbURlZmluaXRpb259IGVkaXRhYmxlIC0gRWRpdGFibGUgcHJvcGVydGllcyBvZiBgZWxlbWVudGAgdHlwZXMuIFthZGQgbGluayB0byB0dXRvcmlhbCFdLlxuICogQHByb3Age3N0cmluZ30ga2V5IC0gQXR0cmlidXRlIGtleXMgKG5hbWVzKSBvZiBgYXR0cmlidXRlYCB0eXBlcy5cbiAqL1xuRHJvcGxldC5Qcm9wVHlwZXMgPSB7XG5cdHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cdG5hbWU6IFByb3BUeXBlcy5zdHJpbmcubm90RW1wdHkuaXNSZXF1aXJlZCxcblx0YXR0YWNobWVudElkczogUHJvcFR5cGVzLmFycmF5T2Yuc3RyaW5nLmlzUmVxdWlyZWQsXG5cdGRyb3BsZXRUeXBlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cdGF0dHJzOiBQcm9wVHlwZXMub2JqZWN0LFxuXHR0YWdOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLm5vdEVtcHR5LmlzUmVxdWlyZWQsXG5cdGlubmVySFRNTDogUHJvcFR5cGVzLnN0cmluZyxcblx0ZWRpdGFibGU6IERyb3BsZXQuX3ZhbGlkYXRlRWRpdGFibGVTZXQsXG5cdGtleTogUHJvcFR5cGVzLnN0cmluZy5ub3RFbXB0eS5pc1JlcXVpcmVkLFxuXHRndWlkYW5jZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuRHJvcGxldC5lZGl0YWJsZUF0dHJpYnV0ZXMgPSBbXG5cdCd2YWx1ZScsXHQnYXR0cnMnLFx0J3RhZ05hbWUnLFx0J2lubmVySFRNTCdcbl07XG5cbkRyb3BsZXQuZWRpdGFibGVGaWVsZFR5cGVzID0gW1xuXHQndGV4dCcsXG5cdCdsb25ndGV4dCcsXG5cdCdkcm9wZG93bicsXG5cdCdjaGVja2JveCcsXG5cdCdyYWRpbydcbl07XG5cbmV4cG9ydCBkZWZhdWx0IERyb3BsZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9saWIvRHJvcGxldC5qcyIsImltcG9ydCB7IFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEZvcm1GaWVsZCBmcm9tICcuLi9saWIvRm9ybUZpZWxkJztcblxuZXhwb3J0IGNvbnN0IGZpZWxkID0ge1xuXHRyZWZDb2xsZWN0b3I6IFByb3BUeXBlcy5mdW5jLFxuXHRmaWVsZDogUHJvcFR5cGVzLmluc3RhbmNlT2YoRm9ybUZpZWxkKS5pc1JlcXVpcmVkLFxuXHR2YWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG5cdFx0UHJvcFR5cGVzLnN0cmluZyxcblx0XHRQcm9wVHlwZXMubnVtYmVyLFxuXHRcdFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpXG5cdF0pLmlzUmVxdWlyZWQsXG5cdG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZXhwb3J0IGNvbnN0IGRpYWxvZyA9IHtcblx0ZGF0YTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRzZXR0aW5nczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRyZWZDb2xsZWN0b3I6IFByb3BUeXBlcy5mdW5jLFxuXHRvbkRpYWxvZ0NhbmNlbDogUHJvcFR5cGVzLmZ1bmMsXG5cdG9uRGlhbG9nQ29tcGxldGU6IFByb3BUeXBlcy5mdW5jLFxuXHRvbkJ1dHRvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcblx0bGliOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvYXNzZXRzL2NvbW1vbi1wcm9wLXR5cGVzLmpzIiwiLyoqXG4gKiBGb3JtRmllbGQgZGF0YSBvYmplY3RcbiAqIEB0eXBlZGVmIEZvcm1GaWVsZERhdGFcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVpcmVkXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbF1cbiAqIEBwcm9wZXJ0eSB7bWl4ZWR9IFtvcHRpb25zXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwbGFjZWhvbGRlcl1cbiAqIEBwcm9wZXJ0eSB7bWl4ZWR9IFt2YWx1ZV1cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmllbGQgPSBGb3JtRmllbGQoJ2ZpZWxkbmFtZScsICdkcm9wZG93bicsIHtcbiAqIFx0J2xhYmVsJzogJ1BsZWFzZSBzZWxlY3QgYSB2YWx1ZScsXG4gKiBcdCdvcHRpb25zJzogWydWYWx1ZSAxJywgJ1ZhbHVlIDInLCAnVmFsdWUgMyddLFxuICogXHQndmFsdWUnOiAnVmFsdWUgMidcbiAqIH0pO1xuICovXG5cbiAvKipcbiAqIFRoaXMgY2xhc3MgZXhpc3RzIGFsbW9zdCBlbnRpcmVseSBmb3IgZGF0YSBjb25zaXN0ZW5jeS5cbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBGaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBJbnB1dCB0eXBlLlxuICogQHBhcmFtIHtGb3JtRmllbGREYXRhfSBkYXRhIC0gRmllbGQgZGF0YS5cbiAqL1xudmFyIEZvcm1GaWVsZCA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIGRhdGEgPSB7fSkge1xuXHR0aGlzLl9zZXROYW1lQW5kVHlwZShuYW1lLCB0eXBlKTtcblx0dGhpcy5fdmFsaWRhdGVBbmRTZXQoZGF0YSk7XG59O1xuXG5Gb3JtRmllbGQucHJvdG90eXBlID0ge1xuXHRfc2V0TmFtZUFuZFR5cGU6IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcblx0XHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZmllbGQgbmFtZSBcIicgKyBuYW1lICsgJ1wiJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fFxuXHRcdFx0Rm9ybUZpZWxkLnZhbGlkVHlwZXMuaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmaWVsZCB0eXBlIFwiJyArIHR5cGUgKyAnXCInKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR9XG5cdH0sXG5cblx0X3ZhbGlkYXRlQW5kU2V0OiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0dmFyIF9kYXRhID0gT2JqZWN0LmRlZXBBc3NpZ24oe30sIGRhdGEpO1xuXG5cdFx0aWYgKEZvcm1GaWVsZC52YWxpZGF0ZURhdGFBdHRyaWJ1dGUoXG5cdFx0XHRcdF9kYXRhLFxuXHRcdFx0XHR0aGlzLm5hbWUsXG5cdFx0XHRcdCdFcnJvciB3aXRoIEZvcm1GaWVsZCBkYXRhIGF0dHJpYnV0ZSdcblx0XHRcdCkpIHtcblx0XHRcdHRoaXMuZGF0YSA9IF9kYXRhO1xuXG5cdFx0XHQvLyBleHRlcm5hbGlzZSByZW1haW5pbmcgb3B0aW9uc1xuXHRcdFx0dGhpcy5yZXF1aXJlZCA9IGRhdGEucmVxdWlyZWQ7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBkYXRhLm9wdGlvbnM7XG5cdFx0XHR0aGlzLnBsYWNlaG9sZGVyID0gZGF0YS5wbGFjZWhvbGRlcjtcblx0XHRcdHRoaXMubGFiZWwgPSBkYXRhLmxhYmVsO1xuXG5cdFx0XHR0aGlzLnZhbHVlID0gKHR5cGVvZiBkYXRhLnZhbHVlICE9PSAndW5kZWZpbmVkJykgPyBkYXRhLnZhbHVlIDogJyc7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIEVuc3VyZXMgYSBmb3JtIGZpZWxkJ3MgZGF0YSBhdHRyaWJ1dGVzIGFyZSB2YWxpZFxuICovXG5Gb3JtRmllbGQudmFsaWRhdGVEYXRhQXR0cmlidXRlID0gZnVuY3Rpb24oZGF0YSwgaXRlbSwgZXJyb3JfcHJlZml4KSB7XG5cdHZhciBlcnJvciA9IGVycm9yX3ByZWZpeCArICcgJyArIGl0ZW0gKyAnIC0gJztcblxuXHQvLyBjaGVjayBcInJlcXVpcmVkXCIgaXMgYSBib29sZWFuLCBpZiBkZWZpbmVkXG5cdGlmICh0eXBlb2YgZGF0YS5yZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRhdGEucmVxdWlyZWQgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvciArICdcInJlcXVpcmVkXCIgYXR0cmlidXRlIGlzbuKAmXQgYSBib29sZWFuIHRydWUgb3IgZmFsc2UnKTtcblx0fVxuXG5cdC8vIGNoZWNrIFwib3B0aW9uc1wiIGlzIHZhbGlkXG5cdGlmICh0eXBlb2YgZGF0YS5vcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuXHRcdEZvcm1GaWVsZC5fdmFsaWRhdGVPcHRpb25zU2V0dGluZyhkYXRhLm9wdGlvbnMsIGVycm9yKTtcblx0fVxuXG5cdC8vIGNoZWNrIFwicGxhY2Vob2xkZXJcIiBpcyB2YWxpZFxuXHRpZiAodHlwZW9mIGRhdGEucGxhY2Vob2xkZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkYXRhLnBsYWNlaG9sZGVyICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvciArICdcInBsYWNlaG9sZGVyXCIgYXR0cmlidXRlIGlzbuKAmXQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdC8vIGNoZWNrIFwidmFsdWVcIiBpcyB2YWxpZFxuXHRpZiAodHlwZW9mIGRhdGEudmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0Rm9ybUZpZWxkLl92YWxpZGF0ZVZhbHVlU2V0dGluZyhkYXRhLnZhbHVlLCBkYXRhLm9wdGlvbnMsIGVycm9yKTtcblx0fVxuXG5cdC8vIGNoZWNrIFwibGFiZWxcIiBpcyB2YWxpZFxuXHRpZiAodHlwZW9mIGRhdGEubGFiZWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkYXRhLmxhYmVsICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGVycm9yICsgJ1wibGFiZWxcIiBhdHRyaWJ1dGUgaXNu4oCZdCBhIHN0cmluZydcblx0XHQpO1xuXHR9XG5cblx0Ly8gY2hlY2sgXCJtYXhsZW5ndGhcIiBpcyB2YWxpZFxuXHRpZiAodHlwZW9mIGRhdGEubWF4bGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdCh0eXBlb2YgZGF0YS5tYXhsZW5ndGggIT09ICdudW1iZXInIHx8ZGF0YS5tYXhsZW5ndGggPCAxKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGVycm9yICsgJ1wibWF4bGVuZ3RoXCIgYXR0cmlidXRlIGlzbuKAmXQgYSBudW1iZXIgb3IgYWJvdmUgemVybydcblx0XHQpO1xuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5Gb3JtRmllbGQuX3ZhbGlkYXRlT3B0aW9uc1NldHRpbmcgPSBmdW5jdGlvbihvcHRpb25zLCBlcnJvcl9wcmVmaXgpIHtcblx0dmFyIGtleSwgYSxcblx0XHRlcnJvciA9IGVycm9yX3ByZWZpeCArICdcIm9wdGlvbnNcIiBpcyBvZiBhbiB1bnJlY29nbmlzZWQgdHlwZSc7XG5cblx0aWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcblx0XHRmb3IgKGEgPSAwOyBhIDwgb3B0aW9ucy5sZW5ndGg7IGEgKz0gMSkge1xuXHRcdFx0aWYgKHR5cGVvZiBvcHRpb25zW2FdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuXHRcdGZvciAoa2V5IGluIG9wdGlvbnMpIHtcblx0XHRcdGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3B0aW9uc1trZXldICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3IgKyAnIC0gb2JqZWN0IHZhbHVlcyBtdXN0IGJlIGEgc2ltcGxlIGtleS92YWx1ZSBzZXQnKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAob3B0aW9ucyA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvciArICcgLSBvcHRpb25zIGNhbm5vdCBiZSBudWxsJyk7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkZvcm1GaWVsZC5fdmFsaWRhdGVWYWx1ZVNldHRpbmcgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucywgZXJyb3JfcHJlZml4KSB7XG5cdGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcblx0XHR0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmXG5cdFx0dHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGVycm9yX3ByZWZpeCArICdcInZhbHVlXCIgaXMgb2YgYW4gdW5yZWNvZ25pc2VkIHR5cGUnXG5cdFx0KTtcblx0fVxuXG5cdGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHQvLyB2YWxpZGF0ZSBhZ2FpbnN0IG9wdGlvbnNcblx0XHRpZiAoXG5cdFx0XHQoQXJyYXkuaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLmluZGV4T2YodmFsdWUpID09PSAtMSkgfHxcblx0XHRcdChcblx0XHRcdFx0dHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmXG5cdFx0XHRcdCFBcnJheS5pc0FycmF5KG9wdGlvbnMpICYmXG5cdFx0XHRcdCFvcHRpb25zW3ZhbHVlXVxuXHRcdFx0KVxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRlcnJvcl9wcmVmaXggKyAnXCJ2YWx1ZVwiIGF0dHJpYnV0ZSBjb250YWlucyBhbiBvcHRpb24gdGhhdCBkb2VzbuKAmXQgZXhpc3QnXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxufTtcblxuRm9ybUZpZWxkLnZhbGlkVHlwZXMgPSBbXG5cdCd0ZXh0Jyxcblx0J2xvbmd0ZXh0Jyxcblx0J2Ryb3Bkb3duJyxcblx0J2NoZWNrYm94Jyxcblx0J3JhZGlvJ1xuXTtcblxuZXhwb3J0IGRlZmF1bHQgRm9ybUZpZWxkO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvbGliL0Zvcm1GaWVsZC5qcyIsImltcG9ydCByZXF1ZXN0IGZyb20gJy4vYWpheCc7XG5pbXBvcnQgRHJvcFpvbmUgZnJvbSAnLi9Ecm9wWm9uZSc7XG5pbXBvcnQgRHJvcGxldCBmcm9tICcuL0Ryb3BsZXQnO1xuXG52YXIgVGVtcGxhdGUgPSBmdW5jdGlvbihwYXJlbnQsIHNldHRpbmdzID0ge30pIHtcblx0dGhpcy5fcGFyZW50ID0gcGFyZW50O1xuXHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cdHRoaXMuX2Ryb3Bfem9uZXMgPSB7fTtcblx0dGhpcy5fdGVtcGxhdGUgPSBbXTtcblx0dGhpcy5fbWF4X3pvbmVzID0gMTAwO1xufTtcblxuVGVtcGxhdGUucHJvdG90eXBlID0ge1xuXHRsb2FkOiBmdW5jdGlvbih1cmwpIHtcblx0XHRyZXR1cm4gcmVxdWVzdC5nZXQodXJsKVxuXHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0XHRcdGlmIChyZXNwb25zZS50ZXh0KSB7XG5cdFx0XHRcdFx0dGhpcy5fbWFya3VwID0gcmVzcG9uc2UudGV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5jYXRjaCgoZXJyb3IpID0+IHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yKTtcblx0XHRcdH0pO1xuXHR9LFxuXG5cdGNyZWF0ZTogZnVuY3Rpb24obWFya3VwID0gdGhpcy5fbWFya3VwKSB7XG5cdFx0aWYgKHR5cGVvZiBtYXJrdXAgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIGNyZWF0ZSgpIHdpdGggbm8gbWFya3VwIGRlZmluZWQuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVwbGFjZSBodG1sIHdpdGggZW50aXRpZXNcblx0XHRtYXJrdXAgPSBUZW1wbGF0ZS5lbnRpdGllcyhtYXJrdXApO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZURyb3Bab25lcyhtYXJrdXApO1xuXHR9LFxuXG5cdF9jcmVhdGVEcm9wWm9uZXM6IGZ1bmN0aW9uKG1hcmt1cCkge1xuXHRcdHZhciB6b25lLCBjb3VudGVyID0gMDtcblxuXHRcdC8vIGxvb3AgdGhyb3VnaCBtYXJrdXAgZmluZGluZyBkcm9wIHpvbmVzXG5cdFx0d2hpbGUgKCh6b25lID0gRHJvcFpvbmUuZmV0Y2hab25lKG1hcmt1cCkpICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9kcm9wX3pvbmVzW3pvbmUuaWRdID0gem9uZTtcblx0XHRcdGNvdW50ZXIgKz0gMTtcblxuXHRcdFx0aWYgKGNvdW50ZXIgPT09IHRoaXMuX21heF96b25lcykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J01heGltdW0gbnVtYmVyIG9mIHpvbmVzIGluIHRlbXBsYXRlIHJlYWNoZWQgKCcgKyB0aGlzLl9tYXhfem9uZXMgKyAnKS4nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIGNvbGxlY3RlZCBkcm9wIHpvbmVzIGFuZCByZXBsYWNlIHRhZ3MgaW4gbWFya3VwXG5cdFx0Zm9yICh6b25lIGluIHRoaXMuX2Ryb3Bfem9uZXMpIHtcblx0XHRcdG1hcmt1cCA9IG1hcmt1cC5yZXBsYWNlKFxuXHRcdFx0XHR0aGlzLl9kcm9wX3pvbmVzW3pvbmVdLnRhZyxcblx0XHRcdFx0JzxzcGFuJyArXG5cdFx0XHRcdFx0JyBkYXRhLWlkPVwiJyArIHRoaXMuX2Ryb3Bfem9uZXNbem9uZV0uaWQgKyAnXCInICtcblx0XHRcdFx0XHQnIGRhdGEtYXR0YWNobWVudD1cIicgKyB0aGlzLl9kcm9wX3pvbmVzW3pvbmVdLmF0dGFjaG1lbnRJZCArICdcIj4nICtcblx0XHRcdFx0Jzwvc3Bhbj4nXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RlbXBsYXRlID0gdGhpcy5fY3JlYXRlVGVtcGxhdGVBcnJheShtYXJrdXApO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRyb3Bfem9uZXM6IHRoaXMuX2Ryb3Bfem9uZXMsXG5cdFx0XHR0ZW1wbGF0ZTogdGhpcy5fdGVtcGxhdGVcblx0XHR9O1xuXHR9LFxuXG5cdF9jcmVhdGVUZW1wbGF0ZUFycmF5OiBmdW5jdGlvbihtYXJrdXApIHtcblx0XHR2YXIgc2FuZGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdFx0ZGF0YSA9IFtdLFxuXHRcdFx0bm9kZSwgYTtcblx0XHRzYW5kYm94LmlubmVySFRNTCA9IG1hcmt1cDtcblxuXHRcdGZvciAoYSA9IDA7IChub2RlID0gc2FuZGJveC5jaGlsZE5vZGVzW2FdKTsgYSArPSAxKSB7XG5cdFx0XHRzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcblx0XHRcdGNhc2UgTm9kZS5URVhUX05PREU6XG5cdFx0XHRcdGRhdGEucHVzaCh7XG5cdFx0XHRcdFx0dHlwZTogJ3RleHQnLFxuXHRcdFx0XHRcdGNvbnRlbnQ6IG5vZGUudGV4dENvbnRlbnRcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuXHRcdFx0XHRkYXRhLnB1c2goe1xuXHRcdFx0XHRcdHR5cGU6ICdkcm9wem9uZScsXG5cdFx0XHRcdFx0em9uZTogdGhpcy5fZHJvcF96b25lc1tub2RlLmRhdGFzZXQuaWRdXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblxuXHRyZW5kZXJBc0hUTUw6IGZ1bmN0aW9uKHpvbmVzKSB7XG5cdFx0dmFyIGh0bWwgPSAnJztcblxuXHRcdHRoaXMuX3RlbXBsYXRlLmZvckVhY2goKG5vZGUpID0+IHtcblx0XHRcdGlmIChub2RlLnR5cGUgPT09ICd0ZXh0Jykge1xuXHRcdFx0XHQvLyBwbGFpbiB0ZXh0IG5vZGVcblx0XHRcdFx0aHRtbCArPSBub2RlLmNvbnRlbnQ7XG5cdFx0XHR9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ2Ryb3B6b25lJyAmJiB6b25lc1tub2RlLnpvbmUuaWRdKSB7XG5cdFx0XHRcdC8vIGRyb3Agem9uZSB3aXRoIGF0dGFjaG1lbnRzXG5cdFx0XHRcdHpvbmVzW25vZGUuem9uZS5pZF0uYXR0YWNobWVudHMuZm9yRWFjaCgoYXR0YWNobWVudCkgPT4ge1xuXHRcdFx0XHRcdHZhciBkcm9wbGV0ID0gdGhpcy5fcGFyZW50Ll9VSS5nZXREcm9wbGV0QnlJZChhdHRhY2htZW50LmRyb3BsZXRfaWQpLFxuXHRcdFx0XHRcdFx0ZGF0YSA9IE9iamVjdC5kZWVwQXNzaWduKHt9LCBkcm9wbGV0LmRhdGEsIGF0dGFjaG1lbnQuZGF0YSk7XG5cblx0XHRcdFx0XHRodG1sICs9IFRlbXBsYXRlLnJlbmRlckRyb3BsZXQoXG5cdFx0XHRcdFx0XHRkcm9wbGV0LFxuXHRcdFx0XHRcdFx0ZGF0YSxcblx0XHRcdFx0XHRcdHRoaXMuX3BhcmVudC5fVUkuZ2V0RHJvcFpvbmVCeUlkKG5vZGUuem9uZS5pZCksXG5cdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLm9uRWxlbWVudFJlbmRlclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGh0bWw7XG5cdH1cbn07XG5cblRlbXBsYXRlLnJlbmRlckRyb3BsZXQgPSBmdW5jdGlvbihkcm9wbGV0LCBkYXRhLCBkcm9wX3pvbmUsIGlzX291dHB1dCA9IHRydWUpIHtcblx0dmFyIG91dHB1dDtcblxuXHRpZiAoIShkcm9wbGV0IGluc3RhbmNlb2YgRHJvcGxldCkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Ryb3BsZXQgYXJndW1lbnQgbXVzdCBiZSBhIERyb3BsZXQgaW5zdGFuY2UnKTtcblx0fVxuXG5cdHN3aXRjaCAoZHJvcGxldC5kcm9wbGV0VHlwZSkge1xuXHRjYXNlICdlbGVtZW50Jzpcblx0XHRvdXRwdXQgPSBUZW1wbGF0ZS5yZW5kZXJFbGVtZW50RHJvcGxldChkYXRhLCBkcm9wbGV0LCBkcm9wX3pvbmUsIGlzX291dHB1dCk7XG5cdFx0YnJlYWs7XG5cblx0Y2FzZSAndGV4dCc6XG5cdFx0b3V0cHV0ID0gVGVtcGxhdGUucmVuZGVyVGV4dERyb3BsZXQoZGF0YSwgZHJvcGxldCwgZHJvcF96b25lLCBpc19vdXRwdXQpO1xuXHRcdGJyZWFrO1xuXG5cdGNhc2UgJ2F0dHJpYnV0ZSc6XG5cdFx0b3V0cHV0ID0gVGVtcGxhdGUucmVuZGVyQXR0cmlidXRlRHJvcGxldChkYXRhLCBkcm9wbGV0LCBkcm9wX3pvbmUsIGlzX291dHB1dCk7XG5cdFx0YnJlYWs7XG5cdH1cblxuXHRyZXR1cm4gb3V0cHV0O1xufTtcblxuVGVtcGxhdGUucmVuZGVyRWxlbWVudERyb3BsZXQgPSBmdW5jdGlvbihkYXRhLCBkcm9wbGV0LCBkcm9wX3pvbmUsIGlzX291dHB1dCkge1xuXHQvLyBUT0RPIC0gbWFrZSBzdXJlIHNlbGYtY2xvc2luZyB0YWdzIGFyZSBjb3JyZWN0bHkgcmVuZGVyZWRcblx0dmFyIGF0dHJzID0gW10sXG5cdFx0bWFya3VwID0ge30sXG5cdFx0YXR0cjtcblxuXHRtYXJrdXAub3BlbiA9ICc8JyArIGRhdGEudGFnTmFtZTtcblxuXHRpZiAoZGF0YS5hdHRycykge1xuXHRcdGZvciAoYXR0ciBpbiBkYXRhLmF0dHJzKSB7XG5cdFx0XHRhdHRycy5wdXNoKGF0dHIgKz0gJz1cIicgKyBUZW1wbGF0ZS5lbnRpdGllcyhkYXRhLmF0dHJzW2F0dHJdKSArICdcIicpO1xuXHRcdH1cblxuXHRcdGlmIChhdHRycy5sZW5ndGgpIHtcblx0XHRcdG1hcmt1cC5vcGVuICs9ICcgJyArIGF0dHJzLmpvaW4oJyAnKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoZGF0YS5pbm5lckhUTUwgfHwgVGVtcGxhdGUudm9pZFRhZ3MuaW5kZXhPZihkYXRhLnRhZ05hbWUpID09PSAtMSkge1xuXHRcdG1hcmt1cC5vcGVuICs9ICc+Jztcblx0XHRtYXJrdXAuaW5uZXJIVE1MID0gKGRhdGEuaW5uZXJIVE1MIHx8ICcnKTtcblx0XHRtYXJrdXAuY2xvc2UgPSAnPC8nICsgZGF0YS50YWdOYW1lICsgJz4nO1xuXHR9IGVsc2Uge1xuXHRcdG1hcmt1cC5jbG9zZSA9ICcvPic7XG5cdH1cblxuXHRtYXJrdXAgPSBUZW1wbGF0ZS5vbkVsZW1lbnRSZW5kZXIoXG5cdFx0bWFya3VwLFxuXHRcdGRyb3BsZXQsXG5cdFx0ZHJvcF96b25lLFxuXHRcdGlzX291dHB1dFxuXHQpO1xuXG5cdHJldHVybiBtYXJrdXAub3BlbiArIChtYXJrdXAuaW5uZXJIVE1MIHx8ICcnKSArIG1hcmt1cC5jbG9zZTtcbn07XG5cblRlbXBsYXRlLnJlbmRlclRleHREcm9wbGV0ID0gZnVuY3Rpb24oZGF0YSwgZHJvcGxldCwgZHJvcF96b25lLCBpc19vdXRwdXQpIHtcblx0dmFyIHZhbHVlID0gVGVtcGxhdGUub25FbGVtZW50UmVuZGVyKFxuXHRcdGRhdGEudmFsdWUsXG5cdFx0ZHJvcGxldCxcblx0XHRkcm9wX3pvbmUsXG5cdFx0aXNfb3V0cHV0XG5cdCk7XG5cblx0cmV0dXJuIFRlbXBsYXRlLmVudGl0aWVzKHZhbHVlKTtcbn07XG5cblRlbXBsYXRlLnJlbmRlckF0dHJpYnV0ZURyb3BsZXQgPSBmdW5jdGlvbihkYXRhLCBkcm9wbGV0LCBkcm9wX3pvbmUsIGlzX291dHB1dCkge1xuXHR2YXIgbWFya3VwID0ge1xuXHRcdGtleTogZGF0YS5rZXksXG5cdFx0dmFsdWU6IGRhdGEudmFsdWVcblx0fTtcblxuXHRtYXJrdXAgPSBUZW1wbGF0ZS5vbkVsZW1lbnRSZW5kZXIoXG5cdFx0bWFya3VwLFxuXHRcdGRyb3BsZXQsXG5cdFx0ZHJvcF96b25lLFxuXHRcdGlzX291dHB1dFxuXHQpO1xuXG5cdHJldHVybiBtYXJrdXAua2V5ICsgJz1cIicgKyBUZW1wbGF0ZS5lbnRpdGllcyhtYXJrdXAudmFsdWUpICsgJ1wiJztcbn07XG5cblRlbXBsYXRlLmVudGl0aWVzID0gZnVuY3Rpb24oc3RyKSB7XG5cdHJldHVybiBzdHIucmVwbGFjZSgvW1xcdTAwQTAtXFx1OTk5OTw+XFwmXS9naW0sIChpKSA9PlxuXHRcdCgnJiMnICsgaS5jaGFyQ29kZUF0KDApICsgJzsnKVxuXHQpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbWFya3VwIC0gVGhlIGN1cnJlbnQgbWFya3VwIGRhdGEgYXMgc2V0IGJ5IFRlbXBsYXRlI3JlbmRlckRyb3BsZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gZHJvcGxldCAtIFRoZSBEcm9wbGV0IGJlaW5nIHJlbmRlcmVkLlxuICogQHBhcmFtIHtvYmplY3R9IHpvbmUgLSBUaGUgRHJvcCBab25lIHRoZSBEcm9wbGV0IGlzIGF0dGFjaGVkIHRvLlxuICogQHBhcmFtIHtib29sfSBpc19vdXRwdXQgLSBTZWUgYmVsb3cuXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJlY2VpdmVzIGVsZW1lbnQgZGF0YSBmcm9tIERyb3BsZXRzIGFzIGF0dGFjaGVkIHRvIERyb3AgWm9uZXMsIGFzIHdlbGwgYXMgdGhlXG4gKiBleGlzdGluZyBtYXJrdXAgYWJvdXQgdG8gYmUgcmVuZGVyZWQuIFRoZSByZXR1cm4gdmFsdWUgc2hvdWxkIGVxdWFsIHRoZSBgbWFya3VwYFxuICogYXJndW1lbnQgc2VudCBidXQgY2FuIGJlIGF1Z21lbnRlZCB0byBhbHRlciByZW5kZXJpbmcuXG4gKlxuICogIyMgVGhlIGBpc19vdXRwdXRgIGFyZ3VtZW50LlxuICogUmVuZGVyaW5nIGNhbiB0YWtlIHBsYWNlIGluIHR3byBmb3JtczogRWl0aGVyIGZvciB0aGUgdGVtcGxhdGUgZGlzcGxheSBvciB3aXRoaW4gYXNcbiAqIHRvb2x0aXBzIGFzIHZpc2libGUgc291cmNlIGNvZGUsIG9yIHdpdGhpbiB0aGUgdmlldyBmcmFtZSBhcyBwYXJ0IG9mIGFuIG91dHB1dHRlZCBwYWdlLlxuICogVGhlIGBpc19vdXRwdXRgIGFyZ3VtZW50IHdpbGwgYmUgYGZhbHNlYCBpbiB0aGUgZm9ybWVyIGNhc2UgYW5kIGB0cnVlYCBpbiB0aGUgbGF0dGVyLlxuICovXG5UZW1wbGF0ZS5vbkVsZW1lbnRSZW5kZXIgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIGFyZ3VtZW50c1swXTtcbn07XG5cbi8qKlxuICogRnJvbSBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbC9zeW50YXguaHRtbCN3cml0aW5nLWh0bWwtZG9jdW1lbnRzLWVsZW1lbnRzXG4gKiBUaGlzIGFycmF5IGlzIGEgbGlzdCBvZiB0YWcgY29uc2lkZXJlZCB0byBiZSBcInZvaWRcIiBhbmQgaGF2ZSBubyBjbG9zaW5nIHRhZy5cbiAqIEFsbCBvdGhlciB0YWdzIGNhbiAoYW5kIGRvKSBoYXZlIGNsb3NpbmcgdGFncyB3aGVuIGJlaW5nIHJlbmRlcmVkLlxuICovXG5UZW1wbGF0ZS52b2lkVGFncyA9IFtcblx0J2FyZWEnLCAnYmFzZScsICdicicsICdjb2wnLCAnZW1iZWQnLCAnaHInLCAnaW1nJywgJ2lucHV0JywgJ2tleWdlbicsXG5cdCdsaW5rJywgJ21lbnVpdGVtJywgJ21ldGEnLCAncGFyYW0nLCAnc291cmNlJywgJ3RyYWNrJywgJ3dicidcbl07XG5cbmV4cG9ydCBkZWZhdWx0IFRlbXBsYXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvbGliL1RlbXBsYXRlLmpzIiwiaW1wb3J0IHsgYWN0aW9uVHlwZXMgfSBmcm9tICcuLi9hc3NldHMvY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRzZXRVSVN0YXRlOiBmdW5jdGlvbih1aV9zdGF0ZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBhY3Rpb25UeXBlcy5VSV9TVEFURSxcblx0XHRcdHVpX3N0YXRlXG5cdFx0fTtcblx0fSxcblxuXHRyZXNldEFwcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IGFjdGlvblR5cGVzLlJFU0VUX0FQUFxuXHRcdH07XG5cdH0sXG5cblx0Y29tcGxldGVGaXJzdERyb3A6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBhY3Rpb25UeXBlcy5DT01QTEVURV9GSVJTVF9EUk9QXG5cdFx0fTtcblx0fSxcblxuXHRjb21wbGV0ZUxhc3REcm9wOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogYWN0aW9uVHlwZXMuQ09NUExFVEVfTEFTVF9EUk9QXG5cdFx0fTtcblx0fSxcblxuXHRzZXRBY3RpdmVEcm9wbGV0OiBmdW5jdGlvbihkcm9wbGV0X2lkKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IGFjdGlvblR5cGVzLlNFVF9BQ1RJVkVfRFJPUExFVCxcblx0XHRcdGRyb3BsZXRfaWRcblx0XHR9O1xuXHR9LFxuXG5cdHNldERpYWxvZ01vZGU6IGZ1bmN0aW9uKG1vZGUsIGRhdGEgPSB7fSwgb25EaWFsb2dDb21wbGV0ZSwgb25EaWFsb2dDYW5jZWwpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogYWN0aW9uVHlwZXMuU0VUX0RJQUxPR19NT0RFLFxuXHRcdFx0bW9kZSxcblx0XHRcdGRhdGEsXG5cdFx0XHRvbkRpYWxvZ0NvbXBsZXRlLFxuXHRcdFx0b25EaWFsb2dDYW5jZWxcblx0XHR9O1xuXHR9LFxuXG5cdHpvbmVBZGRBdHRhY2htZW50OiBmdW5jdGlvbihpZCwgZHJvcGxldF9pZCwgYXR0YWNoZWQsIGRhdGEpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogYWN0aW9uVHlwZXMuWk9ORV9BRERfQVRUQUNITUVOVCxcblx0XHRcdGlkLFxuXHRcdFx0ZHJvcGxldF9pZCxcblx0XHRcdGF0dGFjaGVkLFxuXHRcdFx0ZGF0YVxuXHRcdH07XG5cdH0sXG5cblx0em9uZUVkaXRBdHRhY2htZW50OiBmdW5jdGlvbihpZCwgYXR0YWNobWVudF9pbmRleCwgZGF0YSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBhY3Rpb25UeXBlcy5aT05FX0VESVRfQVRUQUNITUVOVCxcblx0XHRcdGlkLFxuXHRcdFx0YXR0YWNobWVudF9pbmRleCxcblx0XHRcdGRhdGFcblx0XHR9O1xuXHR9LFxuXG5cdHpvbmVEZXRhY2hBdHRhY2htZW50OiBmdW5jdGlvbihpZCwgYXR0YWNobWVudF9pbmRleCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBhY3Rpb25UeXBlcy5aT05FX0RFVEFDSF9BVFRBQ0hNRU5ULFxuXHRcdFx0aWQsXG5cdFx0XHRhdHRhY2htZW50X2luZGV4XG5cdFx0fTtcblx0fSxcblxuXHR6b25lQ2xlYXJBbGxBdHRhY2htZW50czogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IGFjdGlvblR5cGVzLlpPTkVfQ0xFQVJfQUxMX0FUVEFDSE1FTlRTXG5cdFx0fTtcblx0fSxcblxuXHRzZXRUb3VyU3RhZ2U6IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IGFjdGlvblR5cGVzLlNFVF9UT1VSX1NUQUdFLFxuXHRcdFx0c3RhZ2Vcblx0XHR9O1xuXHR9LFxuXG5cdHNob3dUb29sdGlwOiBmdW5jdGlvbihhdHRhY2htZW50LCBvcHRpb25zPXt9KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IGFjdGlvblR5cGVzLlNIT1dfVE9PTFRJUCxcblx0XHRcdGF0dGFjaG1lbnQsXG5cdFx0XHRvcHRpb25zXG5cdFx0fTtcblx0fSxcblxuXHRoaWRlVG9vbHRpcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IGFjdGlvblR5cGVzLkhJREVfVE9PTFRJUFxuXHRcdH07XG5cdH0sXG5cblx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uKHRpdGxlLCBjb250ZW50LCBpY29uR2x5cGgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogYWN0aW9uVHlwZXMuU0VUX1RPT0xUSVBfQ09OVEVOVCxcblx0XHRcdGNvbnRlbnQsXG5cdFx0XHR0aXRsZSxcblx0XHRcdGljb25HbHlwaFxuXHRcdH07XG5cdH1cbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9zdGF0ZS9hY3Rpb25zLmpzIiwidmFyIENvbW11bmljYXRvciA9IGZ1bmN0aW9uKGlkLCBvcmlnaW4sIGNhbGxiYWNrcyA9IHt9KSB7XG5cdGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY2hvb3NlIGEgc3RyaW5nLWJhc2VkIElEIGZvciB0aGUgZ3Vlc3QuJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG9yaWdpbiAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBjaG9vc2UgYSBzdHJpbmctYmFzZWQgb3JpZ2luIGFkZHJlc3MuJyk7XG5cdH1cblxuXHR0aGlzLl9zZXR0aW5ncyA9IHtcblx0XHRuYW1lOiAndGFnLWNvbW0tZGF0YSdcblx0fTtcblxuXHR0aGlzLl9ndWVzdHMgPSB7fTtcblx0dGhpcy5fcXVldWUgPSB7fTtcblx0dGhpcy5pZCA9IGlkO1xuXHR0aGlzLm1lc3NhZ2VfaW5kZXggPSAwO1xuXG5cdHRoaXMuX29yaWdpbiA9IG9yaWdpbjtcblx0dGhpcy5fY2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0bWVzc2FnZTogbnVsbFxuXHR9LCBjYWxsYmFja3MpO1xuXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fcmVjZWl2ZU1lc3NhZ2UuYmluZCh0aGlzKSwgZmFsc2UpO1xuXG5cdHRoaXMuX3NlbmRQaW5nKCk7XG59O1xuXG5Db21tdW5pY2F0b3IucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogQXR0ZW1wdCB0byBwaW5nIHNvdXJjZSB3aW5kb3dcblx0ICovXG5cdF9zZW5kUGluZzogZnVuY3Rpb24obm9kZSkge1xuXHRcdHZhciBwaW5nID0gdGhpcy5fY3JlYXRlTWVzc2FnZShudWxsLCB7XG5cdFx0XHRwaW5nOiB0aGlzLmlkXG5cdFx0fSk7XG5cblx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdGlmICh3aW5kb3cub3BlbmVyKSB7XG5cdFx0XHRcdG5vZGUgPSB3aW5kb3cub3BlbmVyO1xuXHRcdFx0fSBlbHNlIGlmICh3aW5kb3cudG9wICE9PSB3aW5kb3cpIHtcblx0XHRcdFx0bm9kZSA9IHdpbmRvdy50b3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5vZGUpIHtcblx0XHRcdHRoaXMuX3Bvc3Qobm9kZSwgcGluZyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZW5kUG9uZzogZnVuY3Rpb24obm9kZSkge1xuXHRcdHZhciBwb25nID0gdGhpcy5fY3JlYXRlTWVzc2FnZShudWxsLCB7XG5cdFx0XHRwb25nOiB0aGlzLmlkXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9wb3N0KG5vZGUsIHBvbmcpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBzaW5nbGUgZ3Vlc3QgZm9yIGNvbW11bmljYXRpb24gcHVycG9zZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIEd1ZXN0IElELiBVc2VkIHdoZW4gc2VuZGluZyBtZXNzYWdlcy5cblx0ICogQHBhcmFtIHttaXhlZH0gZGVzdCAtIERlc3RpbmF0aW9uIG5vZGUuXG5cdCAqL1xuXHRyZWdpc3Rlckd1ZXN0QWRkcmVzczogZnVuY3Rpb24oaWQsIGRlc3QpIHtcblx0XHRpZiAodHlwZW9mIGRlc3QgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdCdDYW5ub3QgcmVnaXN0ZXIgYWRkcmVzcyBmb3IgJyArIGlkICsgJy4gJyArXG5cdFx0XHRcdCdBIGd1ZXN0IGFkZHJlc3MgRE9NIG5vZGUsIHdpbmRvdyBvciBmcmFtZSBtdXN0IGJlIGRlZmluZWQuJ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoISgncG9zdE1lc3NhZ2UnIGluIGRlc3QpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdCdDb21tdW5pY2F0b3IgY2Fubm90IHNlbmQgbWVzc2FnZXMgdG8gZGVzdGluYXRpb24uIFBsZWFzZSBjaG9vc2UgYW4gSFRNTEVsZW1lbnQgJyArXG5cdFx0XHRcdCd0aGF0IHN1cHBvcnRzIHRoZSBwb3N0TWVzc2FnZSBtZXRob2QnXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBjaG9vc2UgYSBzdHJpbmctYmFzZWQgSUQgZm9yIHRoZSBndWVzdC4nKTtcblx0XHR9XG5cblx0XHQvLyByZWdpc3RlciBsb2NhbCBhZGRyZXNzIGZvciBndWVzdFxuXHRcdHRoaXMuX3NldEd1ZXN0RGF0YShpZCwge1xuXHRcdFx0aWQsXG5cdFx0XHRub2RlOiBkZXN0XG5cdFx0fSk7XG5cblx0XHQvLyBzdGFydCB0aW1lclxuXHRcdGlmICh0aGlzLnRpbWVyKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgb3IgcmVwbGFjZXMgdGhlIGd1ZXN0IGRhdGEuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIEd1ZXN0IElELlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIEd1ZXN0IGRhdGEuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfc2V0R3Vlc3REYXRhOiBmdW5jdGlvbihpZCwgZGF0YSkge1xuXHRcdGlmICghdGhpcy5fZ3Vlc3RzW2lkXSkge1xuXHRcdFx0dGhpcy5fZ3Vlc3RzW2lkXSA9IHtcblx0XHRcdFx0bGl2ZTogZmFsc2UsXG5cdFx0XHRcdG5vZGU6IG51bGxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLl9ndWVzdHNbaWRdLCBkYXRhKTtcblx0fSxcblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRvIC0gR3Vlc3QgSUQsIGFzIHN0b3JlZC5cblx0ICogQHBhcmFtIHttaXhlZH0gbWVzc2FnZSAtIEFueSBKUyBjb21wYXRpYmxlIGRhdGEgdG8gc2VuZCBhcyBhIG1lc3NhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIEFkZCBhIG1lc3NhZ2UgSUQgdG8gYWxsb3cgdGhlIHJlY2lwaWVudCB0byBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucy5cblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgZGVmaW5lZCBndWVzdC5cblx0ICogSWYgbm8gSUQgaXMgZGVmaW5lZCwgb25lIHdpbGwgYmUgZ2VuZXJhdGVkLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgSUQgb2YgdGhlIG1lc3NhZ2UgYXMgZGVmaW5lZCBvciBnZW5lcmF0ZWQuXG5cdCAqL1xuXHRzZW5kOiBmdW5jdGlvbih0bywgbWVzc2FnZSwgaWQgPSBudWxsKSB7XG5cdFx0dmFyIGd1ZXN0ID0gdGhpcy5fZ2V0R3Vlc3RCeUlkKHRvKTtcblxuXHRcdGlkID0gKGlkIHx8IHRoaXMuX2dlbmVyYXRlU2VuZElkKHRvKSk7XG5cblx0XHRpZiAoZ3Vlc3QgJiYgZ3Vlc3QubGl2ZSkge1xuXHRcdFx0Ly8gcG9zdCBtZXNzYWdlIGltbWVkaWF0ZWx5XG5cdFx0XHR0aGlzLl9wb3N0KHRvLCB0aGlzLl9jcmVhdGVNZXNzYWdlKG1lc3NhZ2UsIHt9LCBpZCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBxdWV1ZSBtZXNzYWdlIGZvciBwb3N0aW5nXG5cdFx0XHR0aGlzLl9hZGRUb1F1ZXVlKHRvLCBtZXNzYWdlLCBpZCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGlkO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbWVzc2FnZSB0byB0aGUgbG9jYWwgJ291dGJveCcgZm9yIHRoZSBndWVzdCAoYnkgSUQpLlxuXHQgKi9cblx0X2FkZFRvUXVldWU6IGZ1bmN0aW9uKHRvLCBtZXNzYWdlLCBpZCkge1xuXHRcdGlmICghdGhpcy5fcXVldWVbdG9dKSB7XG5cdFx0XHR0aGlzLl9xdWV1ZVt0b10gPSBbXTtcblx0XHR9XG5cblx0XHR0aGlzLl9xdWV1ZVt0b10ucHVzaCh7XG5cdFx0XHRtZXNzYWdlLFxuXHRcdFx0aWRcblx0XHR9KTtcblx0fSxcblxuXHRfc2VuZFF1ZXVlOiBmdW5jdGlvbih0bykge1xuXHRcdHZhciBhO1xuXG5cdFx0aWYgKHRoaXMuX3F1ZXVlW3RvXSAmJiB0aGlzLl9ndWVzdHNbdG9dKSB7XG5cdFx0XHQvLyBzZW5kIG1lc3NhZ2VzIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgcXVldWVkXG5cdFx0XHRmb3IgKGEgPSAwOyBhIDwgdGhpcy5fcXVldWVbdG9dLmxlbmd0aDsgYSArPSAxKSB7XG5cdFx0XHRcdHRoaXMuX3Bvc3QoXG5cdFx0XHRcdFx0dGhpcy5fZ3Vlc3RzW3RvXS5ub2RlLFxuXHRcdFx0XHRcdHRoaXMuX2NyZWF0ZU1lc3NhZ2UoXG5cdFx0XHRcdFx0XHR0aGlzLl9xdWV1ZVt0b11bYV0ubWVzc2FnZSxcblx0XHRcdFx0XHRcdHt9LFxuXHRcdFx0XHRcdFx0dGhpcy5fcXVldWVbdG9dW2FdLmlkXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjbGVhciBxdWV1ZSBmb3IgdGhpcyByZWNpcGllbnRcblx0XHRcdHRoaXMuX3F1ZXVlW3RvXSA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogR2V0cyBhIGNvbW11bmljYXRvciBndWVzdCBieSBpdHMgSUQsIG9yIHJldHVybnMgYG51bGxgLlxuXHQgKiBAcmV0dXJucyB7bWl4ZWR9IEd1ZXN0IGRhdGEsIG9yIGBudWxsYC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRHdWVzdEJ5SWQ6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2d1ZXN0c1tpZF0gfHwgbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGEgZ3Vlc3QgYnkga25vd24gbm9kZSAoaS5lLiB0aGF0IHJlZ2lzdGVyZWQgaW4gYHRoaXMuX2d1ZXN0c2ApXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0R3Vlc3RCeU5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHR2YXIgaWQ7XG5cblx0XHRmb3IgKGlkIGluIHRoaXMuX2d1ZXN0cykge1xuXHRcdFx0aWYgKHRoaXMuX2d1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpZCkgJiZcblx0XHRcdFx0dGhpcy5fZ3Vlc3RzW2lkXS5ub2RlID09PSBub2RlKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9nZXRHdWVzdEJ5SWQoaWQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBY3R1YWxseSBwb3N0cyB0aGUgbWVzc2FnZSB0byB0aGUgZGVzdGluYXRpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0byAtIEd1ZXN0IElELlxuXHQgKiBAcGFyYW0ge21peGVkfSBtZXNzYWdlIC0gQW55IEpTIGNvbXBhdGlibGUgZGF0YSB0byBzZW5kIGFzIGEgbWVzc2FnZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9wb3N0OiBmdW5jdGlvbih0bywgbWVzc2FnZSkge1xuXHRcdHZhciBndWVzdCwgbm9kZTtcblxuXHRcdGlmICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRndWVzdCA9IHRoaXMuX2dldEd1ZXN0QnlJZCh0byk7XG5cblx0XHRcdGlmICghZ3Vlc3Qubm9kZSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J0Nhbm5vdCBjb21tdW5pY2F0ZSB3aXRoIGd1ZXN0IFwiJyArIHRvICsgJ1wiLiBIYXMgaXRzIE5vZGUgYWRkcmVzcyBiZWVuIHJlZ2lzdGVyZWQ/J1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRub2RlID0gZ3Vlc3Qubm9kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9kZSA9IHRvO1xuXHRcdH1cblxuXHRcdG5vZGUucG9zdE1lc3NhZ2UobWVzc2FnZSwgdGhpcy5fb3JpZ2luKTtcblx0fSxcblxuXHQvKipcblx0ICogSW52b2tlZCB3aGVuIGEgbGl2ZSBtZXNzYWdlIGlzIHJlY2VpdmVkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3JlY2VpdmVNZXNzYWdlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBvcmlnaW4gPSBldmVudC5vcmlnaW4gfHwgZXZlbnQub3JpZ2luYWxFdmVudC5vcmlnaW4sXG5cdFx0XHRzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwgZXZlbnQub3JpZ2luYWxFdmVudC5zb3VyY2UsXG5cdFx0XHRtZXNzYWdlID0gZXZlbnQuZGF0YSxcblx0XHRcdGd1ZXN0O1xuXG5cdFx0aWYgKG9yaWdpbiAhPT0gbG9jYXRpb24ub3JpZ2luKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0aWYgKChtZXNzYWdlLnBpbmcgfHwgbWVzc2FnZS5wb25nKSAmJiB0aGlzLl9nZXRHdWVzdEJ5Tm9kZShzb3VyY2UpKSB7XG5cdFx0XHQvLyByZWNlaXZlZCBhIHBpbmcvcG9uZyBmcm9tIHZhbGlkIHNvdXJjZVxuXHRcdFx0Z3Vlc3QgPSBtZXNzYWdlLnBpbmcgfHwgbWVzc2FnZS5wb25nO1xuXG5cdFx0XHR0aGlzLl9zZXRHdWVzdExpdmUoZ3Vlc3QpO1xuXHRcdFx0dGhpcy5fc2VuZFF1ZXVlKGd1ZXN0KTtcblxuXHRcdFx0aWYgKG1lc3NhZ2UucGluZykge1xuXHRcdFx0XHQvLyBwb25nIGJhY2sgYSBwaW5nIChkb24ndCBwb25nIGEgcG9uZyBvciB3ZSdsbCBiZSBoZXJlIGZvcmV2ZXIpXG5cdFx0XHRcdHRoaXMuX3NlbmRQb25nKHNvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2NhbGxiYWNrcy5tZXNzYWdlICYmIG1lc3NhZ2Uub3JpZ2luYWxNZXNzYWdlKSB7XG5cdFx0XHR0aGlzLl9jYWxsYmFja3MubWVzc2FnZShcblx0XHRcdFx0bWVzc2FnZS5vcmlnaW5hbE1lc3NhZ2UsXG5cdFx0XHRcdG1lc3NhZ2UuaWRcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRHdWVzdExpdmU6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0dGhpcy5fc2V0R3Vlc3REYXRhKGlkLCB7XG5cdFx0XHRsaXZlOiB0cnVlXG5cdFx0fSk7XG5cdH0sXG5cblx0X2NyZWF0ZU1lc3NhZ2U6IGZ1bmN0aW9uKG1lc3NhZ2UsIGRhdGEsIGlkKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcblx0XHRcdGhvc3Q6IHRoaXMuaWQsXG5cdFx0XHRpZDogaWQsXG5cdFx0XHRvcmlnaW5hbE1lc3NhZ2U6IG1lc3NhZ2Vcblx0XHR9KTtcblx0fSxcblxuXHRfZ2VuZXJhdGVTZW5kSWQ6IGZ1bmN0aW9uKHByZWZpeCkge1xuXHRcdGlmICh3aW5kb3cucGVyZm9ybWFuY2UgJiYgKCdub3cnIGluIHdpbmRvdy5wZXJmb3JtYW5jZSkpIHtcblx0XHRcdHJldHVybiBwcmVmaXggKyAnLXh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuXHRcdFx0XHR2YXIgciA9ICh3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuXHRcdFx0XHRyZXR1cm4gKGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCkpLnRvU3RyaW5nKDE2KTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gcHJlZml4ICsgJy0nICsgKHRoaXMubWVzc2FnZV9pbmRleCsrKTtcblx0XHR9XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbW11bmljYXRvcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2xpYi9Db21tdW5pY2F0b3IuanMiLCJpbXBvcnQgeyB1aVN0YXRlcywgZGlhbG9nTW9kZXMgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5cbi8vIGRlZmF1bHQgc3RhdGUgZm9yLi4uXG5leHBvcnQgZGVmYXVsdCB7XG5cdC8vIGdlbmVyYWwgYXBwbGljYXRpb25cblx0YXBwOiB7XG5cdFx0dWlfc3RhdGU6IHVpU3RhdGVzLklOSVRJQUxJU0lORyxcblx0XHRhY3RpdmU6IGZhbHNlLFxuXHRcdGZpcnN0X3ZhbGlkX2Ryb3A6IGZhbHNlLFxuXHRcdGxhc3RfdmFsaWRfZHJvcDogZmFsc2Vcblx0fSxcblxuXHQvLyBhY3RpdmUgem9uZXMgYW5kIGN1cnJlbnQgYXR0YWNobWVudHNcblx0em9uZXM6IHt9LFxuXG5cdC8vIFVJIHN0YXRlcyAtIGRvIG5vdCBwZXJzaXN0XG5cdFVJOiB7XG5cdFx0Ly8gdGhlIGN1cnJlbnRseSBhY3RpdmUgZGlhbG9nIGFuZCBpdHMgZGF0YVxuXHRcdGRpYWxvZzoge1xuXHRcdFx0bW9kZTogZGlhbG9nTW9kZXMuTk9ORSxcblx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRvbkRpYWxvZ0NvbXBsZXRlOiBudWxsLFxuXHRcdFx0b25EaWFsb2dDYW5jZWw6IG51bGwsXG5cdFx0XHRvdmVybGF5OiB0cnVlLFxuXHRcdFx0YXR0YWNobWVudDogbnVsbCxcblx0XHRcdGlkOiAnJ1xuXHRcdH0sXG5cblx0XHQvLyB0aGUgY3VycmVudGx5IGFjdGl2ZSBkcm9wbGV0IChpLmUuIHRoZSBvbmUgdGhhdCB3aWxsIGJlIFwiZHJvcHBlZFwiIHdoZW4gYVxuXHRcdC8vIGRyb3Agem9uZSBpcyBuZXh0IGNsaWNrZWQpXG5cdFx0YWN0aXZlX2Ryb3BsZXRfaWQ6ICcnLFxuXG5cdFx0Ly8gc3RhZ2UgdGhlIHRvdXIgaXMgYXQgKGZyb20gMSAtIGRpYWxvZ3MudG91ci5sZW5ndGgpXG5cdFx0dG91cl9zdGFnZTogbnVsbCxcblxuXHRcdHRvb2x0aXA6IHtcblx0XHRcdHNob3c6IGZhbHNlLFxuXHRcdFx0YXR0YWNobWVudDogbnVsbCxcblx0XHRcdG9wdGlvbnM6IG51bGwsXG5cdFx0XHR0aXRsZTogJycsXG5cdFx0XHRpY29uR2x5cGg6ICcnLFxuXHRcdFx0Y29udGVudDogJydcblx0XHR9XG5cdH1cbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9hc3NldHMvZGVmYXVsdC1zdGF0ZS5qcyIsImNvbnN0IHRvdXJEaWFsb2dNb2RpZmllcnMgPSB7XG5cdGFycm93OiB7XG5cdFx0ZWxlbWVudDogJy5hcnJvdydcblx0fVxufTtcblxuY29uc3QgdG91ckJ1dHRvbnMgPSB7XG5cdHByb2NlZWQ6IFt7XG5cdFx0dHlwZTogJ2NhbmNlbCcsXG5cdFx0bGFiZWw6ICdDbG9zZSdcblx0fSwge1xuXHRcdHR5cGU6ICdzdWJtaXQnLFxuXHRcdGxhYmVsOiAnQ29udGludWUnXG5cdH1dLFxuXHR0cnlfaXQ6IFt7XG5cdFx0dHlwZTogJ2NhbmNlbCcsXG5cdFx0bGFiZWw6ICdDbG9zZSdcblx0fSwge1xuXHRcdHR5cGU6ICdwYXVzZScsXG5cdFx0bGFiZWw6ICdUcnkgaXQgb3V0J1xuXHR9LCB7XG5cdFx0dHlwZTogJ3N1Ym1pdCcsXG5cdFx0bGFiZWw6ICdDb250aW51ZSdcblx0fV0sXG5cdGVuZDogW3tcblx0XHR0eXBlOiAnc3VibWl0Jyxcblx0XHRsYWJlbDogJ0ZpbmlzaCB0b3VyJ1xuXHR9XVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlRGlhbG9ncyhzZXR0aW5ncykge1xuXHRyZXR1cm4ge1xuXHRcdGludHJvOiB7XG5cdFx0XHR0aXRsZTogJ1dlbGNvbWUgdG8gPHNwYW4gY2xhc3M9XCJsb2dvXCI+Jmx0OzxiPlRhZzwvYj4mZ3Q7PC9zcGFuPiEnLFxuXHRcdFx0bWVzc2FnZTogW1xuXHRcdFx0XHQnVGFnIGlzIGFuIGFwcCBkZXNpZ25lZCB0byBleHBsYWluIGhvdyB3ZWIgcGFnZXMgYXJlIGNvbnN0cnVjdGVkLicsXG5cdFx0XHRcdCdJZiB5b3UgYXJlIG5ldyB0byB0YWcsIHlvdSBjYW4gdXNlIHRoZSBUb3VyIGJ1dHRvbiBpbiB0aGUgdG9vbGJhci4nLFxuXHRcdFx0XHQnT3RoZXJ3aXNlLCBqdXN0IGNsaWNrIOKAnE9L4oCdIGFuZCBnZXQgY3JlYXRpbmchJ1xuXHRcdFx0XVxuXHRcdH0sXG5cdFx0cmVzZXRTdGF0ZToge1xuXHRcdFx0dGl0bGU6ICdSZXNldCBUYWcnLFxuXHRcdFx0bWVzc2FnZTogW1xuXHRcdFx0XHQnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGdvIGJhY2sgdG8gdGhlIGJlZ2lubmluZz8nLFxuXHRcdFx0XHQnQWxsIG9mIHlvdXIgY3VycmVudCB3b3JrIHdpbGwgYmUgY2xlYXJlZC4nXG5cdFx0XHRdLFxuXHRcdFx0YnV0dG9uczogW3tcblx0XHRcdFx0dHlwZTogJ2NhbmNlbCcsXG5cdFx0XHRcdGxhYmVsOiAnQ2FuY2VsJ1xuXHRcdFx0fSwge1xuXHRcdFx0XHR0eXBlOiAnc3VibWl0Jyxcblx0XHRcdFx0Y2xhc3NOYW1lOiAnZGFuZ2VyJyxcblx0XHRcdFx0bGFiZWw6ICdDbGVhciBteSB3b3JrJ1xuXHRcdFx0fV1cblx0XHR9LFxuXHRcdGRyb3BsZXRCYWRQbGFjZW1lbnQ6IHtcblx0XHRcdHRpdGxlOiAnT29wcyEnLFxuXHRcdFx0bWVzc2FnZTogW1xuXHRcdFx0XHQnQWxtb3N0IHRoZXJlLCBidXQgdGhlIERyb3BsZXQgeW914oCZdmUgY2hvc2VuIGRvZXNu4oCZdCBnbyBoZXJlLicsXG5cdFx0XHRcdCdUcnkgYWdhaW4gYW5kIHNlZSBpZiB5b3UgY2FuIGZpbmQgdGhlIGNvcnJlY3QgcGxhY2UuJyxcblx0XHRcdFx0J1JlbWVtYmVyLCB0aGUgdGFyZ2V0IHdpbGwgYmUgPHNwYW4gY2xhc3M9XCJkcm9wLXpvbmUgYWNjZXB0XCI+PHNwYW4gY2xhc3M9XCJ0YXJnZXRcIj48Yj5ncmVlbjwvYj48L3NwYW4+PC9zcGFuPiB3aGVuIHlvdSBjYW4gcGxhY2UgdGhlIERyb3BsZXQuJ1xuXHRcdFx0XVxuXHRcdH0sXG5cdFx0Zmlyc3REcm9wbGV0RHJvcDogZnVuY3Rpb24oZHJvcGxldF9vdXRwdXQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRpdGxlOiAnV2VsbCBkb25lIScsXG5cdFx0XHRcdG1lc3NhZ2U6IFtcblx0XHRcdFx0XHQnPGNvZGU+JyArIGRyb3BsZXRfb3V0cHV0ICsgJzwvY29kZT4nLFxuXHRcdFx0XHRcdCdZb3XigJl2ZSBwbGFjZWQgeW91ciA8Yj52ZXJ5IGZpcnN0PC9iPiBEcm9wbGV0IG9udG8gdGhlIFRlbXBsYXRlLiBIdXJyYWghJyxcblx0XHRcdFx0XHQnUHJlc3MgdGhlIDxzcGFuIGNsYXNzPVwicHNldWRvLWJ1dHRvbiBydW5cIj48c3ZnIGNsYXNzPVwiaWNvblwiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiPjx1c2UgeGxpbms6aHJlZj1cIiNpY29uLW1lZGlhLXBsYXlcIj48L3VzZT48L3N2Zz5SdW48L3NwYW4+IGJ1dHRvbiB0byBzZWUgaG93IGl0IGxvb2tzLidcblx0XHRcdFx0XVxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGxhc3REcm9wbGV0RHJvcDoge1xuXHRcdFx0dGl0bGU6ICdXZWxsIGRvbmUhJyxcblx0XHRcdG1lc3NhZ2U6IFtcblx0XHRcdFx0J1lvdeKAmXZlIHBsYWNlZCBhdCA8Yj5sZWFzdCBvbmUgRHJvcGxldDwvYj4gb24gZXZlcnkgdGFyZ2V0IGluIHRoZSB0ZW1wbGF0ZS4gWWlwcGVlIScsXG5cdFx0XHRcdCdXaHkgbm90IHRyeSB0aGUgPHNwYW4gY2xhc3M9XCJwc2V1ZG8tYnV0dG9uIHJ1blwiPjxzdmcgY2xhc3M9XCJpY29uXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCI+PHVzZSB4bGluazpocmVmPVwiI2ljb24tbWVkaWEtcGxheVwiPjwvdXNlPjwvc3ZnPlJ1bjwvc3Bhbj4gYnV0dG9uIHRvIHNlZSBob3cgaXQgbG9va3M/J1xuXHRcdFx0XVxuXHRcdH0sXG5cdFx0dG91cjogW3tcblx0XHRcdHRpdGxlOiAnV2VsY29tZSB0byA8c3BhbiBjbGFzcz1cImxvZ29cIj4mbHQ7PGI+VGFnPC9iPiZndDs8L3NwYW4+IScsXG5cdFx0XHRtZXNzYWdlOiBbXG5cdFx0XHRcdCdUYWcgaXMgYW4gYXBwIGRlc2lnbmVkIHRvIGV4cGxhaW4gaG93IHdlYiBwYWdlcyBhcmUgY29uc3RydWN0ZWQuJyxcblx0XHRcdFx0J1RoZSBpZGVhIGlzIHNpbXBsZTogUGxhY2UgPGI+ZWxlbWVudHM8L2I+IG9udG8gdGhlIDxiPnRlbXBsYXRlPC9iPiwgYW5kIHRoZW4gdXNlIHRoZSAnICtcblx0XHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJwc2V1ZG8tYnV0dG9uIHJ1blwiPjxzdmcgY2xhc3M9XCJpY29uXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCI+PHVzZSB4bGluazpocmVmPVwiI2ljb24tbWVkaWEtcGxheVwiPjwvdXNlPjwvc3ZnPlJ1bjwvc3Bhbj4gYnV0dG9uIHRvIHNlZSBob3cgdGhlIHBhZ2Ugd2lsbCBsb29rIGluIHRoZSA8Yj52aWV3PC9iPi4nLFxuXHRcdFx0XHQnU29tZSBwYXJ0cyBvZiB0aGUgdG91ciB3aWxsIGxldCB5b3UgdHJ5IHRoaW5ncyBvdXQgYmVmb3JlIG1vdmluZyBvbi4gSWYgeW91IHdhbnQgdG8sIHVzZSB0aGUgPHNwYW4gY2xhc3M9XCJwc2V1ZG8tYnV0dG9uXCI+VHJ5IGl0IG91dDwvc3Bhbj4gYnV0dG9uIHdoZW4geW91IHNlZSBpdCwgdGhlbiB1c2UgPHNwYW4gY2xhc3M9XCJwc2V1ZG8tYnV0dG9uXCI+PHN2ZyBjbGFzcz1cImljb25cIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIj48dXNlIHhsaW5rOmhyZWY9XCIjaWNvbi1jb21wYXNzXCI+PC91c2U+PC9zdmc+Q29udGludWUgdG91cjwvc3Bhbj4gdG8gZ28gYmFjayB0byB0aGUgdG91ci4nXG5cdFx0XHRdLFxuXHRcdFx0YnV0dG9uczogdG91ckJ1dHRvbnMucHJvY2VlZFxuXHRcdH0sIHtcblx0XHRcdHRpdGxlOiAnVGhlIHRlbXBsYXRlJyxcblx0XHRcdG1lc3NhZ2U6IFtcblx0XHRcdFx0J1RoaXMgaXMgdGhlIHRlbXBsYXRlLiBJdCBjb250YWlucyB0aGUgc291cmNlIGNvZGUgZm9yIHlvdXIgd2ViIHBhZ2UsIGFuZCBpcyB3aGVyZSB5b3XigJlsbCBhZGQgc25pcHBldHMgb2YgY29kZS4nLFxuXHRcdFx0XHQnQWRkIGVsZW1lbnRzIHRvIHRoZSA8c3BhbiBjbGFzcz1cImRyb3Atem9uZVwiPjxzcGFuIGNsYXNzPVwidGFyZ2V0XCI+PGI+JyArXG5cdFx0XHRcdFx0c2V0dGluZ3MuZHJvcFpvbmUubGFiZWwgK1xuXHRcdFx0XHRcdCc8L2I+PC9zcGFuPjwvc3Bhbj4gdGFyZ2V0cyB0byBjb25zdHJ1Y3QgdGhlIHBhZ2UuJ1xuXHRcdFx0XSxcblx0XHRcdG92ZXJsYXk6IGZhbHNlLFxuXHRcdFx0YXR0YWNobWVudDoge1xuXHRcdFx0XHRzZWxlY3RvcjogJy5tYWluID4gLnRlbXBsYXRlJyxcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdHBsYWNlbWVudDogJ3JpZ2h0Jyxcblx0XHRcdFx0XHRtb2RpZmllcnM6IHRvdXJEaWFsb2dNb2RpZmllcnNcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGJ1dHRvbnM6IHRvdXJCdXR0b25zLnByb2NlZWRcblx0XHR9LCB7XG5cdFx0XHR0aXRsZTogJ1RoZSBwYWxsZXQnLFxuXHRcdFx0bWVzc2FnZTogW1xuXHRcdFx0XHQnVGhpcyBpcyB0aGUgcGFsbGV0LiBJdCBjb250YWlucyBEcm9wbGV0cywgd2hpY2ggY2FuIGJlIGFkZGVkIHRvIHRoZSB0ZW1wbGF0ZSBhYm92ZS4nXG5cdFx0XHRdLFxuXHRcdFx0b3ZlcmxheTogZmFsc2UsXG5cdFx0XHRhdHRhY2htZW50OiB7XG5cdFx0XHRcdHNlbGVjdG9yOiAnc2VjdGlvbi5wYWxsZXQnLFxuXHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0cGxhY2VtZW50OiAndG9wJyxcblx0XHRcdFx0XHRtb2RpZmllcnM6IHRvdXJEaWFsb2dNb2RpZmllcnNcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGJ1dHRvbnM6IHRvdXJCdXR0b25zLnByb2NlZWRcblx0XHR9LCB7XG5cdFx0XHR0aXRsZTogJ0Ryb3BsZXQnLFxuXHRcdFx0bWVzc2FnZTogW1xuXHRcdFx0XHQnVGhpcyBpcyBhIERyb3BsZXQuIEl0IGNhbiBiZSBhZGRlZCB0byB0aGUgdGVtcGxhdGUgYWJvdmUuJyxcblx0XHRcdFx0J0NlcnRhaW4gPHNwYW4gY2xhc3M9XCJkcm9wLXpvbmVcIj48c3BhbiBjbGFzcz1cInRhcmdldFwiPjxiPicgK1xuXHRcdFx0XHRcdHNldHRpbmdzLmRyb3Bab25lLmxhYmVsICtcblx0XHRcdFx0XHQnPC9iPjwvc3Bhbj48L3NwYW4+IHRhcmdldHMgb25seSBhbGxvdyBjZXJ0YWluIERyb3BsZXRzIHRvIGJlIGFkZGVkIHRvIHRoZW0uJyxcblx0XHRcdFx0J1doZW4gYSB0YXJnZXQgZ29lcyBncmVlbiA8c3BhbiBjbGFzcz1cImRyb3Atem9uZSBhY2NlcHRcIj48c3BhbiBjbGFzcz1cInRhcmdldFwiPjxiPicgK1xuXHRcdFx0XHRcdHNldHRpbmdzLmRyb3Bab25lLmxhYmVsICtcblx0XHRcdFx0XHQnPC9iPjwvc3Bhbj48L3NwYW4+LCBpdCBtZWFucyBpdCBjYW4gYWNjZXB0IHRoZSBEcm9wbGV0IHlvdSBoYXZlIGNob3Nlbiwgb3IgPHNwYW4gY2xhc3M9XCJkcm9wLXpvbmUgZGVjbGluZVwiPjxzcGFuIGNsYXNzPVwidGFyZ2V0XCI+PGI+JyArXG5cdFx0XHRcdFx0XHRzZXR0aW5ncy5kcm9wWm9uZS5sYWJlbCArXG5cdFx0XHRcdFx0XHQnPC9iPjwvc3Bhbj48L3NwYW4+IGlmIHRoZSBEcm9wbGV0IGNhbuKAmXQgYmUgcGxhY2VkIHRoZXJlLicsXG5cdFx0XHRcdCdDbGljayBvbiBhIERyb3BsZXQgYW5kIHRoZW4gY2xpY2sgb24gb25lIG9mIHRoZSA8c3BhbiBjbGFzcz1cImRyb3Atem9uZVwiPjxzcGFuIGNsYXNzPVwidGFyZ2V0XCI+PGI+JyArXG5cdFx0XHRcdFx0c2V0dGluZ3MuZHJvcFpvbmUubGFiZWwgK1xuXHRcdFx0XHRcdCc8L2I+PC9zcGFuPjwvc3Bhbj4gdGFyZ2V0cyBpbiB0aGUgdGVtcGxhdGUgdG8gYXR0YWNoIGl0Lidcblx0XHRcdF0sXG5cdFx0XHRvdmVybGF5OiBmYWxzZSxcblx0XHRcdGF0dGFjaG1lbnQ6IHtcblx0XHRcdFx0c2VsZWN0b3I6ICdzZWN0aW9uLnBhbGxldCAuZHJvcGxldDpmaXJzdC1jaGlsZCcsXG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRwbGFjZW1lbnQ6ICd0b3AnLFxuXHRcdFx0XHRcdG1vZGlmaWVyczogdG91ckRpYWxvZ01vZGlmaWVyc1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YnV0dG9uczogdG91ckJ1dHRvbnMudHJ5X2l0XG5cdFx0fSwge1xuXHRcdFx0dGl0bGU6ICdUaGUgdmlldycsXG5cdFx0XHRtZXNzYWdlOiBbXG5cdFx0XHRcdCdUaGlzIGlzIHRoZSB2aWV3LiBJdCB3aWxsIHNob3cgeW91IGhvdyB0aGUgcGFnZSBsb29rcyBhZnRlciBydW5uaW5nIHRoZSBjb2RlIScsXG5cdFx0XHRcdCdVc2UgdGhlIDxzcGFuIGNsYXNzPVwicHNldWRvLWJ1dHRvbiBydW5cIj48c3ZnIGNsYXNzPVwiaWNvblwiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiPjx1c2UgeGxpbms6aHJlZj1cIiNpY29uLW1lZGlhLXBsYXlcIj48L3VzZT48L3N2Zz5SdW48L3NwYW4+IGJ1dHRvbiB0byB1cGRhdGUgdGhlIHZpZXcnXG5cdFx0XHRdLFxuXHRcdFx0b3ZlcmxheTogZmFsc2UsXG5cdFx0XHRhdHRhY2htZW50OiB7XG5cdFx0XHRcdHNlbGVjdG9yOiAnc2VjdGlvbi52aWV3Jyxcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdHBsYWNlbWVudDogJ2xlZnQnLFxuXHRcdFx0XHRcdG1vZGlmaWVyczogdG91ckRpYWxvZ01vZGlmaWVyc1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YnV0dG9uczogdG91ckJ1dHRvbnMudHJ5X2l0XG5cdFx0fSwge1xuXHRcdFx0dGl0bGU6ICdBbGwgZG9uZSEnLFxuXHRcdFx0bWVzc2FnZTogW1xuXHRcdFx0XHQnT25jZSB5b3XigJl2ZSB1c2VkIHRoZSA8c3BhbiBjbGFzcz1cInBzZXVkby1idXR0b24gcnVuXCI+PHN2ZyBjbGFzcz1cImljb25cIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIj48dXNlIHhsaW5rOmhyZWY9XCIjaWNvbi1tZWRpYS1wbGF5XCI+PC91c2U+PC9zdmc+UnVuPC9zcGFuPiBidXR0b24sIHRoZSB2aWV3IGhhcyB1cGRhdGVkIGFuZCB5b3VyIGxhc3QgY2hhbmdlIHNob3VsZCBub3cgYmUgc2hvd2luZyBoZXJlISdcblx0XHRcdF0sXG5cdFx0XHRvdmVybGF5OiBmYWxzZSxcblx0XHRcdGF0dGFjaG1lbnQ6IHtcblx0XHRcdFx0c2VsZWN0b3I6ICdzZWN0aW9uLnZpZXcnLFxuXHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0cGxhY2VtZW50OiAnbGVmdCcsXG5cdFx0XHRcdFx0bW9kaWZpZXJzOiB0b3VyRGlhbG9nTW9kaWZpZXJzXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRidXR0b25zOiB0b3VyQnV0dG9ucy5maW5pc2hcblx0XHR9XVxuXHR9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2Fzc2V0cy9kaWFsb2dzLmpzIiwiaW1wb3J0IFJlYWN0LCB7IFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR0xZUEhTLCBJY29uIH0gZnJvbSAnLi4vdmlld3MvSWNvbi5qc3gnO1xuaW1wb3J0IHsgcmF3TWFya3VwIH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcblxudmFyIERpYWxvZ0hlYWRpbmcgPSBmdW5jdGlvbihwcm9wcykge1xuXHR2YXIgbm90ZXMgPSBbXSxcblx0XHRpY29uO1xuXG5cdHByb3BzLm5vdGVzLmZvckVhY2goKG5vdGUsIGluZGV4KSA9PiAobm90ZXMucHVzaChcblx0XHQ8cCBrZXk9eydub3RlLScgKyBpbmRleH1cblx0XHRcdGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXtyYXdNYXJrdXAobm90ZSl9Lz5cblx0KSkpO1xuXG5cdGlmIChwcm9wcy5pY29uR2x5cGgpIHtcblx0XHRpY29uID0gPEljb24gZ2x5cGg9e3Byb3BzLmljb25HbHlwaH0vPjtcblx0fVxuXG5cdHJldHVybiAoXG5cdFx0PGRpdiBjbGFzc05hbWU9e3Byb3BzLmNsYXNzTmFtZX0+XG5cdFx0XHQ8aDI+XG5cdFx0XHRcdHtpY29ufVxuXHRcdFx0XHQ8c3BhbiBkYW5nZXJvdXNseVNldElubmVySFRNTD17cmF3TWFya3VwKHByb3BzLnRpdGxlKX0vPlxuXHRcdFx0PC9oMj5cblx0XHRcdHtub3Rlc31cblx0XHQ8L2Rpdj5cblx0KTtcbn07XG5cbkRpYWxvZ0hlYWRpbmcucHJvcFR5cGVzID0ge1xuXHRpY29uR2x5cGg6IFByb3BUeXBlcy5zdHJpbmcsXG5cdGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuXHR0aXRsZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuXHRub3RlczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZylcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERpYWxvZ0hlYWRpbmc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2RpYWxvZ3MvRGlhbG9nSGVhZGluZy5qc3giLCIvKipcbiAqIEB0eXBlZGVmIEZvcm1PblN1Ym1pdFxuICogQHBhcmFtIHtvYmplY3R9IGZvcm1WYWx1ZXMgLSB0aGUgY3VycmVudCB2YWx1ZXMgb2YgdGhlIGZvcm0gZWxlbWVudHMsIGFzIGFuIG9iamVjdC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIEZvcm1GaWVsZFNldHNcbiAqIEBkZXNjcmlwdGlvblxuICogQW4gYXJyYXkgb2YgZmllbGRzZXRzIOKAlCBlYWNoIGl0ZW0gb2Ygd2hpY2ggY29udGFpbnMgYW4gb2JqZWN0IGRlZmluaW5nIGFcbiAqIHNpbmdsZSBmaWVsZHNldC4gU2VlIHtAbGluayBGb3JtRmllbGRzZXR9LlxuICogQGV4YW1wbGVcbiAqIHZhciBmaWVsZHNldHMgPSBbXG4gKiBcdHtAbGluayBGb3JtRmllbGRTZXR9Li4uXG4gKiBdO1xuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IGRlZmluaW5nIGEgc2luZ2xlIGZpZWxkc2V0LlxuICogQHR5cGVkZWYgRm9ybUZpZWxkU2V0XG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5IC0gVW5pcXVlIGtleSB2YWx1ZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsZWdlbmQgLSBMZWdlbmQgbGFiZWwuXG4gKiBAcHJvcGVydHkge29iamVjdH0gZmllbGRzIC0gRmllbGRzIHdpdGhpbiB0aGUgZmllbGRzZXQuIFRoZSBrZXlzIG9mIHdoaWNoXG4gKiBzaG91bGQgcmVwcmVzZW50IHRoZSBuYW1lIG9mIHRoZSBmaWVsZCwgd2l0aCB0aGUgdmFsdWVzIGJlaW5nIG9uZSBvZlxuICoge0BsaW5rIEZvcm1GaWVsZH0gZWFjaC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmllbGRzZXQgPSBbXG4gKiBcdHtAbGluayBGb3JtRmllbGR9Li4uXG4gKiBdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBGb3JtQnV0dG9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIEVpdGhlciAnY2FuY2VsJywgJ3N1Ym1pdCcgb3IgYSBjdXN0b20gdHlwZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbCAtIEJ1dHRvbiBsYWJlbC5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkYXRhIC0gRGF0YSBzZW50IGFzIGBkYXRhYCB0byB0aGUgZm9ybSBvblN1Ym1pdCBwcm9wLlxuICogQHByb3BlcnR5IHtvYmplY3R9IGNsYXNzTmFtZSAtIEV4dHJhIGNsYXNzIG5hbWUocykgZm9yIHRoZSBidXR0b24uXG4gKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEZpZWxkc2V0IGZyb20gJy4vRmllbGRzZXQuanN4JztcbmltcG9ydCBCdXR0b24gZnJvbSAnLi9CdXR0b24uanN4JztcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRha2VzIGEgZm9ybSBzcGVjaWZpY2F0aW9uIGFuZCBwcm9kdWNlcyBhbiBIVE1MIGZvcm0uXG4gKiBTZWUge0BsaW5rIEZvcm0ucHJvcFR5cGVzfSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICovXG5jbGFzcyBGb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHR2YXIgZm9ybVZhbHVlcyA9IHt9O1xuXG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0dGhpcy51aSA9IHtcblx0XHRcdHJlZnM6IHtcblx0XHRcdFx0YnV0dG9uczoge30sXG5cdFx0XHRcdGZpZWxkczoge31cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc2V0IGRlZmF1bHQgc3RhdGUgZm9yIGZpZWxkcyBiYXNlZCBvbiBvcmlnaW5hbCB2YWx1ZXNcblx0XHRpZiAodGhpcy5wcm9wcy5maWVsZFNldHMpIHtcblx0XHRcdHRoaXMucHJvcHMuZmllbGRTZXRzLmZvckVhY2goKHNldCkgPT4ge1xuXHRcdFx0XHRmb3JtVmFsdWVzW3NldC5rZXldID0ge307XG5cblx0XHRcdFx0c2V0LmZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT5cblx0XHRcdFx0XHQoZm9ybVZhbHVlc1tzZXQua2V5XVtmaWVsZC5uYW1lXSA9IGZpZWxkLnZhbHVlKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IGRlZmF1bHQgZm9ybSB2YWx1ZSBzdGF0ZVxuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRmb3JtVmFsdWVzXG5cdFx0fTtcblxuXHRcdC8vIGJpbmQgZnVuY3Rpb25zIGZvciBldmVudHNcblx0XHR0aGlzLmVsZW1lbnRDaGFuZ2UgPSB0aGlzLmVsZW1lbnRDaGFuZ2UuYmluZCh0aGlzKTtcblx0fVxuXG5cdHZhbHVlU2V0KHZhbHVlcywgbm9kZSkge1xuXHRcdHZhciBub2RlcyA9IFtdLCBrZXk7XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG5cdFx0XHR2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKFxuXHRcdFx0XHRcdDxub2RlIHZhbHVlPXt2YWx1ZX0+e3ZhbHVlfTwvbm9kZT5cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAoa2V5IGluIHZhbHVlcykge1xuXHRcdFx0XHRub2Rlcy5wdXNoKFxuXHRcdFx0XHRcdDxub2RlIHZhbHVlPXtrZXl9Pnt2YWx1ZXNba2V5XX08L25vZGU+XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vZGVzO1xuXHR9XG5cblx0ZmllbGRTZXRzKCkge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblxuXHRcdGlmICh0aGlzLnByb3BzLmZpZWxkU2V0cykge1xuXHRcdFx0dGhpcy5wcm9wcy5maWVsZFNldHMuZm9yRWFjaCgoc2V0KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGtleSA9ICdmaWVsZHNldC0nICsgc2V0LmtleTtcblxuXHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHQ8RmllbGRzZXRcblx0XHRcdFx0XHRcdGtleT17a2V5fVxuXHRcdFx0XHRcdFx0cmVmQ29sbGVjdG9yPXt0aGlzLmNvbGxlY3RGaWVsZFJlZi5iaW5kKHRoaXMpfVxuXHRcdFx0XHRcdFx0c2V0PXtzZXQua2V5fVxuXHRcdFx0XHRcdFx0ZmllbGRzPXtzZXQuZmllbGRzfVxuXHRcdFx0XHRcdFx0bGVnZW5kPXtzZXQubGVnZW5kfVxuXHRcdFx0XHRcdFx0b25GaWVsZFVwZGF0ZT17dGhpcy5lbGVtZW50Q2hhbmdlfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRlbGVtZW50Q2hhbmdlKHNldCwgbmFtZSwgdmFsdWUsIHZhbHVlc19zdGF0ZSkge1xuXHRcdHZhciBzZXRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5mb3JtVmFsdWVzKTtcblxuXHRcdHNldHNbc2V0XSA9IHZhbHVlc19zdGF0ZTtcblxuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0Zm9ybVZhbHVlczogc2V0c1xuXHRcdH0pO1xuXHR9XG5cblx0Y29tcG9uZW50T25TdWJtaXQocHJveHlfZXZlbnQpIHtcblx0XHR0aGlzLm9uU3VibWl0KHByb3h5X2V2ZW50LCAnc3VibWl0Jyk7XG5cdH1cblxuXHRvblN1Ym1pdChldmVudCwgYnV0dG9uLCBidXR0b25fZGF0YSkge1xuXHRcdGlmIChldmVudCkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR0aGlzLnByb3BzLm9uU3VibWl0KHRoaXMuc3RhdGUuZm9ybVZhbHVlcywgYnV0dG9uLCBidXR0b25fZGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGEgZnVuY3Rpb24gdG8gY29sbGVjdCBCdXR0b24gY29tcG9uZW50IERPTSByZWZlcmVuY2VzLlxuXHQgKi9cblx0Y29sbGVjdEJ1dHRvblJlZihrZXkpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24ocmVmKSB7XG5cdFx0XHR0aGlzLnVpLnJlZnMuYnV0dG9uc1trZXldID0gcmVmO1xuXHRcdH0uYmluZCh0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogQ29sbGVjdCBhIHJlZmVyZW5jZSB0byBhIGZpZWxkLiBFYWNoIGZpZWxkIGNvbXBvbmVudCB1c2VzIHR3byBhcmd1bWVudHNcblx0ICogZm9yIHRoZWlyIHJlZkNvbGxlY3RvciBwcm9wICh1bmxpa2UgdGhlIHVzdWFsIG9uZSk6XG5cdCAqIDEuIEFuIGlkZW50aWZ5aW5nIGtleVxuXHQgKiAyLiBUaGUgRE9NIHJlZmVyZW5jZVxuXHQgKi9cblx0Y29sbGVjdEZpZWxkUmVmKGtleSwgcmVmKSB7XG5cdFx0dGhpcy51aS5yZWZzLmZpZWxkc1trZXldID0gcmVmO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0dmFyIGEsIGIsIGtleTtcblxuXHRcdGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcblx0XHRcdC8vIGlmIGl0J3MgYSB0b3VjaCBkZXZpY2UsIGl0J2xsIGxpa2VseSBoYXZlIGFuIG9uLXNjcmVlbiBrZXlib2FyZFxuXHRcdFx0Ly8gd2hpY2ggY291bGQgZ2V0IGluIHRoZSB3YXkgb2YgdGhlIGRpYWxvZyBvcGVuaW5nIGFuZCBjYXVzZSBVWCBpc3N1ZXMuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gaGFuZGxlIGZvY3VzaW5nIG9mIHRoZSBmaXJzdCBmaWVsZCAob3IgYnV0dG9uKSBpbiB0aGUgZm9ybVxuXHRcdGlmICh0aGlzLnByb3BzLmZpZWxkU2V0cyAmJiB0aGlzLnByb3BzLmZpZWxkU2V0cy5sZW5ndGgpIHtcblx0XHRcdC8vIGhpZ2hsaWdodCBmaXJzdCBjb2xsZWN0ZWQgZmllbGRcblx0XHRcdGZvciAoYSA9IDA7IGEgPCB0aGlzLnByb3BzLmZpZWxkU2V0cy5sZW5ndGg7IGEgKz0gMSkge1xuXHRcdFx0XHRmb3IgKGIgPSAwOyBiIDwgdGhpcy5wcm9wcy5maWVsZFNldHNbYV0uZmllbGRzLmxlbmd0aDsgYiArPSAxKSB7XG5cdFx0XHRcdFx0a2V5ID0gJ2ZpZWxkLScgKyB0aGlzLnByb3BzLmZpZWxkU2V0c1thXS5maWVsZHNbYl0ubmFtZTtcblxuXHRcdFx0XHRcdGlmICh0aGlzLnByb3BzLmZpZWxkU2V0c1thXS5maWVsZHNbYl0udHlwZSAhPT0gJ2hpZGRlbicgJiZcblx0XHRcdFx0XHRcdHRoaXMudWkucmVmcy5maWVsZHNba2V5XSkge1xuXHRcdFx0XHRcdFx0dGhpcy51aS5yZWZzLmZpZWxkc1trZXldLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRhID0gdGhpcy5wcm9wcy5maWVsZFNldHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGhpZ2hsaWdodCBmaXJzdCBjb2xsZWN0ZWQgYnV0dG9uXG5cdFx0XHR0aGlzLnByb3BzLmJ1dHRvbnMuZm9yRWFjaCgoYnV0dG9uLCBpbmRleCkgPT4ge1xuXHRcdFx0XHR2YXIga2V5ID0gJ2J1dHRvbi0nICsgaW5kZXg7XG5cblx0XHRcdFx0aWYgKHRoaXMudWkucmVmcy5idXR0b25zW2tleV0gJiYgYnV0dG9uLnR5cGUgPT09ICdzdWJtaXQnKSB7XG5cdFx0XHRcdFx0dGhpcy51aS5yZWZzLmJ1dHRvbnNba2V5XS5mb2N1cygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIEl0ZXJhdGUgdGhyb3VnaCB0aGUgYGJ1dHRvbnNgIG9iamVjdCBpbiBgcHJvcHNgIGFuZCBwcm9kdWNlIGEgbGlzdCBvZiBCdXR0b25cblx0ICogY29tcG9uZW50cy5cblx0ICovXG5cdGdldEJ1dHRvbnMoKSB7XG5cdFx0dmFyIGJ1dHRvbnMgPSBbXTtcblxuXHRcdGlmICh0aGlzLnByb3BzLmJ1dHRvbnMgJiYgdGhpcy5wcm9wcy5idXR0b25zLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5wcm9wcy5idXR0b25zLmZvckVhY2goKGJ1dHRvbiwgaW5kZXgpID0+IHtcblx0XHRcdFx0dmFyIGtleSA9ICdidXR0b24tJyArIGluZGV4LFxuXHRcdFx0XHRcdGNsaWNrX2Z1bmN0aW9uO1xuXG5cdFx0XHRcdGNsaWNrX2Z1bmN0aW9uID0gKChjb21wb25lbnQsIGtleSkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKGNvbXBvbmVudC51aS5yZWZzLmJ1dHRvbnMgJiYgY29tcG9uZW50LnVpLnJlZnMuYnV0dG9uc1trZXldKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBvbmVudC51aS5yZWZzLmJ1dHRvbnNba2V5XS5ibHVyKCk7XG5cdFx0XHRcdFx0XHRcdGNvbXBvbmVudC5wcm9wcy5vbkJ1dHRvbkNsaWNrKGNvbXBvbmVudC51aS5yZWZzLmJ1dHRvbnNba2V5XSwgZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoYnV0dG9uLnR5cGUgPT09ICdjYW5jZWwnKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGNhbmNlbCBidXR0b25cblx0XHRcdFx0XHRcdFx0Y29tcG9uZW50LnByb3BzLm9uQ2FuY2VsKCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGJ1dHRvbi50eXBlICE9PSAnc3VibWl0Jykge1xuXHRcdFx0XHRcdFx0XHQvLyBhbnl0aGluZyBleGNlcHQgc3VibWl0XG5cdFx0XHRcdFx0XHRcdGNvbXBvbmVudC5vblN1Ym1pdChudWxsLCBidXR0b24udHlwZSwgYnV0dG9uLmRhdGEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pKHRoaXMsIGtleSwgYnV0dG9uLm9uQ2xpY2spO1xuXG5cdFx0XHRcdGJ1dHRvbnMucHVzaChcblx0XHRcdFx0XHQ8QnV0dG9uXG5cdFx0XHRcdFx0XHRrZXk9e2tleX1cblx0XHRcdFx0XHRcdHJlZkNvbGxlY3Rvcj17dGhpcy5jb2xsZWN0QnV0dG9uUmVmKGtleSl9XG5cdFx0XHRcdFx0XHR0eXBlPXtidXR0b24udHlwZX1cblx0XHRcdFx0XHRcdGxhYmVsPXtidXR0b24ubGFiZWx9XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9e2J1dHRvbi5jbGFzc05hbWV9XG5cdFx0XHRcdFx0XHRvbkNsaWNrPXtjbGlja19mdW5jdGlvbn0vPlxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJ1dHRvbnM7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxmb3JtIGFjdGlvbj1cIlwiIG9uU3VibWl0PXt0aGlzLmNvbXBvbmVudE9uU3VibWl0LmJpbmQodGhpcyl9PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZpZWxkc1wiPlxuXHRcdFx0XHRcdHt0aGlzLmZpZWxkU2V0cygpfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGZpZWxkc2V0IGNsYXNzTmFtZT1cImJ1dHRvbnNcIj5cblx0XHRcdFx0XHR7dGhpcy5nZXRCdXR0b25zKCl9XG5cdFx0XHRcdDwvZmllbGRzZXQ+XG5cdFx0XHQ8L2Zvcm0+XG5cdFx0KTtcblx0fVxufVxuXG4vKipcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG9uQ2FuY2VsIC0gaW52b2tlZCB3aGVuIHRoZSBmb3JtIGlzIGNhbmNlbGxlZFxuICogQHByb3BlcnR5IHtGb3JtT25TdWJtaXR9IG9uU3VibWl0IC0gaW52b2tlZCB3aGVuIHRoZSBmb3JtIGlzIHN1Ym1pdHRlZFxuICogQHByb3BlcnR5IHtGb3JtRmllbGRTZXRzfSBmaWVsZFNldHMgLSBmaWVsZHNldHMgZm9yIGRpc3BsYXlcbiAqL1xuRm9ybS5wcm9wVHlwZXMgPSB7XG5cdG9uQnV0dG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdG9uQ2FuY2VsOiBQcm9wVHlwZXMuZnVuYyxcblx0b25TdWJtaXQ6IFByb3BUeXBlcy5mdW5jLFxuXHRmaWVsZFNldHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zaGFwZSh7XG5cdFx0a2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRcdGxlZ2VuZDogUHJvcFR5cGVzLnN0cmluZyxcblx0XHRmaWVsZHM6IFByb3BUeXBlcy5hcnJheVxuXHR9KSksXG5cdGJ1dHRvbnM6IFByb3BUeXBlcy5hcnJheVxufTtcblxuRm9ybS5kZWZhdWx0UHJvcHMgPSB7XG5cdG9uQ2FuY2VsOiAoKSA9PiB7fSxcblx0b25TdWJtaXQ6ICgpID0+IHt9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9Gb3JtLmpzeCIsImltcG9ydCB7IGNoZWNrU3RvcmFnZSB9IGZyb20gJy4vdXRpbHMnO1xuXG52YXIgSlNPTiA9IEpTT04gfHwgd2luZG93LkpTT047XG52YXIgc3RvcmUgPSB3aW5kb3cubG9jYWxTdG9yYWdlIHx8IHdpbmRvdy5zZXNzaW9uU3RvcmFnZTtcblxudmFyIFN0b3JhZ2UgPSBmdW5jdGlvbihwcmVmaXgpIHtcblx0dGhpcy5wcmVmaXggPSBwcmVmaXggKyAnXyc7XG5cdHRoaXMuc3RvcmFnZUVuYWJsZWQgPSBjaGVja1N0b3JhZ2UoJ2xvY2FsU3RvcmFnZScpO1xufTtcblxuU3RvcmFnZS5wcm90b3R5cGUgPSB7XG5cdGdldDogZnVuY3Rpb24oa2V5LCBkZWZhdWx0X3ZhbHVlKSB7XG5cdFx0dmFyIHZhbHVlO1xuXG5cdFx0aWYgKHRoaXMuc3RvcmFnZUVuYWJsZWQgJiZcblx0XHRcdCh2YWx1ZSA9IHN0b3JlLmdldEl0ZW0odGhpcy5wcmVmaXggKyBrZXkpKSAhPT0gbnVsbCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHJldHVybiBkZWZhdWx0X3ZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBkZWZhdWx0X3ZhbHVlO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdGlmICh0aGlzLnN0b3JhZ2VFbmFibGVkKSB7XG5cdFx0XHRzdG9yZS5zZXRJdGVtKHRoaXMucHJlZml4ICsga2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuXHRcdH1cblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2xpYi9TdG9yYWdlLmpzIiwiaW1wb3J0IHByb21pc2UgZnJvbSAncHJvbWlzZSc7XG5pbXBvcnQgc3VwZXJhZ2VudCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCBzdXBlcmFnZW50X3Byb21pc2UgZnJvbSAnc3VwZXJhZ2VudC1wcm9taXNlJztcblxuZXhwb3J0IGRlZmF1bHQgc3VwZXJhZ2VudF9wcm9taXNlKHN1cGVyYWdlbnQsIHByb21pc2UpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvbGliL2FqYXguanMiLCIvKipcbiAqIFRoZSBidWlsdCBpbiBIVE1MRWxlbWVudCB0eXBlLiBVc2VkIHRvIGRlZmluZSBET00gY29tcGF0aWJsZSBub2RlcyBvZiBFbGVtZW50IHR5cGUuXG4gKiBAdHlwZWRlZiBIVE1MRWxlbWVudFxuICovXG5cbi8qKlxuICogUmVhY3QncyBpbnRlcm5hbCBzaW11bGF0ZWQgZXZlbnQgdHlwZS4gRXhwb3NlcyBmdXJ0aGVyIHByb3BlcnRpZXMgZm9yIGVhc2Ugb2YgZGV2ZWxvcG1lbnQuXG4gKiBAdHlwZWRlZiBSZWFjdEV2ZW50XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRGlhbG9nUHJvbWlzZVxuICogQHBhcmFtIHtEaWFsb2dEYXRhfSBkaWFsb2cgLSBEYXRhIGZyb20gdGhlIGRpYWxvZy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIERpYWxvZ0RhdGFcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkYXRhIC0gRGF0YSBmcm9tIGFueSBmb3JtIGVsZW1lbnRzIHdpdGhpbiB0aGUgZGlhbG9nLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFjdGlvbiAtIEFjdGlvbiBzdHJpbmcuICdzdWJtaXQnLCAnY2FuY2VsJyBvciBhIGN1c3RvbSBhY3Rpb24sIGlmIHNldC5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBhY3Rpb25fZGF0YSAtIERhdGEgc3BlY2lmaWMgdG8gdGhlIHNwZWNpYWwgYWN0aW9uLCBpZiBzZXQuXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlU3RvcmUgfSBmcm9tICdyZWR1eCc7XG5cbmltcG9ydCAnLi9saWIvcG9seWZpbGxzJztcbmltcG9ydCAnLi9zdHlsZXMvbWFpbi5zY3NzJztcblxuaW1wb3J0IFVJIGZyb20gJy4vbGliL1VJLmpzeCc7XG5pbXBvcnQgeyBHTFlQSFMgfSBmcm9tICcuL2NvbXBvbmVudHMvdmlld3MvSWNvbi5qc3gnO1xuXG5pbXBvcnQgRHJvcGxldCBmcm9tICcuL2xpYi9Ecm9wbGV0JztcbmltcG9ydCByZXF1ZXN0IGZyb20gJy4vbGliL2FqYXgnO1xuaW1wb3J0IFRlbXBsYXRlIGZyb20gJy4vbGliL1RlbXBsYXRlJztcbmltcG9ydCBTdG9yYWdlIGZyb20gJy4vbGliL1N0b3JhZ2UnO1xuaW1wb3J0IHsgc3RydWN0Q29tcGFyZSB9IGZyb20gJy4vbGliL3V0aWxzJztcblxuaW1wb3J0IGFjdGlvbnMgZnJvbSAnLi9zdGF0ZS9hY3Rpb25zJztcbmltcG9ydCByZWR1Y2VycyBmcm9tICcuL3N0YXRlL3JlZHVjZXJzJztcblxuaW1wb3J0IGFwcERlZmF1bHRzIGZyb20gJy4vYXNzZXRzL2RlZmF1bHRzJztcbmltcG9ydCBkZWZhdWx0U3RhdGUgZnJvbSAnLi9hc3NldHMvZGVmYXVsdC1zdGF0ZSc7XG5pbXBvcnQgY3JlYXRlRGlhbG9ncyBmcm9tICcuL2Fzc2V0cy9kaWFsb2dzJztcbmltcG9ydCB7IGRpYWxvZ01vZGVzLCB1aVN0YXRlcywgYWN0aW9uVHlwZXMsIG1lc3NhZ2VDb21tYW5kcyB9IGZyb20gJy4vYXNzZXRzL2NvbnN0YW50cyc7XG5cbi8qKlxuICogTWFpbiBhcHBsaWNhdGlvbiB3cmFwZXIuXG4gKiBAcGFyYW0ge0FwcERlZmF1bHRzfSBzZXR0aW5ncyAtIFNldHRpbmdzIG9iamVjdC5cbiAqIEBjbGFzc1xuICovXG52YXIgQXBwID0gZnVuY3Rpb24oc2V0dGluZ3MgPSB7fSkge1xuXHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmRlZXBBc3NpZ24oe30sIEFwcC5kZWZhdWx0cywgc2V0dGluZ3MpO1xuXHR0aGlzLl9pbml0KCk7XG5cdHRoaXMuZGlhbG9ncyA9IGNyZWF0ZURpYWxvZ3ModGhpcy5zZXR0aW5ncyk7XG5cdHRoaXMuc3RvcmFnZSA9IG5ldyBTdG9yYWdlKCd0YWdfYXBwJyk7XG5cblx0Ly8gc2V0IFRlbXBsYXRlLm9uRWxlbWVudFJlbmRlciB0byBzZXR0aW5ncywgaWYgZGVmaW5lZFxuXHRpZiAoc2V0dGluZ3Mub25FbGVtZW50UmVuZGVyKSB7XG5cdFx0VGVtcGxhdGUub25FbGVtZW50UmVuZGVyID0gc2V0dGluZ3Mub25FbGVtZW50UmVuZGVyLmJpbmQodGhpcyk7XG5cdH1cblxuXHQvLyBiaW5kIGhpZGVEaWFsb2cgdG8gdGhpcyBjb250ZXh0IGluIGNhc2UgaXRzIHVzZWQgYXMgYSBkaXJlY3QgYXJndW1lbnQgd2l0aGluIGEgcHJvbWlzZVxuXHR0aGlzLmhpZGVEaWFsb2cgPSB0aGlzLmhpZGVEaWFsb2cuYmluZCh0aGlzKTtcbn07XG5cbkFwcC5wcm90b3R5cGUgPSB7XG5cdF9pbml0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9yZWZzID0ge1xuXHRcdFx0dWk6IHtcblx0XHRcdFx0YXBwOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXBwJylcblx0XHRcdH0sXG5cdFx0XHRtb3VudGVkOiB7fSxcblx0XHRcdGNvbXBvbmVudHM6IHt9XG5cdFx0fTtcblxuXHRcdC8vIGFwcCBkYXRhIHN0b3JlIChub3Qgc3RhdGVmdWwpXG5cdFx0dGhpcy5fZGF0YSA9IHtcblx0XHRcdHRlbXBsYXRlOiAnJyxcblx0XHRcdHBhbGxldDogW11cblx0XHR9O1xuXG5cdFx0Ly8gdGVtcGxhdGVzIG1vZHVsZVxuXHRcdHRoaXMuX3RlbXBsYXRlID0gbmV3IFRlbXBsYXRlKHRoaXMsIHRoaXMuc2V0dGluZ3MpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBMb2FkIHRoZSB0ZW1wbGF0ZS9wYWxsZXQgZGF0YSBhbmQgYWN0aXZhdGUgVGFnLlxuXHQgKi9cblx0bG9hZDogZnVuY3Rpb24odXJsLCBwYWxsZXQpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGVtcGxhdGUubG9hZCh1cmwpXG5cdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdC8vIGxvYWQgdGhlIEhUTUwgdGVtcGxhdGUgYW5kIGNyZWF0ZSBpdFxuXHRcdFx0XHR2YXIgZGF0YSA9IHRoaXMuX3RlbXBsYXRlLmNyZWF0ZSgpO1xuXG5cdFx0XHRcdHRoaXMuX2RhdGEuZHJvcF96b25lcyA9IGRhdGEuZHJvcF96b25lcztcblx0XHRcdFx0dGhpcy5fZGF0YS50ZW1wbGF0ZSA9IGRhdGEudGVtcGxhdGU7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHQvLyBsb2FkIHRoZSBKU09OIGJhc2VkIHBhbGxldCBkYXRhXG5cdFx0XHRcdHJldHVybiB0aGlzLl9sb2FkUGFsbGV0KHBhbGxldCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHR2YXIgc3RvcmVkX3N0YXRlID0gdGhpcy5zdG9yYWdlLmdldCgnc3RhdGUnLCB1bmRlZmluZWQpO1xuXG5cdFx0XHRcdGlmIChzdG9yZWRfc3RhdGUgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdHR5cGVvZiBzdG9yZWRfc3RhdGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0Ly8gc3RvcmVkIHN0YXRlIGV4aXN0cyAtIHJlc2V0IFVJICh3aGljaCBpcyBub24tcGVyc2lzdGFudClcblx0XHRcdFx0XHRzdG9yZWRfc3RhdGUuVUkgPSB7fTtcblx0XHRcdFx0XHRzdG9yZWRfc3RhdGUuVUkgPSBkZWZhdWx0U3RhdGUuVUk7XG5cblx0XHRcdFx0XHRpZiAoIXRoaXMuX3ZhbGlkYXRlX3N0YXRlKHN0b3JlZF9zdGF0ZSkpIHtcblx0XHRcdFx0XHRcdC8vIHJlc2V0IHN0b3JlZF9zdGF0ZSBiYWNrIHRvIHVuZGVmaW5lZCBpZiAgaXQncyBub3QgdmFsaWRcblx0XHRcdFx0XHRcdHN0b3JlZF9zdGF0ZSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gcmVzZXQgYmFjayB0byB1bmRlZmluZWRcblx0XHRcdFx0XHRzdG9yZWRfc3RhdGUgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhcHAgc3RhdGUgc3RvcmUgLSBkZWZhdWx0XG5cdFx0XHRcdHRoaXMuX3N0b3JlID0gY3JlYXRlU3RvcmUoXG5cdFx0XHRcdFx0cmVkdWNlcnMsXG5cdFx0XHRcdFx0c3RvcmVkX3N0YXRlLFxuXHRcdFx0XHRcdChcblx0XHRcdFx0XHRcdHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRcdFx0XHR3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyAmJlxuXHRcdFx0XHRcdFx0d2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18oe1xuXHRcdFx0XHRcdFx0XHQvLyBibGFjayBsaXN0IGFsbCBzZXNzaW9uLWJhc2VkIG5vbiBwZXJzaXN0YW50IGFjdGlvbnNcblx0XHRcdFx0XHRcdFx0Ly8gKHNvbWUgb2Ygd2hpY2ggY29udGFpbiB1bnNlcmlhbGlzYWJsZSBvYmplY3RzKVxuXHRcdFx0XHRcdFx0XHRhY3Rpb25zQmxhY2tsaXN0OiBbXG5cdFx0XHRcdFx0XHRcdFx0YWN0aW9uVHlwZXMuU0VUX0FDVElWRV9EUk9QTEVULFxuXHRcdFx0XHRcdFx0XHRcdGFjdGlvblR5cGVzLlNFVF9ESUFMT0dfTU9ERSxcblx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UeXBlcy5TRVRfVE9VUl9TVEFHRSxcblx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UeXBlcy5TSE9XX1RPT0xUSVAsXG5cdFx0XHRcdFx0XHRcdFx0YWN0aW9uVHlwZXMuSElERV9UT09MVElQLFxuXHRcdFx0XHRcdFx0XHRcdGFjdGlvblR5cGVzLlNFVF9UT09MVElQX0NPTlRFTlRcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gYWN0aXZhdGUgdGhlIFVJXG5cdFx0XHRcdHRoaXMuX1VJID0gbmV3IFVJKFxuXHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncyxcblx0XHRcdFx0XHR0aGlzLl9yZWZzLFxuXHRcdFx0XHRcdHRoaXMuX2RhdGEsXG5cdFx0XHRcdFx0dGhpcy5fc3RvcmUsXG5cdFx0XHRcdFx0dGhpcy5fdGVtcGxhdGVcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyByZW5kZXJcblx0XHRcdFx0dGhpcy5fVUkucmVuZGVyKCk7XG5cblx0XHRcdFx0Ly8gc2V0IGFjdGl2ZSBzdGF0ZVxuXHRcdFx0XHR0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnNldFVJU3RhdGUodWlTdGF0ZXMuQUNUSVZFKSk7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBMb2FkIHRoZSBwYWxsZXQgZGF0YVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2xvYWRQYWxsZXQ6IGZ1bmN0aW9uKHVybCkge1xuXHRcdHJldHVybiByZXF1ZXN0LmdldCh1cmwpXG5cdFx0XHQudGhlbigocmVzcG9uc2UpID0+IHtcblx0XHRcdFx0dmFyIHBhbGxldCwgaXRlbTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHBhbGxldCA9IEpTT04ucGFyc2UocmVzcG9uc2UudGV4dCk7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHQnUGFsbGV0IGRhdGEgYXQgZmlsZSBcIicgKyB1cmwgKyAnXCJcIiBjb3VsZCBub3QgYmUgcGFyc2VkLicgK1xuXHRcdFx0XHRcdFx0JyBpcyBpdCB2YWxpZCBKU09OPydcblx0XHRcdFx0XHQpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHBhbGxldCkgJiYgcGFsbGV0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGZvciAoaXRlbSBpbiBwYWxsZXQpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEucGFsbGV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdG5ldyBEcm9wbGV0KHBhbGxldFtpdGVtXSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdCdMb29rcyBsaWtlIHRoZSBwYWxsZXQgYXQgcGF0aCAnICsgdXJsICtcblx0XHRcdFx0XHRcdCcgaXNu4oCZdCBhIHZhbGlkIGFycmF5IGluIEpTT04gZm9ybWF0Lidcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBWYWxpZGF0ZXMgYSBzdGF0ZSBvYmplY3QgYnkgY29tcGFyaW5nIGl0IHRvIHRoZSBkZWZhdWx0IHN0YXRlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3ZhbGlkYXRlX3N0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdHJldHVybiBzdHJ1Y3RDb21wYXJlKHN0YXRlLCBkZWZhdWx0U3RhdGUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEaXNwbGF5cyBhIGRpYWxvZyBtZXNzYWdlIHdpdGggb3B0aW9uYWwgY29uZmlybWF0aW9uc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgLSBUaXRsZSBvZiB0aGUgZGlhbG9nLlxuXHQgKiBAcGFyYW0ge2FycmF5fEhUTUxFbGVtZW50fSBtZXNzYWdlIC0gTWVzc2FnZSB0byBkaXNwbGF5LlxuXHQgKiBAcGFyYW0ge2FycmF5fSBbYnV0dG9uc10gLSBCdXR0b25zIHRvIHNob3cuIERlZmF1bHRzIHRvIGEgc2luZ2xlIFwiT0tcIiBidXR0b24uXG5cdCAqIEByZXR1cm5zIHtEaWFsb2dQcm9taXNlfSBhIFByb21pc2UsIHRoZSByZXNvbHZlL3JlamVjdCBtZXRob2RzIG9mIHdoaWNoIHdpbGwgZGVub3RlXG5cdCAqIGNvbXBsZXRpb24gb3IgY2FuY2VsbGF0aW9uIG9mIHRoZSBkaWFsb2cuIEN1c3RvbSBidXR0b24gZXZlbnRzIHdpbGwgbm90IGNvbXBsZXRlXG5cdCAqIHRoZSBwcm9taXNlLlxuXHQgKi9cblx0ZGlhbG9nOiBmdW5jdGlvbih0aXRsZSwgbWVzc2FnZSwgYnV0dG9ucyA9IFtdKSB7XG5cdFx0dGhpcy5fcmVxdWlyZVVJKCk7XG5cblx0XHRpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcblx0XHRcdG1lc3NhZ2UgPSBbbWVzc2FnZV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX1VJLl9zaG93RGlhbG9nKFxuXHRcdFx0ZGlhbG9nTW9kZXMuR0VORVJBTCwge1xuXHRcdFx0XHR0aXRsZSxcblx0XHRcdFx0bWVzc2FnZSxcblx0XHRcdFx0YnV0dG9uc1xuXHRcdFx0fVxuXHRcdCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhpZGVzIHdoaWNoZXZlciBhY3RpdmUgZGlhbG9nIGlzIGN1cnJlbnRseSBvcGVuLlxuXHQgKi9cblx0aGlkZURpYWxvZzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fVUkuX2hpZGVEaWFsb2cuYXBwbHkodGhpcy5fVUkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTdGFydHMgdGhlIHN0YW5kYXJkaXNlZCB0b3VyIHByb2Nlc3MsIGd1aWRpbmcgdGhlIHVzZXIgdGhyb3VnaCB0aGUgaW50ZXJmYWNlLlxuXHQgKi9cblx0c3RhcnRUb3VyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9yZXF1aXJlVUkoKTtcblx0XHR0aGlzLl9VSS5fdG91ci5zdGFydCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIHRlbXBsYXRlIGFuZCB2aWV3IGZyYW1lLiAqbm90ZSosIGFsbCBwbGFjZW1lbnRzIHdpbGwgYmUgbG9zdC5cblx0ICovXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9yZXF1aXJlVUkoKTtcblxuXHRcdHRoaXMuX1VJLl9zaG93RGlhbG9nKGRpYWxvZ01vZGVzLkdFTkVSQUwsIHRoaXMuZGlhbG9ncy5yZXNldFN0YXRlKVxuXHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHQvLyBjbGVhciBhbGwgem9uZXMgYW5kIHJlc2V0IHRoZSBhcHBcblx0XHRcdFx0dGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy56b25lQ2xlYXJBbGxBdHRhY2htZW50cygpKTtcblx0XHRcdFx0dGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy5yZXNldEFwcCgpKTtcblxuXHRcdFx0XHQvLyBjbGVhciB2aWV3XG5cdFx0XHRcdHRoaXMuX1VJLl9jb21tcy5zZW5kKCd2aWV3Jywge1xuXHRcdFx0XHRcdGNtZDogbWVzc2FnZUNvbW1hbmRzLlJFU0VUXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXMuaGlkZURpYWxvZygpO1xuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHZpZXcgZnJhbWUgd2l0aCB0aGUgbGF0ZXN0IHRlbXBsYXRlIGFuZCBpdHMgYXR0YWNobWVudHMuXG5cdCAqL1xuXHR1cGRhdGVWaWV3OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9yZXF1aXJlVUkoKTtcblx0XHR0aGlzLl9VSS5fdXBkYXRlVmlldygpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXF1aXJlcyBhIF9VSSBpbnN0YW5jZS4gV2lsbCB0aHJvdyBpZiBvbmUgZG9lc24ndCBleGlzdC5cblx0ICovXG5cdF9yZXF1aXJlVUk6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fVUkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVUkgaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXNlZCEgSGF2ZSB5b3UgdXNlZCAjbG9hZCgpIHlldD8nKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogRGVmYXVsdCBzZXR0aW5ncy5cbiAqL1xuQXBwLmRlZmF1bHRzID0gYXBwRGVmYXVsdHM7XG5cbi8qKlxuICogSWNvbiBnbHlwaHNcbiAqL1xuQXBwLkdMWVBIUyA9IEdMWVBIUztcblxuZXhwb3J0IGRlZmF1bHQgQXBwO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvSW5kZXguanMiLCJpbXBvcnQgeyBHTFlQSFMgfSBmcm9tICcuLi9jb21wb25lbnRzL3ZpZXdzL0ljb24uanN4JztcbmltcG9ydCB7IGRpYWxvZ01vZGVzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHNldHRpbmdzIGFwcGxpZWQgdG8gdGFnJ3MgQXBwIGNsYXNzIG9uIGluc3RhbnRpYXRpb24uXG4gKiBAdHlwZWRlZiBBcHBEZWZhdWx0c1xuICogQHByb3BlcnR5IHtvYmplY3R9IGNsYXNzZXMgLSBDbGFzcyBkZWZpbml0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBzZWxlY3RvcnMgLSBDU1MgU2VsZWN0b3IgZGVmaW5pdGlvbnMuXG4gKiBAcHJvcGVydHkge29iamVjdH0gdGVtcGxhdGUgLSBUZW1wbGF0ZSBvcHRpb25zLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRlbXBsYXRlLmluaXRpYWxfZmxleF9iYXNpcz01MCAtIFRoZSBpbml0aWFsIGZsZXggYmFzaXMgKHdpZHRoKSBvZlxuICogdGhlIHRlbXBsYXRlIGNvbnRhaW5lci5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB2aWV3IC0gVmlldyBvcHRpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZpZXcuc3JjPSd2aWV3Lmh0bWwnIC0gU291cmNlIGZpbGVuYW1lIGZvciB0aGUgdmlldyBmcmFtZSAocmVsYXRpdmUgdG8gdGhlIEFwcCBpbmRleCkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHZpZXcuYXV0b1VwZGF0ZT1mYWxzZSAtIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSB1cGRhdGUgdGhlIHZpZXcgd2hlbiBEcm9wbGV0IGF0dGFjaG1lbnRzIGNoYW5nZS5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkcm9wWm9uZSAtIERyb3AgWm9uZSBvcHRpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRyb3Bab25lLmxhYmVsPScuLi4nIC0gVGhlIGxhYmVsIHRvIHVzZSBmb3IgRHJvcCBab25lIHRhcmdldHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGRyb3Bab25lLndhcm5PbkJhZFBsYWNlbWVudD10cnVlIC0gUHJvZHVjZSBhIGRpYWxvZyB3aGVuIHBsYWNpbmcgYSBEcm9wbGV0IGludG8gYW4gaW52YWxpZCBEcm9wIFpvbmUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGRyb3Bab25lLm5vdGljZU9uRmlyc3RQbGFjZW1lbnQ9dHJ1ZSAtIFByb2R1Y2UgYSBkaWFsb2cgb24gdGhlIGZpcnN0IHZhbGlkIHBsYWNlbWVudCBvZiBhIERyb3BsZXRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZHJvcFpvbmUubm90aWNlT25MYXN0UGxhY2VtZW50PXRydWUgLSBQcm9kdWNlIGEgZGlhbG9nIHdoZW4gYWxsIG9mIHRoZSBEcm9wIFpvbmVzIGhhdmUgYXQgbGVhc3Qgb25lIGF0dGFjaG1lbnQuXG4gKiBAcHJvcGVydHkge1Rvb2xiYXJJdGVtW119IHRvb2xiYXIgLSBUb29sYmFyIGl0ZW1zLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0Y2xhc3Nlczoge1xuXHRcdGNhbnZhczogJ3RhZy1jYW52YXMnLFxuXHRcdGNhbnZhc19hY3RpdmU6ICdhY3RpdmUnLFxuXHRcdGRyb3BsZXRfYWN0aXZlOiAnZHJvcGxldC1hY3RpdmUnLFxuXHRcdGlzX2RyYWdnaW5nOiAnZHJhZ2dpbmcnLFxuXHRcdGl0ZW1fZHJhZ2dpbmc6ICdpdGVtLWRyYWdnaW5nJyxcblx0XHRkcm9wem9uZV90YXJnZXQ6ICd0YXJnZXQnLFxuXHRcdGRyb3B6b25lX2lzX2FjdGl2ZTogJ2lzLWFjdGl2ZScsXG5cdFx0ZHJvcHpvbmVfaXNfdGFyZ2V0OiAnaXMtdGFyZ2V0Jyxcblx0XHRhdHRhY2hlZDogJ2F0dGFjaGVkJyxcblx0XHR0ZXh0X2VsZW1lbnQ6ICd0ZXh0Jyxcblx0XHRoaWRkZW46ICdoaWRkZW4nLFxuXHRcdGJ1dHRvbjogJ2J1dHRvbicsXG5cdFx0YnV0dG9uX2FuaW1hdGU6ICdhbmltYXRlJyxcblx0XHRwb3B1cDogJ3BvcHVwJyxcblx0XHR0b29sdGlwOiAndG9vbHRpcCcsXG5cdFx0dGVtcGxhdGU6IHtcblx0XHRcdG5vZGU6ICd0ZW1wbGF0ZScsXG5cdFx0XHRpbm5lcjogJ3RlbXBsYXRlLWlubmVyJ1xuXHRcdH0sXG5cdFx0ZHJvcGxldDoge1xuXHRcdFx0bm9kZTogJ2Ryb3BsZXQnLFxuXHRcdFx0YWN0aXZlOiAnYWN0aXZlJyxcblx0XHR9LFxuXHRcdGRyb3B6b25lOiB7XG5cdFx0XHRub2RlOiAnZHJvcC16b25lJyxcblx0XHRcdHBvc3NpYmxlX3RhcmdldDogJ3Bvc3NpYmxlLXRhcmdldCcsXG5cdFx0XHR3aWxsX2FjY2VwdDogJ3dpbGwtYWNjZXB0Jyxcblx0XHRcdHdpbGxfZGVjbGluZTogJ3dpbGwtZGVjbGluZSdcblx0XHR9LFxuXHRcdGRpYWxvZzoge1xuXHRcdFx0bWFpbjogJ2RpYWxvZycsXG5cdFx0XHR2aXNpYmxlOiAndmlzaWJsZScsXG5cdFx0XHRjb250YWluZXI6ICdkaWFsb2ctY29udGFpbmVyJyxcblx0XHRcdGhlYWRpbmc6ICdkaWFsb2ctaGVhZGluZycsXG5cdFx0XHRub19vdmVybGF5OiAnbm8tb3ZlcmxheSdcblx0XHR9LFxuXHRcdHRvb2xiYXI6IHtcblx0XHRcdHNlcGFyYXRvcjogJ3NlcGFyYXRvcidcblx0XHR9XG5cdH0sXG5cdHNlbGVjdG9yczoge1xuXHRcdGRyb3Bfem9uZTogJy5kcm9wLXpvbmUgLnRhcmdldCcsXG5cdFx0ZHJvcGxldDogJy5kcm9wbGV0Jyxcblx0XHRidXR0b25fY2lyY2xlOiAnLmNpcmNsZSdcblx0fSxcblx0dGVtcGxhdGU6IHtcblx0XHRpbml0aWFsX2ZsZXhfYmFzaXM6IDUwXG5cdH0sXG5cdHZpZXc6IHtcblx0XHRzcmM6ICd2aWV3Lmh0bWwnLFxuXHRcdGF1dG9VcGRhdGU6IGZhbHNlXG5cdH0sXG5cdGRyb3Bab25lOiB7XG5cdFx0bGFiZWw6ICcuLi4nLFxuXHRcdHdhcm5PbkJhZFBsYWNlbWVudDogdHJ1ZSxcblx0XHRub3RpY2VPbkZpcnN0UGxhY2VtZW50OiB0cnVlLFxuXHRcdG5vdGljZU9uTGFzdFBsYWNlbWVudDogdHJ1ZVxuXHR9LFxuXHR0b29sYmFyOiBbe1xuXHRcdGxhYmVsOiAoc3RhdGUpID0+IHtcblx0XHRcdGlmIChzdGF0ZS5VSS50b3VyX3N0YWdlICE9PSBudWxsICYmIHN0YXRlLlVJLmRpYWxvZy5tb2RlID09PSBkaWFsb2dNb2Rlcy5OT05FKSB7XG5cdFx0XHRcdHJldHVybiAnQ29udGludWUgdG91cic7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gJ1RvdXInO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aWNvbjogR0xZUEhTLkNPTVBBU1MsXG5cdFx0bWV0aG9kOiAnc3RhcnRUb3VyJ1xuXHR9LCB7XG5cdFx0bGFiZWw6ICdSZXNldCcsXG5cdFx0aWNvbjogR0xZUEhTLkxPT1BfQ0lSQ1VMQVIsXG5cdFx0bWV0aG9kOiAncmVzZXQnXG5cdH0sIHtcblx0XHRsYWJlbDogJ1J1bicsXG5cdFx0aWNvbjogR0xZUEhTLk1FRElBX1BMQVksXG5cdFx0bWV0aG9kOiAndXBkYXRlVmlldycsXG5cdFx0Y2xhc3NOYW1lOiAncnVuJyxcblx0XHRzZXBhcmF0b3I6IHRydWVcblx0fV0sXG5cdG9uRWxlbWVudFJlbmRlcjogbnVsbCxcblx0c2hvd0ludHJvOiBQUk9EVUNUSU9OXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvYXNzZXRzL2RlZmF1bHRzLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGNvbnN0IG9wdGlvblZhbHVlU2V0ID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdHZhciBub2RlcyA9IFtdLCBrZXk7XG5cblx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuXHRcdHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuXHRcdFx0dmFyIGtleSA9ICdpdGVtLScgKyBpbmRleDtcblx0XHRcdG5vZGVzLnB1c2goXG5cdFx0XHRcdDxvcHRpb24ga2V5PXtrZXl9IHZhbHVlPXt2YWx1ZX0+e3ZhbHVlfTwvb3B0aW9uPlxuXHRcdFx0KTtcblx0XHR9KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWVzID09PSAnb2JqZWN0Jykge1xuXHRcdGZvciAoa2V5IGluIHZhbHVlcykge1xuXHRcdFx0bm9kZXMucHVzaChcblx0XHRcdFx0PG9wdGlvbiBrZXk9e2tleX0gdmFsdWU9e2tleX0+e3ZhbHVlc1trZXldfTwvb3B0aW9uPlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbm9kZXM7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy9jb21wb25lbnQtdXRpbHMuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29sbGVjdFJlZiB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5cbmltcG9ydCBWaWV3IGZyb20gJy4uL3ZpZXdzL1ZpZXcuanN4JztcbmltcG9ydCBUb29sdGlwIGZyb20gJy4vVG9vbHRpcENvbnRhaW5lcic7XG5pbXBvcnQgSGVhZGVyIGZyb20gJy4vSGVhZGVyQ29udGFpbmVyJztcbmltcG9ydCBUZW1wbGF0ZSBmcm9tICcuL1RlbXBsYXRlQ29udGFpbmVyJztcbmltcG9ydCBEaWFsb2cgZnJvbSAnLi9EaWFsb2dDb250YWluZXInO1xuaW1wb3J0IFBhbGxldCBmcm9tICcuL1BhbGxldENvbnRhaW5lcic7XG5cbmNsYXNzIENhbnZhcyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0aWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uTW91bnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMucHJvcHMub25Nb3VudCgnY2FudmFzJyk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW1xuXHRcdFx0dGhpcy5wcm9wcy5zZXR0aW5ncy5jbGFzc2VzLmNhbnZhcyxcblx0XHRcdHRoaXMucHJvcHMuc3RhdGUudWlfc3RhdGVcblx0XHRdO1xuXG5cdFx0aWYgKHR5cGVvZiB0aGlzLnByb3BzLmFjdGl2ZV9kcm9wbGV0X2lkID09PSAnc3RyaW5nJyAmJlxuXHRcdFx0dGhpcy5wcm9wcy5hY3RpdmVfZHJvcGxldF9pZCAhPT0gJycpIHtcblx0XHRcdGNsYXNzZXMucHVzaCh0aGlzLnByb3BzLnNldHRpbmdzLmNsYXNzZXMuZHJvcGxldF9hY3RpdmUpO1xuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5qb2luKCcgJyl9XG5cdFx0XHRcdHJlZj17Y29sbGVjdFJlZih0aGlzLnByb3BzLCAnY2FudmFzJyl9XG5cdFx0XHRcdD5cblx0XHRcdFx0PEhlYWRlclxuXHRcdFx0XHRcdHNldHRpbmdzPXt0aGlzLnByb3BzLnNldHRpbmdzfVxuXHRcdFx0XHRcdG9uQnV0dG9uQ2xpY2s9e3RoaXMucHJvcHMub25CdXR0b25DbGlja31cblx0XHRcdFx0XHRsaWI9e3RoaXMucHJvcHMubGlifT5cblx0XHRcdFx0XHQ8aDEgY2xhc3NOYW1lPVwibG9nb1wiPiZsdDs8Yj5UYWc8L2I+Jmd0OzwvaDE+XG5cdFx0XHRcdFx0PHA+VGhlIHdlYnBhZ2UgbGVhcm5pbmcgdG9vbC48L3A+XG5cdFx0XHRcdDwvSGVhZGVyPlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwibWFpblwiPlxuXHRcdFx0XHRcdDxUZW1wbGF0ZVxuXHRcdFx0XHRcdFx0ZGF0YT17dGhpcy5wcm9wcy5kYXRhfVxuXHRcdFx0XHRcdFx0c2V0dGluZ3M9e3RoaXMucHJvcHMuc2V0dGluZ3N9XG5cdFx0XHRcdFx0XHRyZWZDb2xsZWN0b3I9e3RoaXMucHJvcHMucmVmQ29sbGVjdG9yfVxuXHRcdFx0XHRcdFx0b25Nb3VudD17dGhpcy5wcm9wcy5vbk1vdW50fVxuXHRcdFx0XHRcdFx0b25BdHRhY2htZW50Q2xpY2s9e3RoaXMucHJvcHMub25BdHRhY2htZW50Q2xpY2t9XG5cdFx0XHRcdFx0XHRvbkRyb3Bab25lRXZlbnQ9e3RoaXMucHJvcHMub25Ecm9wWm9uZUV2ZW50fVxuXHRcdFx0XHRcdFx0dGVtcGxhdGU9e3RoaXMucHJvcHMuZGF0YS50ZW1wbGF0ZX1cblx0XHRcdFx0XHRcdGxpYj17dGhpcy5wcm9wcy5saWJ9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZHJhZy1oYW5kbGVcIlxuXHRcdFx0XHRcdFx0b25Nb3VzZUVudGVyPXt0aGlzLnByb3BzLm9uRHJhZ0hhbmRsZUV2ZW50fVxuXHRcdFx0XHRcdFx0b25Nb3VzZUxlYXZlPXt0aGlzLnByb3BzLm9uRHJhZ0hhbmRsZUV2ZW50fVxuXHRcdFx0XHRcdFx0b25Nb3VzZURvd249e3RoaXMucHJvcHMub25EcmFnSGFuZGxlRXZlbnR9XG5cdFx0XHRcdFx0XHRvbk1vdXNlVXA9e3RoaXMucHJvcHMub25EcmFnSGFuZGxlRXZlbnR9XG5cdFx0XHRcdFx0XHRvblRvdWNoU3RhcnQ9e3RoaXMucHJvcHMub25EcmFnSGFuZGxlRXZlbnR9XG5cdFx0XHRcdFx0XHRvblRvdWNoRW5kPXt0aGlzLnByb3BzLm9uRHJhZ0hhbmRsZUV2ZW50fVxuXHRcdFx0XHRcdFx0cmVmPXtjb2xsZWN0UmVmKHRoaXMucHJvcHMsICdkcmFnX2hhbmRsZScpfT48L2Rpdj5cblx0XHRcdFx0XHQ8Vmlld1xuXHRcdFx0XHRcdFx0c2V0dGluZ3M9e3RoaXMucHJvcHMuc2V0dGluZ3N9XG5cdFx0XHRcdFx0XHRvbk1vdW50PXt0aGlzLnByb3BzLm9uTW91bnR9XG5cdFx0XHRcdFx0XHRyZWZDb2xsZWN0b3I9e3RoaXMucHJvcHMucmVmQ29sbGVjdG9yfS8+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxQYWxsZXRcblx0XHRcdFx0XHRkYXRhPXt0aGlzLnByb3BzLmRhdGF9XG5cdFx0XHRcdFx0c2V0dGluZ3M9e3RoaXMucHJvcHMuc2V0dGluZ3N9XG5cdFx0XHRcdFx0bGliPXt0aGlzLnByb3BzLmxpYn1cblx0XHRcdFx0XHRvbk1vdW50PXt0aGlzLnByb3BzLm9uTW91bnR9XG5cdFx0XHRcdFx0b25Ecm9wbGV0RXZlbnQ9e3RoaXMucHJvcHMub25Ecm9wbGV0RXZlbnR9XG5cdFx0XHRcdFx0cmVmQ29sbGVjdG9yPXt0aGlzLnByb3BzLnJlZkNvbGxlY3Rvcn0vPlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwib3ZlcmxheVwiPjwvZGl2PlxuXHRcdFx0XHQ8RGlhbG9nXG5cdFx0XHRcdFx0c2V0dGluZ3M9e3RoaXMucHJvcHMuc2V0dGluZ3N9XG5cdFx0XHRcdFx0bGliPXt0aGlzLnByb3BzLmxpYn1cblx0XHRcdFx0XHRvbkJ1dHRvbkNsaWNrPXt0aGlzLnByb3BzLm9uQnV0dG9uQ2xpY2t9Lz5cblx0XHRcdFx0PFRvb2x0aXBcblx0XHRcdFx0XHRzZXR0aW5ncz17dGhpcy5wcm9wcy5zZXR0aW5nc31cblx0XHRcdFx0XHRhdHRhY2hlcj17dGhpcy5wcm9wcy5saWIuc2V0VUlQb3BwZXJBdHRhY2htZW50fS8+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cbkNhbnZhcy5wcm9wVHlwZXMgPSB7XG5cdC8vIGZyb20gQ2FudmFzQ29udGFpbmVyXG5cdHN0YXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cdGFjdGl2ZV9kcm9wbGV0X2lkOiBQcm9wVHlwZXMuYW55LFxuXHRzdGF0ZV90b29sdGlwOiBQcm9wVHlwZXMub2JqZWN0LFxuXG5cdC8vIGZyb20gVUkjcmVuZGVyXG5cdGRhdGE6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblx0b25Nb3VudDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblx0b25BdHRhY2htZW50Q2xpY2s6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdG9uRHJvcGxldEV2ZW50OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRvbkRyb3Bab25lRXZlbnQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdG9uRHJhZ0hhbmRsZUV2ZW50OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRvbkJ1dHRvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRyZWZDb2xsZWN0b3I6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdHNldHRpbmdzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cdGxpYjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYW52YXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lcnMvQ2FudmFzLmpzeCIsImltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5cbmltcG9ydCBDYW52YXMgZnJvbSAnLi9DYW52YXMuanN4JztcblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlKSA9PiB7XG5cdHJldHVybiB7XG5cdFx0c3RhdGU6IHN0YXRlLmFwcCxcblx0XHRhY3RpdmVfZHJvcGxldF9pZDogc3RhdGUuVUkuYWN0aXZlX2Ryb3BsZXRfaWRcblx0fTtcbn07XG5cbmNvbnN0IENhbnZhc0NvbnRhaW5lciA9IGNvbm5lY3QoXG4gIG1hcFN0YXRlVG9Qcm9wc1xuKShDYW52YXMpO1xuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNDb250YWluZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lcnMvQ2FudmFzQ29udGFpbmVyLmpzIiwiaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcblxuaW1wb3J0IERpYWxvZyBmcm9tICcuLi9kaWFsb2dzL0RpYWxvZy5qc3gnO1xuXG5jb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSAoc3RhdGUpID0+IHtcblx0cmV0dXJuIHtcblx0XHRpZDogc3RhdGUuVUkuZGlhbG9nLmlkLFxuXHRcdG1vZGU6IHN0YXRlLlVJLmRpYWxvZy5tb2RlLFxuXHRcdGRhdGE6IHN0YXRlLlVJLmRpYWxvZy5kYXRhLFxuXHRcdG9uRGlhbG9nQ29tcGxldGU6IHN0YXRlLlVJLmRpYWxvZy5vbkRpYWxvZ0NvbXBsZXRlLFxuXHRcdG9uRGlhbG9nQ2FuY2VsOiBzdGF0ZS5VSS5kaWFsb2cub25EaWFsb2dDYW5jZWxcblx0fTtcbn07XG5cbmNvbnN0IERpYWxvZ0NvbnRhaW5lciA9IGNvbm5lY3QoXG4gIG1hcFN0YXRlVG9Qcm9wc1xuKShEaWFsb2cpO1xuXG5leHBvcnQgZGVmYXVsdCBEaWFsb2dDb250YWluZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lcnMvRGlhbG9nQ29udGFpbmVyLmpzIiwiaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcblxuaW1wb3J0IEhlYWRlciBmcm9tICcuLi92aWV3cy9IZWFkZXIuanN4JztcblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlKSA9PiB7XG5cdHJldHVybiB7XG5cdFx0dG91cl9zdGFnZTogc3RhdGUuVUkudG91cl9zdGFnZSxcblx0XHRkaWFsb2dfbW9kZTogc3RhdGUuVUkuZGlhbG9nLm1vZGVcblx0fTtcbn07XG5cbmNvbnN0IEhlYWRlckNvbnRhaW5lciA9IGNvbm5lY3QoXG4gIG1hcFN0YXRlVG9Qcm9wc1xuKShIZWFkZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBIZWFkZXJDb250YWluZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lcnMvSGVhZGVyQ29udGFpbmVyLmpzIiwiaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcblxuaW1wb3J0IGFjdGlvbnMgZnJvbSAnLi4vLi4vc3RhdGUvYWN0aW9ucyc7XG5pbXBvcnQgUGFsbGV0IGZyb20gJy4uL3ZpZXdzL1BhbGxldC5qc3gnO1xuXG5jb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSAoc3RhdGUpID0+IHtcblx0cmV0dXJuIHtcblx0XHRhY3RpdmVEcm9wbGV0SWQ6IHN0YXRlLlVJLmFjdGl2ZV9kcm9wbGV0X2lkXG5cdH07XG59O1xuXG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSAoZGlzcGF0Y2gsIHByb3BzKSA9PiB7XG5cdHJldHVybiB7XG5cdFx0b25Ecm9wbGV0RXZlbnQ6IChldmVudCwgZHJvcGxldCwgZGF0YSkgPT4ge1xuXHRcdFx0c3dpdGNoIChldmVudC50eXBlKSB7XG5cdFx0XHRjYXNlICdtb3VzZWVudGVyJzpcblx0XHRcdGNhc2UgJ3RvdWNoc3RhcnQnOlxuXHRcdFx0XHRkaXNwYXRjaChhY3Rpb25zLnNldFRvb2x0aXBDb250ZW50KGRhdGEudGl0bGUsIGRhdGEuY29udGVudCwgZGF0YS5pY29uR2x5cGgpKTtcblx0XHRcdFx0ZGlzcGF0Y2goYWN0aW9ucy5zaG93VG9vbHRpcChkYXRhLnJlZikpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnbW91c2VsZWF2ZSc6XG5cdFx0XHRjYXNlICd0b3VjaGVuZCc6XG5cdFx0XHRjYXNlICdjbGljayc6XG5cdFx0XHRcdGRpc3BhdGNoKGFjdGlvbnMuaGlkZVRvb2x0aXAoKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRwcm9wcy5vbkRyb3BsZXRFdmVudChldmVudCwgZHJvcGxldCwgZGF0YSk7XG5cdFx0fVxuXHR9O1xufTtcblxuY29uc3QgUGFsbGV0Q29udGFpbmVyID0gY29ubmVjdChcbiAgbWFwU3RhdGVUb1Byb3BzLFxuICBtYXBEaXNwYXRjaFRvUHJvcHNcbikoUGFsbGV0KTtcblxuZXhwb3J0IGRlZmF1bHQgUGFsbGV0Q29udGFpbmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy9jb250YWluZXJzL1BhbGxldENvbnRhaW5lci5qcyIsImltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5cbmltcG9ydCBUZW1wbGF0ZSBmcm9tICcuLi92aWV3cy9UZW1wbGF0ZS5qc3gnO1xuXG5jb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSAoc3RhdGUpID0+IHtcblx0cmV0dXJuIHtcblx0XHR6b25lczogc3RhdGUuem9uZXMsXG5cdFx0YWN0aXZlRHJvcGxldElEOiBzdGF0ZS5VSS5hY3RpdmVfZHJvcGxldF9pZFxuXHR9O1xufTtcblxuY29uc3QgVGVtcGxhdGVDb250YWluZXIgPSBjb25uZWN0KFxuICBtYXBTdGF0ZVRvUHJvcHNcbikoVGVtcGxhdGUpO1xuXG5leHBvcnQgZGVmYXVsdCBUZW1wbGF0ZUNvbnRhaW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvY29udGFpbmVycy9UZW1wbGF0ZUNvbnRhaW5lci5qcyIsImltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5cbmltcG9ydCBUb29sdGlwIGZyb20gJy4uL3ZpZXdzL1Rvb2x0aXAuanN4JztcblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlKSA9PiB7XG5cdHJldHVybiB7XG5cdFx0c3RhdGU6IHN0YXRlLlVJLnRvb2x0aXBcblx0fTtcbn07XG5cbmNvbnN0IFRvb2x0aXBDb250YWluZXIgPSBjb25uZWN0KFxuICBtYXBTdGF0ZVRvUHJvcHNcbikoVG9vbHRpcCk7XG5cbmV4cG9ydCBkZWZhdWx0IFRvb2x0aXBDb250YWluZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lcnMvVG9vbHRpcENvbnRhaW5lci5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgZGlhbG9nTW9kZXMgfSBmcm9tICcuLi8uLi9hc3NldHMvY29uc3RhbnRzJztcblxuLy8gaW1wb3J0IHRoZSBkaWFsb2dzIHVzZWQsIHRoZW4gcHV0IGludG8gYSBnbG9iYWwgZm9yIHJlZmVyZW5jaW5nXG5pbXBvcnQgRGlhbG9nR2VuZXJhbCBmcm9tICcuLi9kaWFsb2dzL0RpYWxvZ0dlbmVyYWwuanN4JztcbmltcG9ydCBEaWFsb2dFZGl0RHJvcGxldCBmcm9tICcuLi9kaWFsb2dzL0RpYWxvZ0VkaXREcm9wbGV0LmpzeCc7XG5cbnZhciBEaWFsb2dDb21wb25lbnRzID0ge307XG5EaWFsb2dDb21wb25lbnRzW2RpYWxvZ01vZGVzLkVESVRfRFJPUExFVF0gPSBEaWFsb2dFZGl0RHJvcGxldDtcbkRpYWxvZ0NvbXBvbmVudHNbZGlhbG9nTW9kZXMuR0VORVJBTF0gPSBEaWFsb2dHZW5lcmFsO1xuRGlhbG9nQ29tcG9uZW50c1tkaWFsb2dNb2Rlcy5UT1VSXSA9IERpYWxvZ0dlbmVyYWw7XG5cbmNsYXNzIERpYWxvZyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIGByZWZgIGFuZCBgcG9wcGVyYCByZWZlcmVuY2UgaXMgcmVmcmVzaGVkIGhlcmUgaW5zdGVhZCBvZiBjb21wb25lbnREaWRNb3VudFxuXHQgKiBiZWNhdXNlIHRoaXMgY29tcG9uZW50IGRvZXNuJ3QgcmVhbGx5IFwidW5tb3VudFwiIGFzIHN1Y2ggLSBpdCBqdXN0IGNoYW5nZXMgdGhlXG5cdCAqIGlubmVyIGBDb21wb25lbnRgIHZhbHVlIGZvciBkaWFsb2cgY29udGVudHMuXG5cdCAqL1xuXHRjb2xsZWN0UmVmKHJlZikge1xuXHRcdGlmIChyZWYgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuZGlhbG9nUmVmID0gcmVmO1xuXG5cdFx0XHRpZiAodGhpcy5wb3BwZXIpIHtcblx0XHRcdFx0Ly8gcG9wcGVyIGFscmVhZHkgZXhpc3RzIC0gcmVtb3ZlIGFuZCBzZXQgbnVsbFxuXHRcdFx0XHR0aGlzLnBvcHBlci5kZXN0cm95KCk7XG5cdFx0XHRcdHRoaXMucG9wcGVyID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMucHJvcHMuZGF0YSAmJiB0aGlzLnByb3BzLmRhdGEuYXR0YWNobWVudCkge1xuXHRcdFx0XHQvLyBhdHRhY2htZW50IGRhdGEgZXhpc3RzIC0gYXBwbHkgd2l0aCBwb3BwZXJcblx0XHRcdFx0dGhpcy5wb3BwZXIgPSB0aGlzLnByb3BzLmxpYi5zZXRVSVBvcHBlckF0dGFjaG1lbnQoXG5cdFx0XHRcdFx0dGhpcy5wcm9wcy5kYXRhLmF0dGFjaG1lbnQsXG5cdFx0XHRcdFx0dGhpcy5kaWFsb2dSZWZcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0dmFyIENvbXBvbmVudCxcblx0XHRcdGNsYXNzZXMgPSBbXG5cdFx0XHRcdHRoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5kaWFsb2cubWFpblxuXHRcdFx0XTtcblxuXHRcdGlmICh0aGlzLnByb3BzLm1vZGUgIT09IGRpYWxvZ01vZGVzLk5PTkUpIHtcblx0XHRcdGNsYXNzZXMucHVzaCh0aGlzLnByb3BzLnNldHRpbmdzLmNsYXNzZXMuZGlhbG9nLnZpc2libGUpO1xuXHRcdH1cblxuXHRcdC8vIGdldCBhcHByb3ByaWF0ZSBjb21wb25lbnQgZm9yIGRpYWxvZyBtb2RlXG5cdFx0Q29tcG9uZW50ID0gRGlhbG9nQ29tcG9uZW50c1t0aGlzLnByb3BzLm1vZGVdO1xuXG5cdFx0aWYgKENvbXBvbmVudCkge1xuXHRcdFx0Ly8gYSBkaWFsb2cgaXMgYmVpbmcgcmVxdWVzdGVkIC0gcmVuZGVyIHRoZSBhcHByb3ByaWF0ZSBjb21wb25lbnRcblx0XHRcdGlmICh0aGlzLnByb3BzLmRhdGEub3ZlcmxheSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKHRoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5kaWFsb2cubm9fb3ZlcmxheSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLmpvaW4oJyAnKX0+XG5cdFx0XHRcdFx0PENvbXBvbmVudFxuXHRcdFx0XHRcdFx0a2V5PXt0aGlzLnByb3BzLmlkfVxuXHRcdFx0XHRcdFx0ZGF0YT17dGhpcy5wcm9wcy5kYXRhfVxuXHRcdFx0XHRcdFx0c2V0dGluZ3M9e3RoaXMucHJvcHMuc2V0dGluZ3N9XG5cdFx0XHRcdFx0XHRyZWZDb2xsZWN0b3I9e3RoaXMuY29sbGVjdFJlZi5iaW5kKHRoaXMpfVxuXHRcdFx0XHRcdFx0b25EaWFsb2dDb21wbGV0ZT17dGhpcy5wcm9wcy5vbkRpYWxvZ0NvbXBsZXRlfVxuXHRcdFx0XHRcdFx0b25EaWFsb2dDYW5jZWw9e3RoaXMucHJvcHMub25EaWFsb2dDYW5jZWx9XG5cdFx0XHRcdFx0XHRvbkJ1dHRvbkNsaWNrPXt0aGlzLnByb3BzLm9uQnV0dG9uQ2xpY2t9XG5cdFx0XHRcdFx0XHRsaWI9e3RoaXMucHJvcHMubGlifS8+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuam9pbignICcpfT48L2Rpdj5cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG59XG5cbkRpYWxvZy5wcm9wVHlwZXMgPSB7XG5cdC8vIGZyb20gRGlhbG9nQ29udGFpbmVyXG5cdG1vZGU6IFByb3BUeXBlcy5zdHJpbmcsXG5cdGRhdGE6IFByb3BUeXBlcy5vYmplY3QsXG5cdG9uRGlhbG9nQ2FuY2VsOiBQcm9wVHlwZXMuZnVuYyxcblx0b25CdXR0b25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG5cdGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cblx0Ly8gZnJvbSBDYW52YXNcblx0c2V0dGluZ3M6IFByb3BUeXBlcy5vYmplY3QsXG5cdG9uRGlhbG9nQ29tcGxldGU6IFByb3BUeXBlcy5mdW5jLFxuXHRsaWI6IFByb3BUeXBlcy5vYmplY3Rcbn07XG5cbkRpYWxvZy5kZWZhdWx0UHJvcHMgPSB7XG5cdG9uRGlhbG9nQ2FuY2VsOiBudWxsLFxuXHRvbkRpYWxvZ0NvbXBsZXRlOiBudWxsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEaWFsb2c7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2RpYWxvZ3MvRGlhbG9nLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBGb3JtRmllbGQgZnJvbSAnLi4vLi4vbGliL0Zvcm1GaWVsZCc7XG5pbXBvcnQgeyBzZXRMYWJlbHMgfSBmcm9tICcuLi8uLi9hc3NldHMvY29uc3RhbnRzJztcbmltcG9ydCB7IGRpYWxvZyB9IGZyb20gJy4uLy4uL2Fzc2V0cy9jb21tb24tcHJvcC10eXBlcyc7XG5cbmltcG9ydCB7IEdMWVBIUyB9IGZyb20gJy4uL3ZpZXdzL0ljb24uanN4JztcbmltcG9ydCBEaWFsb2dIZWFkaW5nIGZyb20gJy4vRGlhbG9nSGVhZGluZy5qc3gnO1xuaW1wb3J0IEZvcm0gZnJvbSAnLi4vdmlld3MvRm9ybS5qc3gnO1xuXG5jb25zdCBoZWFkaW5nc0J5VHlwZSA9IHtcblx0J2VsZW1lbnQnOiB7XG5cdFx0dGV4dDogJ0VsZW1lbnQnLFxuXHRcdGljb246IEdMWVBIUy5UQUdcblx0fSxcblx0J3RleHQnOiB7XG5cdFx0dGV4dDogJ1RleHQgaXRlbScsXG5cdFx0aWNvbjogR0xZUEhTLlRFWFRcblx0fSxcblx0J2F0dHJpYnV0ZSc6IHtcblx0XHR0ZXh0OiAnQXR0cmlidXRlJyxcblx0XHRpY29uOiBHTFlQSFMuUFVaWkxFX1BJRUNFXG5cdH1cbn07XG5cbmNsYXNzIERpYWxvZ0VkaXREcm9wbGV0IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5kYXRhICYmIHRoaXMucHJvcHMuZGF0YS5kcm9wbGV0X2lkKSB7XG5cdFx0XHR0aGlzLmRyb3BsZXQgPSB0aGlzLnByb3BzLmxpYi5nZXREcm9wbGV0QnlJZCh0aGlzLnByb3BzLmRhdGEuZHJvcGxldF9pZCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbkRpYWxvZ0NvbXBsZXRlID0gdGhpcy5vbkRpYWxvZ0NvbXBsZXRlLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5kZXRhY2hBdHRhY2htZW50ID0gdGhpcy5kZXRhY2hBdHRhY2htZW50LmJpbmQodGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogSW5zdGVhZCBvZiBwYXNzaW5nIGNvbXBsZXRpb24gc3RyYWlnaHQgdG8gdGhlIHByb3AsIGhhbmRsZXMgY29udmVyc2lvbiBvZiByYXcgZm9ybVxuXHQgKiBkYXRhIGJhY2sgaW50byBhIGZvcm1hdCBtYXRjaGluZyB0aGUgb3JpZ2luYWwgZHJvcGxldCBkYXRhLlxuXHQgKi9cblx0b25EaWFsb2dDb21wbGV0ZSh2YWx1ZXMsIGFjdGlvbiwgYWN0aW9uX2RhdGEpIHtcblx0XHR2YXIgZHJvcGxldF92YWx1ZXMgPSB7fSxcblx0XHRcdGtleTtcblxuXHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbkRpYWxvZ0NvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBjb252ZXJ0IGRhdGEgYmFjayBpbnRvIGZvcm1hdCByZXBsaWNhdGluZyBEcm9wbGV0LmRhdGEgZm9ybWF0XG5cdFx0XHRmb3IgKGtleSBpbiB2YWx1ZXMpIHtcblx0XHRcdFx0aWYgKHZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gJ2F0dHJzJykge1xuXHRcdFx0XHRcdFx0ZHJvcGxldF92YWx1ZXNba2V5XSA9IHZhbHVlc1trZXldO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkcm9wbGV0X3ZhbHVlc1trZXldID0gdmFsdWVzW2tleV1ba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZHJvcGxldF92YWx1ZXMgPSBPYmplY3QuZGVlcEFzc2lnbih7fSwgdGhpcy5kcm9wbGV0LmRhdGEsIGRyb3BsZXRfdmFsdWVzKTtcblxuXHRcdFx0Ly8gZmluYWxseSwgZmlyZSB0aGUgb3JpZ2luYWwgcHJvcCB3aXRoIHRoZSBjb252ZXJ0ZWQgZGF0YVxuXHRcdFx0dGhpcy5wcm9wcy5vbkRpYWxvZ0NvbXBsZXRlKGRyb3BsZXRfdmFsdWVzLCBhY3Rpb24sIGFjdGlvbl9kYXRhKTtcblx0XHR9XG5cdH1cblxuXHRkZXRhY2hBdHRhY2htZW50KCkge1xuXHRcdGlmICh0aGlzLnByb3BzLmRhdGEuYXR0YWNobWVudF9pbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5wcm9wcy5saWIuem9uZURldGFjaEF0dGFjaG1lbnQoXG5cdFx0XHRcdHRoaXMucHJvcHMuZGF0YS56b25lX2lkLFxuXHRcdFx0XHR0aGlzLnByb3BzLmRhdGEuYXR0YWNobWVudF9pbmRleFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdhdHRhY2htZW50X2luZGV4IGlzIG51bGwgb3Igbm90IGRlZmluZWQuIENhbm5vdCBkZXRhY2gnKTtcblx0XHR9XG5cblx0XHR0aGlzLnByb3BzLm9uRGlhbG9nQ2FuY2VsKCk7XG5cdH1cblxuXHRnZXRGaWVsZHNldHMoKSB7XG5cdFx0dmFyIGZpZWxkc2V0cyA9IFtdLFxuXHRcdFx0YXR0YWNobWVudCA9IG51bGwsXG5cdFx0XHRmaWVsZHNldCwgZmllbGQsIGF0dHJpYnV0ZSwgaXRlbTtcblxuXHRcdGlmICh0aGlzLnByb3BzLmRhdGEuYXR0YWNobWVudF9pbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0YXR0YWNobWVudCA9IHRoaXMucHJvcHMubGliLnpvbmVHZXRBdHRhY2htZW50KFxuXHRcdFx0XHR0aGlzLnByb3BzLmRhdGEuem9uZV9pZCxcblx0XHRcdFx0dGhpcy5wcm9wcy5kYXRhLmF0dGFjaG1lbnRfaW5kZXhcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChhdHRyaWJ1dGUgaW4gdGhpcy5kcm9wbGV0LmVkaXRhYmxlKSB7XG5cdFx0XHRmaWVsZHNldCA9IHtcblx0XHRcdFx0a2V5OiBhdHRyaWJ1dGUsXG5cdFx0XHRcdGxlZ2VuZDogc2V0TGFiZWxzW2F0dHJpYnV0ZV0sXG5cdFx0XHRcdGZpZWxkczogW11cblx0XHRcdH07XG5cblx0XHRcdC8vIGFkZCBpbmRpZHVhbCBmaWVsZHMsIGRlcGVuZGluZyBvbiBlZGl0YWJsZSBhdHRyaWJ1dGUgdHlwZVxuXHRcdFx0aWYgKGF0dHJpYnV0ZSA9PT0gJ2F0dHJzJykge1xuXHRcdFx0XHQvLyB0aGUgJ2F0dHJzJyBhdHRyaWJ1dGUsIHdoaWNoIGNvbnRhaW5zIGtleS92YWx1ZSBwYWlyc1xuXHRcdFx0XHRmb3IgKGl0ZW0gaW4gdGhpcy5kcm9wbGV0LmVkaXRhYmxlW2F0dHJpYnV0ZV0pIHtcblx0XHRcdFx0XHRmaWVsZCA9IE9iamVjdC5kZWVwQXNzaWduKHt9LCB0aGlzLmRyb3BsZXQuZWRpdGFibGVbYXR0cmlidXRlXVtpdGVtXSk7XG5cblx0XHRcdFx0XHQvLyBwcmVzZXQgdmFsdWUgZnJvbSBhdHRhY2htZW50XG5cdFx0XHRcdFx0aWYgKGF0dGFjaG1lbnQgIT09IG51bGwgJiZcblx0XHRcdFx0XHRcdGF0dGFjaG1lbnQuZGF0YS5hdHRycyAmJlxuXHRcdFx0XHRcdFx0YXR0YWNobWVudC5kYXRhLmF0dHJzW2l0ZW1dKSB7XG5cdFx0XHRcdFx0XHRmaWVsZC52YWx1ZSA9IGF0dGFjaG1lbnQuZGF0YS5hdHRyc1tpdGVtXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmaWVsZHNldC5maWVsZHMucHVzaChuZXcgRm9ybUZpZWxkKFxuXHRcdFx0XHRcdFx0aXRlbSxcblx0XHRcdFx0XHRcdHRoaXMuZHJvcGxldC5lZGl0YWJsZVthdHRyaWJ1dGVdW2l0ZW1dLnR5cGUsXG5cdFx0XHRcdFx0XHRmaWVsZFxuXHRcdFx0XHRcdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBzdHJpbmcgYmFzZWQgYXR0cmlidXRlc1xuXHRcdFx0XHRmaWVsZCA9IE9iamVjdC5kZWVwQXNzaWduKHt9LCB0aGlzLmRyb3BsZXQuZWRpdGFibGVbYXR0cmlidXRlXSk7XG5cblx0XHRcdFx0Ly8gcHJlc2V0IHZhbHVlIGZyb20gYXR0YWNobWVudFxuXHRcdFx0XHRpZiAoYXR0YWNobWVudCAhPT0gbnVsbCAmJiBhdHRhY2htZW50LmRhdGFbYXR0cmlidXRlXSkge1xuXHRcdFx0XHRcdGZpZWxkLnZhbHVlID0gYXR0YWNobWVudC5kYXRhW2F0dHJpYnV0ZV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmaWVsZHNldC5maWVsZHMucHVzaChuZXcgRm9ybUZpZWxkKFxuXHRcdFx0XHRcdGF0dHJpYnV0ZSxcblx0XHRcdFx0XHR0aGlzLmRyb3BsZXQuZWRpdGFibGVbYXR0cmlidXRlXS50eXBlLFxuXHRcdFx0XHRcdGZpZWxkXG5cdFx0XHRcdCkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgZmllbGRzZXQgdG8gZm9ybVxuXHRcdFx0ZmllbGRzZXRzLnB1c2goZmllbGRzZXQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmaWVsZHNldHM7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0dmFyIGZpZWxkc2V0cyA9IHRoaXMuZ2V0RmllbGRzZXRzKCksXG5cdFx0XHRidXR0b25zID0gW10sXG5cdFx0XHRjbGFzc2VzID0gW1xuXHRcdFx0XHR0aGlzLnByb3BzLnNldHRpbmdzLmNsYXNzZXMuZGlhbG9nLmNvbnRhaW5lcixcblx0XHRcdFx0dGhpcy5wcm9wcy5zZXR0aW5ncy5jbGFzc2VzLnBvcHVwXG5cdFx0XHRdLFxuXHRcdFx0dGl0bGUsIG5vdGVzO1xuXG5cdFx0Y2xhc3Nlcy5wdXNoKCdkcm9wbGV0LScgKyB0aGlzLmRyb3BsZXQuZHJvcGxldFR5cGUpO1xuXG5cdFx0Ly8gYWRkIGNhbmNlbCBidXR0b24gKGZvciBldmVyeSBkaWFsb2cgdHlwZSlcblx0XHRidXR0b25zLnB1c2goe1xuXHRcdFx0dHlwZTogJ2NhbmNlbCcsXG5cdFx0XHRsYWJlbDogJ0NhbmNlbCdcblx0XHR9KTtcblxuXHRcdGlmICh0aGlzLnByb3BzLmRhdGEuYXR0YWNobWVudF9pbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0Ly8gZWRpdGluZyBhbiBleGlzdGluZyBkcm9wbGV0XG5cdFx0XHR0aXRsZSA9ICdFZGl0ICcgKyBoZWFkaW5nc0J5VHlwZVt0aGlzLmRyb3BsZXQuZHJvcGxldFR5cGVdLnRleHQ7XG5cblx0XHRcdGlmIChmaWVsZHNldHMubGVuZ3RoKSB7XG5cdFx0XHRcdG5vdGVzID0gW1xuXHRcdFx0XHRcdCdZb3UgY2FuIGVkaXQgdGhlIERyb3BsZXQgdXNpbmcgdGhlIGZpZWxkcyBiZWxvdy4gJyArXG5cdFx0XHRcdFx0XHQnQ2hhbmdlIHRoZSBiaXRzIHlvdSB3YW50IHRvIGN1c3RvbWlzZSBhbmQgdXNlIOKAnEFkZCBEcm9wbGV04oCdIHdoZW4geW914oCZcmUgZG9uZS4nXG5cdFx0XHRcdF07XG5cblx0XHRcdFx0YnV0dG9ucy5wdXNoKHtcblx0XHRcdFx0XHR0eXBlOiAnc3VibWl0Jyxcblx0XHRcdFx0XHRsYWJlbDogJ0VkaXQgRHJvcGxldCdcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub3RlcyA9IFtcblx0XHRcdFx0XHQnVGhlcmUgaXMgbm90aGluZyB0byBlZGl0IG9uIHRoaXMgRHJvcGxldCwgYnV0IHlvdSBjYW4gcmVtb3ZlIGl0ICcgK1xuXHRcdFx0XHRcdFx0J1dpdGggdGhlIOKAnFJlbW92ZSBEcm9wbGV04oCdIGJ1dHRvbi4nXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cblx0XHRcdGJ1dHRvbnMucHVzaCh7XG5cdFx0XHRcdHR5cGU6ICdyZW1vdmVfZHJvcGxldCcsXG5cdFx0XHRcdGxhYmVsOiAnUmVtb3ZlIERyb3BsZXQnLFxuXHRcdFx0XHRjbGFzc05hbWU6ICdkYW5nZXIgcHVsbC1sZWZ0Jyxcblx0XHRcdFx0ZGF0YToge1xuXHRcdFx0XHRcdGF0dGFjaG1lbnRfaW5kZXg6IHRoaXMucHJvcHMuZGF0YS5hdHRhY2htZW50X2luZGV4LFxuXHRcdFx0XHRcdHpvbmVfaWQ6IHRoaXMucHJvcHMuZGF0YS56b25lX2lkXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBhZGRpbmdcblx0XHRcdHRpdGxlID0gJ0FkZCAnICsgaGVhZGluZ3NCeVR5cGVbdGhpcy5kcm9wbGV0LmRyb3BsZXRUeXBlXS50ZXh0O1xuXHRcdFx0bm90ZXMgPSBbXG5cdFx0XHRcdCdZb3XigJl2ZSBmb3VuZCB0aGUgcmlnaHQgZHJvcCBwbGFjZSB0byBwdXQgdGhpcyBEcm9wbGV0ISAnLFxuXHRcdFx0XHQnRWRpdCBhbnl0aGluZyB5b3Ugd291bGQgbGlrZSB0byBjaGFuZ2UgYW5kIHRoZW4gdXNlIOKAnEVkaXQgRHJvcGxldOKAnS4nXG5cdFx0XHRdO1xuXHRcdFx0YnV0dG9ucyA9IGJ1dHRvbnMuY29uY2F0KHtcblx0XHRcdFx0dHlwZTogJ3N1Ym1pdCcsXG5cdFx0XHRcdGxhYmVsOiAnQWRkIERyb3BsZXQnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuam9pbignICcpfVxuXHRcdFx0XHRyZWY9e3RoaXMucHJvcHMucmVmQ29sbGVjdG9yfT5cblx0XHRcdFx0PERpYWxvZ0hlYWRpbmdcblx0XHRcdFx0XHR0aXRsZT17dGl0bGV9XG5cdFx0XHRcdFx0bm90ZXM9e25vdGVzfVxuXHRcdFx0XHRcdGljb25HbHlwaD17aGVhZGluZ3NCeVR5cGVbdGhpcy5kcm9wbGV0LmRyb3BsZXRUeXBlXS5pY29ufVxuXHRcdFx0XHRcdGNsYXNzTmFtZT17dGhpcy5wcm9wcy5zZXR0aW5ncy5jbGFzc2VzLmRpYWxvZy5oZWFkaW5nfS8+XG5cblx0XHRcdFx0PEZvcm1cblx0XHRcdFx0XHRmaWVsZFNldHM9e2ZpZWxkc2V0c31cblx0XHRcdFx0XHRidXR0b25zPXtidXR0b25zfVxuXHRcdFx0XHRcdG9uQnV0dG9uQ2xpY2s9e3RoaXMucHJvcHMub25CdXR0b25DbGlja31cblx0XHRcdFx0XHRvblN1Ym1pdD17dGhpcy5vbkRpYWxvZ0NvbXBsZXRlfVxuXHRcdFx0XHRcdG9uQ2FuY2VsPXt0aGlzLnByb3BzLm9uRGlhbG9nQ2FuY2VsfS8+XG5cdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cImFycm93XCIvPlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5EaWFsb2dFZGl0RHJvcGxldC5wcm9wVHlwZXMgPSBkaWFsb2c7XG5cbmV4cG9ydCBkZWZhdWx0IERpYWxvZ0VkaXREcm9wbGV0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy9kaWFsb2dzL0RpYWxvZ0VkaXREcm9wbGV0LmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBEaWFsb2dIZWFkaW5nIGZyb20gJy4vRGlhbG9nSGVhZGluZy5qc3gnO1xuaW1wb3J0IEZvcm0gZnJvbSAnLi4vdmlld3MvRm9ybS5qc3gnO1xuXG5pbXBvcnQgeyBkaWFsb2cgfSBmcm9tICcuLi8uLi9hc3NldHMvY29tbW9uLXByb3AtdHlwZXMnO1xuXG5jbGFzcyBEaWFsb2dHZW5lcmFsIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0dmFyIGJ1dHRvbnMgPSB0aGlzLnByb3BzLmRhdGEuYnV0dG9ucyxcblx0XHRcdGNsYXNzZXMgPSBbXG5cdFx0XHRcdHRoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5kaWFsb2cuY29udGFpbmVyLFxuXHRcdFx0XHR0aGlzLnByb3BzLnNldHRpbmdzLmNsYXNzZXMucG9wdXBcblx0XHRcdF07XG5cblx0XHRpZiAoIWJ1dHRvbnMgfHwgIWJ1dHRvbnMubGVuZ3RoKSB7XG5cdFx0XHRidXR0b25zID0gW3tcblx0XHRcdFx0dHlwZTogJ3N1Ym1pdCcsXG5cdFx0XHRcdGxhYmVsOiAnT0snXG5cdFx0XHR9XTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuam9pbignICcpfVxuXHRcdFx0XHRyZWY9e3RoaXMucHJvcHMucmVmQ29sbGVjdG9yfT5cblx0XHRcdFx0PERpYWxvZ0hlYWRpbmdcblx0XHRcdFx0XHR0aXRsZT17dGhpcy5wcm9wcy5kYXRhLnRpdGxlfVxuXHRcdFx0XHRcdG5vdGVzPXt0aGlzLnByb3BzLmRhdGEubWVzc2FnZX1cblx0XHRcdFx0XHRjbGFzc05hbWU9e3RoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5kaWFsb2cuaGVhZGluZ30vPlxuXG5cdFx0XHRcdDxGb3JtXG5cdFx0XHRcdFx0YnV0dG9ucz17YnV0dG9uc31cblx0XHRcdFx0XHRvbkJ1dHRvbkNsaWNrPXt0aGlzLnByb3BzLm9uQnV0dG9uQ2xpY2t9XG5cdFx0XHRcdFx0b25TdWJtaXQ9e3RoaXMucHJvcHMub25EaWFsb2dDb21wbGV0ZX1cblx0XHRcdFx0XHRvbkNhbmNlbD17dGhpcy5wcm9wcy5vbkRpYWxvZ0NhbmNlbH0vPlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJhcnJvd1wiLz5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuRGlhbG9nR2VuZXJhbC5wcm9wVHlwZXMgPSBkaWFsb2c7XG5cbmV4cG9ydCBkZWZhdWx0IERpYWxvZ0dlbmVyYWw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2RpYWxvZ3MvRGlhbG9nR2VuZXJhbC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuXG52YXIgQnV0dG9uID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0dmFyIHR5cGUgPSAocHJvcHMudHlwZSA9PT0gJ3N1Ym1pdCcpID8gJ3N1Ym1pdCcgOiAnYnV0dG9uJyxcblx0XHRjbGFzc2VzID0gWydidXR0b24nLCBwcm9wcy5jbGFzc05hbWVdLFxuXHRcdG9uQ2xpY2sgPSBwcm9wcy5vbkNsaWNrO1xuXG5cdGlmIChwcm9wcy50eXBlID09PSAnY2FuY2VsJykge1xuXHRcdGNsYXNzZXMucHVzaCgnY2FuY2VsJyk7XG5cdH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ3N1Ym1pdCcpIHtcblx0XHRjbGFzc2VzLnB1c2goJ3ByaW1hcnknKTtcblx0fVxuXG5cdHJldHVybiAoXG5cdFx0PGJ1dHRvblxuXHRcdFx0cmVmPXtwcm9wcy5yZWZDb2xsZWN0b3J9XG5cdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMuam9pbignICcpfVxuXHRcdFx0b25DbGljaz17b25DbGlja31cblx0XHRcdHR5cGU9e3R5cGV9PlxuXHRcdFx0PHNwYW4+XG5cdFx0XHRcdHtwcm9wcy5sYWJlbH1cblx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwiY2lyY2xlXCI+PC9zcGFuPlxuXHRcdFx0PC9zcGFuPlxuXHRcdDwvYnV0dG9uPlxuXHQpO1xufTtcblxuQnV0dG9uLnByb3BUeXBlcyA9IHtcblx0dHlwZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuXHRsYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuXHRjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cdG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuXHRyZWZDb2xsZWN0b3I6IFByb3BUeXBlcy5mdW5jLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9CdXR0b24uanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBjb2xsZWN0UmVmIH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcbmltcG9ydCBEcm9wWm9uZSBmcm9tICcuLi8uLi9saWIvRHJvcFpvbmUnO1xuaW1wb3J0IERyb3Bab25lQXR0YWNobWVudExpc3QgZnJvbSAnLi9Ecm9wWm9uZUF0dGFjaG1lbnRMaXN0LmpzeCc7XG5pbXBvcnQgRHJvcFpvbmVUYXJnZXQgZnJvbSAnLi9Ecm9wWm9uZVRhcmdldC5qc3gnO1xuXG5jbGFzcyBEcm9wWm9uZUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0dGhpcy5teXJlZnMgPSB7fTtcblx0XHR0aGlzLm9uRXZlbnQgPSB0aGlzLm9uRXZlbnQuYmluZCh0aGlzKTtcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbk1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLnByb3BzLm9uTW91bnQoJ2Ryb3B6b25lJywgdGhpcy5wcm9wcy56b25lLmlkKTtcblx0XHR9XG5cdH1cblxuXHRvbkV2ZW50KGV2ZW50KSB7XG5cdFx0aWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5wcm9wcy5vbkV2ZW50KGV2ZW50LCB0aGlzLnByb3BzLnpvbmUpO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHZhciBrZXkgPSB0aGlzLnByb3BzLnpvbmUuaWQgKyAnLXpvbmUnLFxuXHRcdFx0Y2xhc3NOYW1lcyA9IFt0aGlzLnByb3BzLnNldHRpbmdzLmNsYXNzZXMuZHJvcHpvbmUubm9kZV07XG5cblx0XHRpZiAodGhpcy5wcm9wcy5jbGFzc05hbWUgIT09ICcnKSB7XG5cdFx0XHRjbGFzc05hbWVzLnB1c2godGhpcy5wcm9wcy5jbGFzc05hbWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8c3BhblxuXHRcdFx0XHRrZXk9e2tleX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc05hbWVzLmpvaW4oJyAnKX1cblx0XHRcdFx0cmVmPXtjb2xsZWN0UmVmKHRoaXMucHJvcHMsIFsnZHJvcHpvbmUnXSwgdGhpcy5wcm9wcy56b25lLmlkKX1cblx0XHRcdFx0ZGF0YS1pZD17dGhpcy5wcm9wcy56b25lLmlkfVxuXHRcdFx0XHRkYXRhLWF0dGFjaG1lbnQ9e3RoaXMucHJvcHMuem9uZS5hdHRhY2htZW50SWR9PlxuXHRcdFx0XHQ8RHJvcFpvbmVBdHRhY2htZW50TGlzdFxuXHRcdFx0XHRcdHpvbmU9e3RoaXMucHJvcHMuem9uZX1cblx0XHRcdFx0XHRhY3RpdmVBdHRhY2htZW50cz17dGhpcy5wcm9wcy5hY3RpdmVBdHRhY2htZW50c31cblx0XHRcdFx0XHRvbkF0dGFjaG1lbnRDbGljaz17dGhpcy5wcm9wcy5vbkF0dGFjaG1lbnRDbGlja31cblx0XHRcdFx0XHRsaWI9e3RoaXMucHJvcHMubGlifS8+XG5cdFx0XHRcdDxEcm9wWm9uZVRhcmdldFxuXHRcdFx0XHRcdHpvbmU9e3RoaXMucHJvcHMuem9uZX1cblx0XHRcdFx0XHRzZXR0aW5ncz17dGhpcy5wcm9wcy5zZXR0aW5nc31cblx0XHRcdFx0XHRhY3RpdmVBdHRhY2htZW50cz17dGhpcy5wcm9wcy5hY3RpdmVBdHRhY2htZW50c31cblx0XHRcdFx0XHRyZWZDb2xsZWN0b3I9e3RoaXMucHJvcHMucmVmQ29sbGVjdG9yfVxuXHRcdFx0XHRcdG9uRXZlbnQ9e3RoaXMub25FdmVudH0vPlxuXHRcdFx0PC9zcGFuPlxuXHRcdCk7XG5cdH1cbn1cblxuRHJvcFpvbmVDb21wb25lbnQucHJvcFR5cGVzID0ge1xuXHR6b25lOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEcm9wWm9uZSkuaXNSZXF1aXJlZCxcblx0Y2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRzZXR0aW5nczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRhY3RpdmVBdHRhY2htZW50czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG5cdG9uTW91bnQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdG9uQXR0YWNobWVudENsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRvbkV2ZW50OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRyZWZDb2xsZWN0b3I6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdGxpYjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEcm9wWm9uZUNvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvRHJvcFpvbmUuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgVGVtcGxhdGUgZnJvbSAnLi4vLi4vbGliL1RlbXBsYXRlJztcbmltcG9ydCBEcm9wbGV0IGZyb20gJy4uLy4uL2xpYi9Ecm9wbGV0JztcbmltcG9ydCBEcm9wWm9uZSBmcm9tICcuLi8uLi9saWIvRHJvcFpvbmUnO1xuXG5jbGFzcyBEcm9wWm9uZUF0dGFjaG1lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuXHR9XG5cblx0b25DbGljayhldmVudCkge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR0aGlzLnByb3BzLm9uQ2xpY2soXG5cdFx0XHRldmVudCxcblx0XHRcdHRoaXMucHJvcHMuZHJvcGxldCxcblx0XHRcdHRoaXMucHJvcHMuYXR0YWNobWVudEluZGV4XG5cdFx0KTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2Ryb3B6b25lLWF0dGFjaG1lbnQnLFxuXHRcdFx0ZGF0YTtcblxuXHRcdC8vIG1lcmdlIGVkaXRlZCBkYXRhIHdpdGggZHJvcGxldCBkYXRhXG5cdFx0ZGF0YSA9IE9iamVjdC5kZWVwQXNzaWduKHt9LCB0aGlzLnByb3BzLmRyb3BsZXQuZGF0YSwgdGhpcy5wcm9wcy5kYXRhKTtcblxuXHRcdC8vIHNldCBjbGFzc25hbWVcblx0XHRjbGFzc05hbWUgKz0gJyAnICsgdGhpcy5wcm9wcy5kcm9wbGV0LmRyb3BsZXRUeXBlO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxzcGFuXG5cdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLm9uQ2xpY2t9PlxuXHRcdFx0XHR7VGVtcGxhdGUucmVuZGVyRHJvcGxldCh0aGlzLnByb3BzLmRyb3BsZXQsIGRhdGEsIHRoaXMucHJvcHMuem9uZSwgZmFsc2UpfVxuXHRcdFx0PC9zcGFuPlxuXHRcdCk7XG5cdH1cbn1cblxuRHJvcFpvbmVBdHRhY2htZW50LnByb3BUeXBlcyA9IHtcblx0ZHJvcGxldDogUHJvcFR5cGVzLmluc3RhbmNlT2YoRHJvcGxldCkuaXNSZXF1aXJlZCxcblx0em9uZTogUHJvcFR5cGVzLmluc3RhbmNlT2YoRHJvcFpvbmUpLmlzUmVxdWlyZWQsXG5cdGF0dGFjaG1lbnRJbmRleDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuXHRvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRkYXRhOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEcm9wWm9uZUF0dGFjaG1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL0Ryb3Bab25lQXR0YWNobWVudC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBEcm9wWm9uZSBmcm9tICcuLi8uLi9saWIvRHJvcFpvbmUnO1xuaW1wb3J0IERyb3Bab25lQXR0YWNobWVudCBmcm9tICcuL0Ryb3Bab25lQXR0YWNobWVudC5qc3gnO1xuXG5jbGFzcyBEcm9wWm9uZUF0dGFjaG1lbnRMaXN0IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLmF0dGFjaG1lbnRDbGljayA9IHRoaXMuYXR0YWNobWVudENsaWNrLmJpbmQodGhpcyk7XG5cdH1cblxuXHRhdHRhY2htZW50Q2xpY2soZXZlbnQsIGRyb3BsZXQsIGF0dGFjaG1lbnRJbmRleCkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbkF0dGFjaG1lbnRDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhpcy5wcm9wcy5vbkF0dGFjaG1lbnRDbGljayhkcm9wbGV0LCB0aGlzLnByb3BzLnpvbmUsIGF0dGFjaG1lbnRJbmRleCk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyQWN0aXZlQXR0YWNobWVudHMoKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gW107XG5cblx0XHR0aGlzLnByb3BzLmFjdGl2ZUF0dGFjaG1lbnRzLmZvckVhY2goKGF0dGFjaG1lbnQsIGluZGV4KSA9PiB7XG5cdFx0XHRjaGlsZHJlbi5wdXNoKFxuXHRcdFx0XHQ8RHJvcFpvbmVBdHRhY2htZW50XG5cdFx0XHRcdFx0a2V5PXthdHRhY2htZW50LmRyb3BsZXRfaWQgKyAnLWF0dGFjaG1lbnQtJyArIGluZGV4fVxuXHRcdFx0XHRcdGF0dGFjaG1lbnRJbmRleD17aW5kZXh9XG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5hdHRhY2htZW50Q2xpY2t9XG5cdFx0XHRcdFx0ZHJvcGxldD17dGhpcy5wcm9wcy5saWIuZ2V0RHJvcGxldEJ5SWQoYXR0YWNobWVudC5kcm9wbGV0X2lkKX1cblx0XHRcdFx0XHR6b25lPXt0aGlzLnByb3BzLnpvbmV9XG5cdFx0XHRcdFx0ZGF0YT17YXR0YWNobWVudC5kYXRhfS8+XG5cdFx0XHQpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNoaWxkcmVuO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8c3BhblxuXHRcdFx0XHRjbGFzc05hbWU9XCJhdHRhY2htZW50c1wiPlxuXHRcdFx0XHR7dGhpcy5yZW5kZXJBY3RpdmVBdHRhY2htZW50cygpfVxuXHRcdFx0PC9zcGFuPlxuXHRcdCk7XG5cdH1cbn1cblxuRHJvcFpvbmVBdHRhY2htZW50TGlzdC5wcm9wVHlwZXMgPSB7XG5cdHpvbmU6IFByb3BUeXBlcy5pbnN0YW5jZU9mKERyb3Bab25lKS5pc1JlcXVpcmVkLFxuXHRhY3RpdmVBdHRhY2htZW50czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG5cdG9uQXR0YWNobWVudENsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRsaWI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRHJvcFpvbmVBdHRhY2htZW50TGlzdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvRHJvcFpvbmVBdHRhY2htZW50TGlzdC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IGNvbGxlY3RSZWYgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IERyb3Bab25lIGZyb20gJy4uLy4uL2xpYi9Ecm9wWm9uZSc7XG5cbmNsYXNzIERyb3Bab25lVGFyZ2V0IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLm9uRXZlbnQgPSB0aGlzLm9uRXZlbnQuYmluZCh0aGlzKTtcblx0fVxuXG5cdG9uRXZlbnQoZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR0aGlzLnByb3BzLm9uRXZlbnQoZXZlbnQsIHRoaXMucHJvcHMuem9uZSk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0dmFyIGtleSA9IHRoaXMucHJvcHMuem9uZS5pZCArICctdGFyZ2V0Jyxcblx0XHRcdGNsYXNzTmFtZXMgPSBbdGhpcy5wcm9wcy5zZXR0aW5ncy5jbGFzc2VzLmRyb3B6b25lX3RhcmdldF07XG5cblx0XHRpZiAodGhpcy5wcm9wcy5hY3RpdmVBdHRhY2htZW50cy5sZW5ndGggPj0gdGhpcy5wcm9wcy56b25lLm1heEF0dGFjaG1lbnRzKSB7XG5cdFx0XHRjbGFzc05hbWVzLnB1c2godGhpcy5wcm9wcy5zZXR0aW5ncy5jbGFzc2VzLmhpZGRlbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInRhcmdldC1vdXRlclwiPlxuXHRcdFx0XHQ8c3BhbiBrZXk9e2tleX1cblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLm9uRXZlbnR9XG5cdFx0XHRcdFx0cmVmPXtjb2xsZWN0UmVmKHRoaXMucHJvcHMsIFsnZHJvcHpvbmVfdGFyZ2V0J10sIHRoaXMucHJvcHMuem9uZS5pZCl9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc05hbWVzLmpvaW4oJyAnKX0+XG5cdFx0XHRcdFx0XHQ8Yj57dGhpcy5wcm9wcy5zZXR0aW5ncy5kcm9wWm9uZS5sYWJlbH08L2I+XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0PC9zcGFuPlxuXHRcdCk7XG5cdH1cbn1cblxuRHJvcFpvbmVUYXJnZXQucHJvcFR5cGVzID0ge1xuXHR6b25lOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEcm9wWm9uZSkuaXNSZXF1aXJlZCxcblx0c2V0dGluZ3M6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblx0YWN0aXZlQXR0YWNobWVudHM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuXHRvbkV2ZW50OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRyZWZDb2xsZWN0b3I6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEcm9wWm9uZVRhcmdldDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvRHJvcFpvbmVUYXJnZXQuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBjb2xsZWN0UmVmIH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcbmltcG9ydCBEcm9wbGV0IGZyb20gJy4uLy4uL2xpYi9Ecm9wbGV0JztcbmltcG9ydCBUZW1wbGF0ZSBmcm9tICcuLi8uLi9saWIvVGVtcGxhdGUnO1xuaW1wb3J0IHsgR0xZUEhTLCBJY29uIH0gZnJvbSAnLi9JY29uLmpzeCc7XG5cbmNvbnN0IGRyb3BsZXRUeXBlVG9HbHlwaHMgPSB7XG5cdCd0ZXh0JzogR0xZUEhTLlRFWFQsXG5cdCdlbGVtZW50JzogR0xZUEhTLlRBRyxcblx0J2F0dHJpYnV0ZSc6IEdMWVBIUy5QVVpaTEVfUElFQ0Vcbn07XG5cbmNsYXNzIERyb3BsZXRDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMudG9vbHRpcF9jYWNoZSA9ICcnO1xuXHRcdHRoaXMudWkgPSB7XG5cdFx0XHRkcm9wbGV0OiBudWxsXG5cdFx0fTtcblxuXHRcdHRoaXMub25FdmVudCA9IHRoaXMub25FdmVudC5iaW5kKHRoaXMpO1xuXHR9XG5cblx0cmVmQ29sbGVjdG9yKHJlZikge1xuXHRcdHZhciBjb2xsZWN0b3IgPSBjb2xsZWN0UmVmKHRoaXMucHJvcHMsIFsnZHJvcGxldCddLCB0aGlzLnByb3BzLmRyb3BsZXQuaWQpO1xuXHRcdHRoaXMudWkuZHJvcGxldCA9IHJlZjtcblx0XHRjb2xsZWN0b3IocmVmKTtcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbk1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLnByb3BzLm9uTW91bnQoJ2Ryb3BsZXQnLCB0aGlzLnByb3BzLmRyb3BsZXQuaWQpO1xuXHRcdH1cblx0fVxuXG5cdG9uRXZlbnQoZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZW50ZXInIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdFx0aWYgKHRoaXMudG9vbHRpcF9jYWNoZSA9PT0gJycpIHtcblx0XHRcdFx0dGhpcy50b29sdGlwX2NhY2hlICs9XG5cdFx0XHRcdFx0Jzxjb2RlPicgK1xuXHRcdFx0XHRcdFRlbXBsYXRlLmVudGl0aWVzKFxuXHRcdFx0XHRcdFx0VGVtcGxhdGUucmVuZGVyRHJvcGxldChcblx0XHRcdFx0XHRcdFx0dGhpcy5wcm9wcy5kcm9wbGV0LFxuXHRcdFx0XHRcdFx0XHR0aGlzLnByb3BzLmRyb3BsZXQuZGF0YSxcblx0XHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdFx0ZmFsc2Vcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpICtcblx0XHRcdFx0XHQnPC9jb2RlPic7XG5cblx0XHRcdFx0aWYgKHRoaXMucHJvcHMuZHJvcGxldC5ndWlkYW5jZSkge1xuXHRcdFx0XHRcdHRoaXMudG9vbHRpcF9jYWNoZSArPSB0aGlzLnByb3BzLmRyb3BsZXQuZ3VpZGFuY2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnRvb2x0aXBfY2FjaGUgKz0gJzxwPicgK1xuXHRcdFx0XHRcdCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgPyAnVGFwJyA6ICdDbGljaycpICtcblx0XHRcdFx0XHQnIG9uIHRoZSBEcm9wbGV0IHRvIHBsYWNlIGl0IGluIHRoZSB0ZW1wbGF0ZS48L3A+Jztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnByb3BzLm9uRXZlbnQoZXZlbnQsIHRoaXMucHJvcHMuZHJvcGxldCwge1xuXHRcdFx0cmVmOiB0aGlzLnVpLmRyb3BsZXQsXG5cdFx0XHR0aXRsZTogdGhpcy5wcm9wcy5kcm9wbGV0Lm5hbWUsXG5cdFx0XHRjb250ZW50OiB0aGlzLnRvb2x0aXBfY2FjaGUsXG5cdFx0XHRpY29uR2x5cGg6IEdMWVBIUy5MSUdIVEJVTEJcblx0XHR9KTtcblx0fVxuXG5cdHNob3dEZXNjcmlwdGlvbihzaG93PXRydWUpIHtcblx0XHRjb25zb2xlLmxvZygnc2hvd0Rlc2NyaXB0aW9uJywgdGhpcy5wcm9wcy5kcm9wbGV0LmlkLCBzaG93KTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtcblx0XHRcdHRoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5kcm9wbGV0Lm5vZGUsXG5cdFx0XHQndHlwZS0nICsgdGhpcy5wcm9wcy5kcm9wbGV0LmRyb3BsZXRUeXBlXG5cdFx0XTtcblxuXHRcdGlmICh0aGlzLnByb3BzLmFjdGl2ZSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKHRoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5kcm9wbGV0LmFjdGl2ZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0aWQ9e3RoaXMucHJvcHMuZHJvcGxldC5pZH1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLmpvaW4oJyAnKX1cblx0XHRcdFx0b25DbGljaz17dGhpcy5vbkV2ZW50fVxuXHRcdFx0XHRvbk1vdXNlRW50ZXI9e3RoaXMub25FdmVudH1cblx0XHRcdFx0b25Nb3VzZUxlYXZlPXt0aGlzLm9uRXZlbnR9XG5cdFx0XHRcdG9uVG91Y2hTdGFydD17dGhpcy5vbkV2ZW50fVxuXHRcdFx0XHRvblRvdWNoRW5kPXt0aGlzLm9uRXZlbnR9XG5cdFx0XHRcdHJlZj17dGhpcy5yZWZDb2xsZWN0b3IuYmluZCh0aGlzKX0+XG5cdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cImxhYmVsXCI+XG5cdFx0XHRcdFx0PEljb24gZ2x5cGg9e2Ryb3BsZXRUeXBlVG9HbHlwaHNbdGhpcy5wcm9wcy5kcm9wbGV0LmRyb3BsZXRUeXBlXX0vPlxuXHRcdFx0XHRcdHt0aGlzLnByb3BzLmRyb3BsZXQubmFtZX1cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5Ecm9wbGV0Q29tcG9uZW50LnByb3BUeXBlcyA9IHtcblx0YWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcblx0c2V0dGluZ3M6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblx0bGliOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cdHJlZkNvbGxlY3RvcjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblx0ZHJvcGxldDogUHJvcFR5cGVzLmluc3RhbmNlT2YoRHJvcGxldCkuaXNSZXF1aXJlZCxcblx0b25Nb3VudDogUHJvcFR5cGVzLmZ1bmMsXG5cdG9uRXZlbnQ6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEcm9wbGV0Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9Ecm9wbGV0LmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEZvcm1GaWVsZCBmcm9tICcuLi8uLi9saWIvRm9ybUZpZWxkJztcbmltcG9ydCBUZXh0RmllbGQgZnJvbSAnLi9maWVsZHMvVGV4dEZpZWxkLmpzeCc7XG5pbXBvcnQgRHJvcERvd24gZnJvbSAnLi9maWVsZHMvRHJvcERvd24uanN4JztcblxuY29uc3QgRmllbGRDb21wb25lbnRzID0ge1xuXHQndGV4dCc6IFRleHRGaWVsZCxcblx0J2Ryb3Bkb3duJzogRHJvcERvd25cbn07XG5cbmNsYXNzIEZpZWxkc2V0IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHR2YXIgZm9ybVZhbHVlcyA9IHt9O1xuXG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0Ly8gc2V0IGRlZmF1bHQgc3RhdGUgZm9yIGZpZWxkcyBiYXNlZCBvbiBvcmlnaW5hbCB2YWx1ZXNcblx0XHR0aGlzLnByb3BzLmZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT5cblx0XHRcdChmb3JtVmFsdWVzW2ZpZWxkLm5hbWVdID0gZmllbGQudmFsdWUgfHwgJycpXG5cdFx0KTtcblxuXHRcdC8vIHNldCBkZWZhdWx0IGZvcm0gdmFsdWUgc3RhdGVcblx0XHR0aGlzLnN0YXRlID0ge1xuXHRcdFx0Zm9ybVZhbHVlc1xuXHRcdH07XG5cblx0XHQvLyBiaW5kIGZ1bmN0aW9ucyBmb3IgZXZlbnRzXG5cdFx0dGhpcy5lbGVtZW50Q2hhbmdlID0gdGhpcy5lbGVtZW50Q2hhbmdlLmJpbmQodGhpcyk7XG5cdH1cblxuXHRjb2xsZWN0UmVmKGtleSkge1xuXHRcdHJldHVybiBmdW5jdGlvbihyZWYpIHtcblx0XHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5yZWZDb2xsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhpcy5wcm9wcy5yZWZDb2xsZWN0b3Ioa2V5LCByZWYpO1xuXHRcdFx0fVxuXHRcdH0uYmluZCh0aGlzKTtcblx0fVxuXG5cdGZpZWxkcygpIHtcblx0XHR2YXIgQ29tcG9uZW50LFxuXHRcdFx0b3V0cHV0ID0gW107XG5cblx0XHR0aGlzLnByb3BzLmZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuXHRcdFx0dmFyIGtleSA9ICdmaWVsZC0nICsgZmllbGQubmFtZTtcblxuXHRcdFx0Q29tcG9uZW50ID0gRmllbGRDb21wb25lbnRzW2ZpZWxkLnR5cGVdO1xuXG5cdFx0XHRzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcblx0XHRcdGNhc2UgJ3RleHQnOlxuXHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHQ8Q29tcG9uZW50IGtleT17a2V5fVxuXHRcdFx0XHRcdFx0cmVmQ29sbGVjdG9yPXt0aGlzLmNvbGxlY3RSZWYoa2V5KX1cblx0XHRcdFx0XHRcdGZpZWxkPXtmaWVsZH1cblx0XHRcdFx0XHRcdG9uQ2hhbmdlPXt0aGlzLmVsZW1lbnRDaGFuZ2V9XG5cdFx0XHRcdFx0XHR2YWx1ZT17dGhpcy5zdGF0ZS5mb3JtVmFsdWVzW2ZpZWxkLm5hbWVdfS8+XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdkcm9wZG93bic6XG5cdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdDxDb21wb25lbnQga2V5PXtrZXl9XG5cdFx0XHRcdFx0XHRyZWZDb2xsZWN0b3I9e3RoaXMuY29sbGVjdFJlZihrZXkpfVxuXHRcdFx0XHRcdFx0ZmllbGQ9e2ZpZWxkfVxuXHRcdFx0XHRcdFx0b25DaGFuZ2U9e3RoaXMuZWxlbWVudENoYW5nZX1cblx0XHRcdFx0XHRcdHZhbHVlPXt0aGlzLnN0YXRlLmZvcm1WYWx1ZXNbZmllbGQubmFtZV19Lz5cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRlbGVtZW50Q2hhbmdlKGV2ZW50KSB7XG5cdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCxcblx0XHRcdGZvcm1WYWx1ZXMgPSBPYmplY3QuZGVlcEFzc2lnbih7fSwgdGhpcy5zdGF0ZS5mb3JtVmFsdWVzKTtcblxuXHRcdGZvcm1WYWx1ZXNbdGFyZ2V0Lm5hbWVdID0gdGFyZ2V0LnZhbHVlO1xuXG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRmb3JtVmFsdWVzOiBmb3JtVmFsdWVzXG5cdFx0fSk7XG5cblx0XHR0aGlzLnByb3BzLm9uRmllbGRVcGRhdGUodGhpcy5wcm9wcy5zZXQsIHRhcmdldC5uYW1lLCB0YXJnZXQudmFsdWUsIGZvcm1WYWx1ZXMpO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZmllbGRzZXQ+XG5cdFx0XHRcdDxsZWdlbmQ+e3RoaXMucHJvcHMubGVnZW5kfTwvbGVnZW5kPlxuXHRcdFx0XHR7dGhpcy5maWVsZHMoKX1cblx0XHRcdDwvZmllbGRzZXQ+XG5cdFx0KTtcblx0fVxufVxuXG5GaWVsZHNldC5wcm9wVHlwZXMgPSB7XG5cdHJlZkNvbGxlY3RvcjogUHJvcFR5cGVzLmZ1bmMsXG5cdHNldDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuXHRvbkZpZWxkVXBkYXRlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRsZWdlbmQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cdGZpZWxkczogUHJvcFR5cGVzLmFycmF5T2YoUmVhY3QuUHJvcFR5cGVzLmluc3RhbmNlT2YoRm9ybUZpZWxkKSlcbn07XG5cbkZpZWxkc2V0LmRlZmF1bHRQcm9wcyA9IHtcblx0b25GaWVsZFVwZGF0ZTogKCkgPT4ge30sXG5cdGZpZWxkczoge31cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZpZWxkc2V0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9GaWVsZHNldC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBUb29sYmFyIGZyb20gJy4vVG9vbGJhci5qc3gnO1xuXG5jbGFzcyBIZWFkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGhlYWRlcj5cblx0XHRcdFx0e3RoaXMucHJvcHMuY2hpbGRyZW59XG5cblx0XHRcdFx0PFRvb2xiYXJcblx0XHRcdFx0XHRidXR0b25zPXt0aGlzLnByb3BzLnNldHRpbmdzLnRvb2xiYXJ9XG5cdFx0XHRcdFx0dG91cl9zdGFnZT17dGhpcy5wcm9wcy50b3VyX3N0YWdlfVxuXHRcdFx0XHRcdGRpYWxvZ19tb2RlPXt0aGlzLnByb3BzLmRpYWxvZ19tb2RlfVxuXHRcdFx0XHRcdHNldHRpbmdzPXt0aGlzLnByb3BzLnNldHRpbmdzfVxuXHRcdFx0XHRcdG9uQnV0dG9uQ2xpY2s9e3RoaXMucHJvcHMub25CdXR0b25DbGlja31cblx0XHRcdFx0XHRsaWI9e3RoaXMucHJvcHMubGlifS8+XG5cdFx0XHQ8L2hlYWRlcj5cblx0XHQpO1xuXHR9XG59XG5cbkhlYWRlci5wcm9wVHlwZXMgPSB7XG5cdC8vIGZyb20gSGVhZGVyQ29udGFpbmVyXG5cdHRvdXJfc3RhZ2U6IFByb3BUeXBlcy5hbnksXG5cdGRpYWxvZ19tb2RlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG5cdC8vIGZyb20gQ2FudmFzXG5cdGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblx0c2V0dGluZ3M6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblx0b25CdXR0b25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG5cdGxpYjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBIZWFkZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL0hlYWRlci5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRHJvcGxldCBmcm9tICcuL0Ryb3BsZXQuanN4JztcblxuY2xhc3MgUGFsbGV0IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cdH1cblxuXHRnZXRJdGVtcygpIHtcblx0XHR2YXIgaXRlbXMgPSBbXTtcblxuXHRcdGlmICh0aGlzLnByb3BzLmRhdGEucGFsbGV0KSB7XG5cdFx0XHR0aGlzLnByb3BzLmRhdGEucGFsbGV0LmZvckVhY2goKGRyb3BsZXQpID0+IHtcblx0XHRcdFx0aXRlbXMucHVzaChcblx0XHRcdFx0XHQ8RHJvcGxldCBkcm9wbGV0PXtkcm9wbGV0fVxuXHRcdFx0XHRcdFx0YWN0aXZlPXt0aGlzLnByb3BzLmFjdGl2ZURyb3BsZXRJZCA9PT0gZHJvcGxldC5pZH1cblx0XHRcdFx0XHRcdHNldHRpbmdzPXt0aGlzLnByb3BzLnNldHRpbmdzfVxuXHRcdFx0XHRcdFx0bGliPXt0aGlzLnByb3BzLmxpYn1cblx0XHRcdFx0XHRcdG9uTW91bnQ9e3RoaXMucHJvcHMub25Nb3VudH1cblx0XHRcdFx0XHRcdG9uRXZlbnQ9e3RoaXMucHJvcHMub25Ecm9wbGV0RXZlbnR9XG5cdFx0XHRcdFx0XHRyZWZDb2xsZWN0b3I9e3RoaXMucHJvcHMucmVmQ29sbGVjdG9yfVxuXHRcdFx0XHRcdFx0a2V5PXtkcm9wbGV0LmlkfS8+XG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxzZWN0aW9uIGNsYXNzTmFtZT1cInBhbGxldFwiPlxuXHRcdFx0XHQ8Zm9ybT5cblx0XHRcdFx0XHR7dGhpcy5nZXRJdGVtcy5hcHBseSh0aGlzKX1cblx0XHRcdFx0PC9mb3JtPlxuXHRcdFx0PC9zZWN0aW9uPlxuXHRcdCk7XG5cdH1cbn1cblxuUGFsbGV0LnByb3BUeXBlcyA9IHtcblx0Ly8gZnJvbSBQYWxsZXRDb250YWluZXJcblx0YWN0aXZlRHJvcGxldElkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cblx0Ly8gZnJvbSBDYW52YXNcblx0ZGF0YTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRzZXR0aW5nczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRsaWI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblx0b25Nb3VudDogUHJvcFR5cGVzLmZ1bmMsXG5cdG9uRHJvcGxldEV2ZW50OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRyZWZDb2xsZWN0b3I6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5QYWxsZXQuZGVmYXVsdFByb3BzID0ge1xuXHRkYXRhOiB7XG5cdFx0cGFsbGV0OiBbXVxuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQYWxsZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL1BhbGxldC5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IGNvbGxlY3RSZWYgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IERyb3Bab25lIGZyb20gJy4vRHJvcFpvbmUuanN4JztcblxuY2xhc3MgVGVtcGxhdGUgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbk1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLnByb3BzLm9uTW91bnQoJ3RlbXBsYXRlJyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVzZXMgc3RhdGUgKGZyb20gcHJvcHMuem9uZXMpIHRvIGFzY2VydGFpbiB0aGUgYXR0YWNobWVudHNcblx0ICovXG5cdGdldFpvbmVBdHRhY2htZW50cyhkcm9wem9uZV9pZCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnpvbmVzICYmIHRoaXMucHJvcHMuem9uZXNbZHJvcHpvbmVfaWRdKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wcm9wcy56b25lc1tkcm9wem9uZV9pZF0uYXR0YWNobWVudHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIENvbXB1dGVzIHRoZSBjb3JyZWN0IHBvdGVudGlhbCBjbGFzc05hbWUgZm9yIHRoZSBkcm9wIHpvbmUgYmFzZWQgb246XG5cdCAqIC0gVGhlIGFjdGl2ZSBEcm9wbGV0IElEXG5cdCAqIC0gV2hldGhlciBvciBub3QgdGhpcyBkcm9wIHpvbmUgd2lsbCBhY2NlcHQgdGhlIGRyb3BsZXRcblx0ICovXG5cdGdldERyb3Bab25lQ2xhc3NOYW1lcyhkcm9wem9uZSkge1xuXHRcdHZhciBjbGFzc2VzID0gW10sXG5cdFx0XHRkcm9wbGV0O1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuYWN0aXZlRHJvcGxldElEICE9PSAnJyAmJlxuXHRcdFx0KGRyb3BsZXQgPSB0aGlzLnByb3BzLmxpYi5nZXREcm9wbGV0QnlJZCh0aGlzLnByb3BzLmFjdGl2ZURyb3BsZXRJRCkpKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2godGhpcy5wcm9wcy5zZXR0aW5ncy5jbGFzc2VzLmRyb3B6b25lLnBvc3NpYmxlX3RhcmdldCk7XG5cdFx0XHRjbGFzc2VzLnB1c2goXG5cdFx0XHRcdHRoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5kcm9wem9uZVtcblx0XHRcdFx0XHQoXG5cdFx0XHRcdFx0XHR0aGlzLnByb3BzLmxpYi5pc1ZhbGlkRHJvcChkcm9wbGV0LCBkcm9wem9uZSkgP1xuXHRcdFx0XHRcdFx0J3dpbGxfYWNjZXB0JyA6ICd3aWxsX2RlY2xpbmUnXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRdXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gY2xhc3Nlcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0fVxuXG5cdGdldFRlbXBsYXRlKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IFtdO1xuXG5cdFx0dGhpcy5wcm9wcy50ZW1wbGF0ZS5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuXHRcdFx0dmFyIGtleTtcblxuXHRcdFx0c3dpdGNoIChub2RlLnR5cGUpIHtcblx0XHRcdGNhc2UgJ3RleHQnOlxuXHRcdFx0XHRrZXkgPSAnZnJhZ21lbnQtJyArIGluZGV4O1xuXG5cdFx0XHRcdGNoaWxkcmVuLnB1c2goXG5cdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdGtleT17a2V5fVxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXt0aGlzLnByb3BzLnNldHRpbmdzLmNsYXNzZXMuY29tcG9uZW50fT57bm9kZS5jb250ZW50fTwvc3Bhbj5cblx0XHRcdFx0KTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ2Ryb3B6b25lJzpcblx0XHRcdFx0Y2hpbGRyZW4ucHVzaChcblx0XHRcdFx0XHQ8RHJvcFpvbmVcblx0XHRcdFx0XHRcdGtleT17bm9kZS56b25lLmlkfVxuXHRcdFx0XHRcdFx0em9uZT17bm9kZS56b25lfVxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXt0aGlzLmdldERyb3Bab25lQ2xhc3NOYW1lcyhub2RlLnpvbmUpLmpvaW4oJyAnKX1cblx0XHRcdFx0XHRcdHNldHRpbmdzPXt0aGlzLnByb3BzLnNldHRpbmdzfVxuXHRcdFx0XHRcdFx0YWN0aXZlQXR0YWNobWVudHM9e3RoaXMuZ2V0Wm9uZUF0dGFjaG1lbnRzKG5vZGUuem9uZS5pZCl9XG5cdFx0XHRcdFx0XHRyZWZDb2xsZWN0b3I9e3RoaXMucHJvcHMucmVmQ29sbGVjdG9yfVxuXHRcdFx0XHRcdFx0b25Nb3VudD17dGhpcy5wcm9wcy5vbk1vdW50fVxuXHRcdFx0XHRcdFx0b25FdmVudD17dGhpcy5wcm9wcy5vbkRyb3Bab25lRXZlbnR9XG5cdFx0XHRcdFx0XHRvbkF0dGFjaG1lbnRDbGljaz17dGhpcy5wcm9wcy5vbkF0dGFjaG1lbnRDbGlja31cblx0XHRcdFx0XHRcdGxpYj17dGhpcy5wcm9wcy5saWJ9Lz5cblx0XHRcdFx0KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY2hpbGRyZW47XG5cdH1cblxuXHRnZXRJbnN0cnVjdGlvbigpIHtcblx0XHRpZiAodGhpcy5wcm9wcy5hY3RpdmVEcm9wbGV0SUQgIT0gJycpIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxwIGNsYXNzTmFtZT1cImluc3RydWN0aW9uXCI+Q2hvb3NlIGEgdGFyZ2V0IGZvciB0aGUgZHJvcGxldC4uLjwvcD5cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8c2VjdGlvbiBjbGFzc05hbWU9e3RoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy50ZW1wbGF0ZS5ub2RlfVxuXHRcdFx0XHRyZWY9e2NvbGxlY3RSZWYodGhpcy5wcm9wcywgJ3RlbXBsYXRlJyl9PlxuXHRcdFx0XHR7dGhpcy5nZXRJbnN0cnVjdGlvbigpfVxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17dGhpcy5wcm9wcy5zZXR0aW5ncy5jbGFzc2VzLnRlbXBsYXRlLmlubmVyfT5cblx0XHRcdFx0XHQ8cHJlPlxuXHRcdFx0XHRcdFx0PGNvZGUgY2xhc3NOYW1lPVwiaHRtbFwiXG5cdFx0XHRcdFx0XHRcdHJlZj17Y29sbGVjdFJlZih0aGlzLnByb3BzLCAndGVtcGxhdGVfaW5uZXInKX0+XG5cdFx0XHRcdFx0XHRcdHt0aGlzLmdldFRlbXBsYXRlKCl9XG5cdFx0XHRcdFx0XHQ8L2NvZGU+XG5cdFx0XHRcdFx0PC9wcmU+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9zZWN0aW9uPlxuXHRcdCk7XG5cdH1cbn1cblxuVGVtcGxhdGUucHJvcFR5cGVzID0ge1xuXHQvLyBmcm9tIFRlbXBsYXRlQ29udGFpbmVyXG5cdHpvbmVzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cdGFjdGl2ZURyb3BsZXRJRDogUHJvcFR5cGVzLnN0cmluZyxcblxuXHQvLyBmcm9tIENhbnZhc1xuXHRzZXR0aW5nczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHR0ZW1wbGF0ZTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG5cdG9uTW91bnQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdG9uQXR0YWNobWVudENsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRvbkRyb3Bab25lRXZlbnQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdHJlZkNvbGxlY3RvcjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblx0bGliOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblRlbXBsYXRlLmRlZmF1bHRQcm9wcyA9IHtcblx0dGVtcGxhdGU6ICcnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZW1wbGF0ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvVGVtcGxhdGUuanN4IiwiLyoqXG4gKiBAdHlwZWRlZiBUb29sYmFyU3RhdGVTZWdtZW50XG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgc21hbGwgc2VnbWVudCBvZiB0aGUgQXBwJ3MgaW50ZXJuYWwgc3RhdGUgd2hpY2ggaW5jbHVkZXMgdmFsdWVzIHJlbGV2YW50IHRvIHRvb2xiYXJcbiAqIGJ1dHRvbiBwcm9kdWN0aW9uLlxuICogQHByb3BlcnR5IHtvYmplY3R9IFVJXG4gKiBAcHJvcGVydHkge29iamVjdH0gVUkuZGlhbG9nXG4gKiBAcHJvcGVydHkge21vZHVsZTphc3NldHMvY29uc3RhbnRzLmRpYWxvZ01vZGVzfSBVSS5kaWFsb2cubW9kZSAtIFRoZSBjdXJyZW50IG1vZGUgb2YgdGhlIGFjdGl2ZSBkaWFsb2cuXG4gKiBAcHJvcGVydHkge251bWJlcnxudWxsfSB0b3VyX3N0YWdlIC0gVGhlIGN1cnJlbnQgdG91ciBzdGFnZSBpbmRleC4gKE9yIGBudWxsYCkuXG4gKi9cblxuLyoqXG4gKiBBIHRvb2xiYXIgbGFiZWwgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb259IFRvb2xiYXJJdGVtTGFiZWxcbiAqIEBwYXJhbSB7VG9vbGJhclN0YXRlU2VnbWVudH0gc3RhdGUgLSBBIHNlZ21lbnQgb2YgdGhlIGN1cnJlbnQgYXBwbGljYXRpb24gc3RhdGUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBUb29sYmFySXRlbVxuICogQHByb3BlcnR5IHtUb29sYmFySXRlbUxhYmVsfHN0cmluZ30gbGFiZWwgLSBUaGUgdG9vbGJhciBsYWJlbC4gRWl0aGVyIGEgZnVuY3Rpb24gb3IgYSBsaXRlcmFsIHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmNvbXBvbmVudHMvdmlld3MvSWNvbi5HTFlQSFN9IGdseXBoIC0gVGhlIGljb24gZ2x5cGggdG8gdXNlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1ldGhvZCAtIFRoZSBBcHAgbWV0aG9kIHRvIGludm9rZSB3aGVuIHRoZSBidXR0b25zIGlzIHByZXNzZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2xhc3NOYW1lIC0gRXh0cmEgY2xhc3MgbmFtZShzKSB0byBhcHBseSB0byB0aGUgYnV0dG9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBzZXBhcmF0b3I9ZmFsc2UgLSBQcm9kdWNlIGEgc2VwYXJhdG9yIHRvIHRoZSBsZWZ0IG9mIHRoZSBidXR0b24uXG4gKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4vSWNvbi5qc3gnO1xuXG5jbGFzcyBUb29sYmFyIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLmJ1dHRvblJlZnMgPSB7fTtcblx0fVxuXG5cdHJlZ2lzdGVyQnV0dG9uQ2xpY2soYnV0dG9uLCBrZXkpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBhcmdzID0gYnV0dG9uLmFyZ3VtZW50cyB8fCBbXTtcblxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0aWYgKHRoaXMuYnV0dG9uUmVmcyAmJiB0aGlzLmJ1dHRvblJlZnNba2V5XSkge1xuXHRcdFx0XHR0aGlzLmJ1dHRvblJlZnNba2V5XS5ibHVyKCk7XG5cdFx0XHRcdHRoaXMucHJvcHMub25CdXR0b25DbGljayh0aGlzLmJ1dHRvblJlZnNba2V5XSwgZXZlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIGJ1dHRvbi5tZXRob2QgPT09ICdzdHJpbmcnICYmXG5cdFx0XHRcdHRoaXMucHJvcHMubGliLnRvb2xzW2J1dHRvbi5tZXRob2RdKSB7XG5cdFx0XHRcdC8vIG1ldGhvZCBpcyBhIGRlZmluZWQgQXBwIG1ldGhvZCAoYXMgYSBzdHJpbmcpXG5cdFx0XHRcdHRoaXMucHJvcHMubGliLnRvb2xzW2J1dHRvbi5tZXRob2RdLmFwcGx5KG51bGwsIGFyZ3MpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gbWV0aG9kIGlzIGEgY3VzdG9tIGZ1bmN0aW9uLiBjYWxsIHdpdGggYXBwIGNvbnRleHQgKHVubGVzcyBib3VuZCBlbHNld2hlcmUpXG5cdFx0XHRcdGJ1dHRvbi5tZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XG5cdFx0XHR9XG5cdFx0fS5iaW5kKHRoaXMpO1xuXHR9XG5cblx0cmVnaXN0ZXJCdXR0b25SZWYoa2V5KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHJlZikge1xuXHRcdFx0aWYgKHJlZiAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmJ1dHRvblJlZnNba2V5XSA9IHJlZjtcblx0XHRcdH1cblx0XHR9LmJpbmQodGhpcyk7XG5cdH1cblxuXHRnZXRUb29sYmFyQnV0dG9ucygpIHtcblx0XHR2YXIgYnV0dG9ucyA9IFtdO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuYnV0dG9ucyAmJiB0aGlzLnByb3BzLmJ1dHRvbnMubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLnByb3BzLmJ1dHRvbnMuZm9yRWFjaCgoYnV0dG9uLCBpbmRleCkgPT4ge1xuXHRcdFx0XHR2YXIga2V5ID0gJ2J1dHRvbi0nICsgaW5kZXgsXG5cdFx0XHRcdFx0Y2xhc3NlcyA9IFtdLFxuXHRcdFx0XHRcdGljb24sIGxhYmVsO1xuXG5cdFx0XHRcdGlmIChidXR0b24uaWNvbikge1xuXHRcdFx0XHRcdGljb24gPSAoXG5cdFx0XHRcdFx0XHQ8SWNvbiBnbHlwaD17YnV0dG9uLmljb259XG5cdFx0XHRcdFx0XHRcdHdpZHRoPXsxNH1cblx0XHRcdFx0XHRcdFx0aGVpZ2h0PXsxNH0vPlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYnV0dG9uLmNsYXNzTmFtZSkge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChidXR0b24uY2xhc3NOYW1lKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChidXR0b24uc2VwYXJhdG9yKSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKHRoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy50b29sYmFyLnNlcGFyYXRvcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodHlwZW9mIGJ1dHRvbi5sYWJlbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGxhYmVsID0gYnV0dG9uLmxhYmVsKHtcblx0XHRcdFx0XHRcdFVJOiB7XG5cdFx0XHRcdFx0XHRcdGRpYWxvZzoge1xuXHRcdFx0XHRcdFx0XHRcdG1vZGU6IHRoaXMucHJvcHMuZGlhbG9nX21vZGVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dG91cl9zdGFnZTogdGhpcy5wcm9wcy50b3VyX3N0YWdlLFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxhYmVsID0gYnV0dG9uLmxhYmVsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnV0dG9ucy5wdXNoKFxuXHRcdFx0XHRcdDxsaSBrZXk9e2tleX1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5qb2luKCcgJyl9PlxuXHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9e3RoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5idXR0b259XG5cdFx0XHRcdFx0XHRcdHJlZj17dGhpcy5yZWdpc3RlckJ1dHRvblJlZihrZXkpfVxuXHRcdFx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnJlZ2lzdGVyQnV0dG9uQ2xpY2soYnV0dG9uLCBrZXkpfT5cblx0XHRcdFx0XHRcdFx0PHNwYW4+XG5cdFx0XHRcdFx0XHRcdFx0e2ljb259XG5cdFx0XHRcdFx0XHRcdFx0e2xhYmVsfVxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cImNpcmNsZVwiPjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gYnV0dG9ucztcblx0XHR9XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxtZW51IGNsYXNzTmFtZT1cInRvb2xiYXJcIj5cblx0XHRcdFx0PGZvcm0+XG5cdFx0XHRcdFx0PHVsPlxuXHRcdFx0XHRcdFx0e3RoaXMuZ2V0VG9vbGJhckJ1dHRvbnMoKX1cblx0XHRcdFx0XHQ8L3VsPlxuXHRcdFx0XHQ8L2Zvcm0+XG5cdFx0XHQ8L21lbnU+XG5cdFx0KTtcblx0fVxufVxuXG5Ub29sYmFyLnByb3BUeXBlcyA9IHtcblx0YnV0dG9uczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9iamVjdCksXG5cdHRvdXJfc3RhZ2U6IFByb3BUeXBlcy5hbnksXG5cdGRpYWxvZ19tb2RlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRzZXR0aW5nczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRvbkJ1dHRvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcblx0bGliOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRvb2xiYXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL1Rvb2xiYXIuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnLi4vdmlld3MvSWNvbi5qc3gnO1xuaW1wb3J0IHsgcmF3TWFya3VwIH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcblxuY2xhc3MgVG9vbHRpcCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0dGhpcy5wb3BwZXIgPSBudWxsO1xuXHRcdHRoaXMudWkgPSB7XG5cdFx0XHR0b29sdGlwOiBudWxsXG5cdFx0fTtcblx0fVxuXG5cdHJlZkNvbGxlY3RvcihyZWYpIHtcblx0XHR0aGlzLnVpLnRvb2x0aXAgPSByZWY7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLnVwZGF0ZUF0dGFjaG1lbnQoKTtcblx0fVxuXG5cdGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcblx0XHR0aGlzLnVwZGF0ZUF0dGFjaG1lbnQoKTtcblx0fVxuXG5cdHVwZGF0ZUF0dGFjaG1lbnQoKSB7XG5cdFx0dmFyIG9wdGlvbnM7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5zdGF0ZS5zaG93KSB7XG5cdFx0XHQvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aG9zZSBhc3NpZ25lZCB2aWEgdGhlIHN0YXRlIGNoYW5nZVxuXHRcdFx0b3B0aW9ucyA9IE9iamVjdC5kZWVwQXNzaWduKHt9LCB7XG5cdFx0XHRcdHBsYWNlbWVudDogJ3RvcCcsXG5cdFx0XHRcdG1vZGlmaWVyczoge1xuXHRcdFx0XHRcdGZsaXA6IFsndG9wJywgJ2JvdHRvbSddLFxuXHRcdFx0XHRcdGFycm93OiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnLmFycm93J1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcy5wcm9wcy5zdGF0ZS5vcHRpb25zKTtcblxuXHRcdFx0dGhpcy5wb3BwZXIgPSB0aGlzLnByb3BzLmF0dGFjaGVyKHRoaXMucHJvcHMuc3RhdGUuYXR0YWNobWVudCwgdGhpcy51aS50b29sdGlwLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMucG9wcGVyKSB7XG5cdFx0XHRcdHRoaXMucG9wcGVyLmRlc3Ryb3koKTtcblx0XHRcdFx0dGhpcy5wb3BwZXIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHR2YXIgY2xhc3NlcywgaWNvbjtcblxuXHRcdGNsYXNzZXMgPSBbXG5cdFx0XHR0aGlzLnByb3BzLnNldHRpbmdzLmNsYXNzZXMucG9wdXAsXG5cdFx0XHR0aGlzLnByb3BzLnNldHRpbmdzLmNsYXNzZXMudG9vbHRpcFxuXHRcdF07XG5cblx0XHRpZiAoIXRoaXMucHJvcHMuc3RhdGUuc2hvdykge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKHRoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5oaWRkZW4pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5wcm9wcy5zdGF0ZS5pY29uR2x5cGgpIHtcblx0XHRcdFx0aWNvbiA9IDxJY29uIGdseXBoPXt0aGlzLnByb3BzLnN0YXRlLmljb25HbHlwaH0vPjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdlxuXHRcdFx0XHRyZWY9e3RoaXMucmVmQ29sbGVjdG9yLmJpbmQodGhpcyl9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5qb2luKCcgJyl9PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj5cblx0XHRcdFx0XHQ8aDI+XG5cdFx0XHRcdFx0XHR7aWNvbn1cblx0XHRcdFx0XHRcdDxzcGFuPnt0aGlzLnByb3BzLnN0YXRlLnRpdGxlfTwvc3Bhbj5cblx0XHRcdFx0XHQ8L2gyPlxuXHRcdFx0XHRcdDxkaXYgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3Jhd01hcmt1cCh0aGlzLnByb3BzLnN0YXRlLmNvbnRlbnQpfS8+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJhcnJvd1wiLz5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuVG9vbHRpcC5wcm9wVHlwZXMgPSB7XG5cdHNldHRpbmdzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cdGF0dGFjaGVyOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRzdGF0ZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBUb29sdGlwO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9Ub29sdGlwLmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNvbGxlY3RSZWYgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuXG5jbGFzcyBWaWV3IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRpZiAodHlwZW9mIHRoaXMucHJvcHMub25Nb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhpcy5wcm9wcy5vbk1vdW50KCd2aWV3X2ZyYW1lJyk7XG5cdFx0fVxuXHR9XG5cblx0c2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuXHRcdC8vIG5vLiByZWxvYWRzL3VwZGF0ZXMgYXJlIGhhbmRsZWQgYnkgdGhlIHZpZXcgY2xhc3Ncblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxzZWN0aW9uIGNsYXNzTmFtZT1cInZpZXdcIlxuXHRcdFx0XHRyZWY9e2NvbGxlY3RSZWYodGhpcy5wcm9wcywgJ3ZpZXcnKX0+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZHJhZy1tYXNrXCI+PC9kaXY+XG5cdFx0XHRcdDxpZnJhbWUgcmVmPXtjb2xsZWN0UmVmKHRoaXMucHJvcHMsICd2aWV3X2ZyYW1lJyl9XG5cdFx0XHRcdFx0c3JjPXt0aGlzLnByb3BzLnNldHRpbmdzLnZpZXcuc3JjfT48L2lmcmFtZT5cblx0XHRcdDwvc2VjdGlvbj5cblx0XHQpO1xuXHR9XG59XG5cblZpZXcucHJvcFR5cGVzID0ge1xuXHRzZXR0aW5nczogUHJvcFR5cGVzLm9iamVjdCxcblx0b25Nb3VudDogUHJvcFR5cGVzLmZ1bmMsXG5cdHJlZkNvbGxlY3RvcjogUHJvcFR5cGVzLmZ1bmMsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBWaWV3O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9WaWV3LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IGZpZWxkIH0gZnJvbSAnLi4vLi4vLi4vYXNzZXRzL2NvbW1vbi1wcm9wLXR5cGVzJztcbmltcG9ydCB7IG9wdGlvblZhbHVlU2V0IH0gZnJvbSAnLi4vLi4vY29tcG9uZW50LXV0aWxzLmpzeCc7XG5cbmZ1bmN0aW9uIERyb3BEb3duKHByb3BzKSB7XG5cdHZhciBsYWJlbCA9IHByb3BzLmZpZWxkLmxhYmVsIHx8IHByb3BzLmZpZWxkLm5hbWU7XG5cblx0cmV0dXJuIChcblx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XG5cdFx0XHQ8bGFiZWw+e2xhYmVsfTwvbGFiZWw+XG5cdFx0XHQ8c2VsZWN0XG5cdFx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdFx0bmFtZT17cHJvcHMuZmllbGQubmFtZX1cblx0XHRcdFx0b25DaGFuZ2U9e3Byb3BzLm9uQ2hhbmdlfVxuXHRcdFx0XHR2YWx1ZT17cHJvcHMudmFsdWV9XG5cdFx0XHRcdHJlZj17cHJvcHMucmVmQ29sbGVjdG9yfT5cblx0XHRcdFx0e29wdGlvblZhbHVlU2V0KHByb3BzLmZpZWxkLm9wdGlvbnMpfVxuXHRcdFx0PC9zZWxlY3Q+XG5cdFx0PC9kaXY+XG5cdCk7XG59XG5cbkRyb3BEb3duLnByb3BUeXBlcyA9IGZpZWxkO1xuXG5leHBvcnQgZGVmYXVsdCBEcm9wRG93bjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvZmllbGRzL0Ryb3BEb3duLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IGZpZWxkIH0gZnJvbSAnLi4vLi4vLi4vYXNzZXRzL2NvbW1vbi1wcm9wLXR5cGVzJztcblxuZnVuY3Rpb24gVGV4dEZpZWxkKHByb3BzKSB7XG5cdHZhciBsYWJlbCA9IHByb3BzLmZpZWxkLmxhYmVsIHx8IHByb3BzLmZpZWxkLm5hbWU7XG5cblx0cmV0dXJuIChcblx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZpZWxkXCI+XG5cdFx0XHQ8bGFiZWw+e2xhYmVsfTwvbGFiZWw+XG5cdFx0XHQ8aW5wdXRcblx0XHRcdFx0dHlwZT1cInRleHRcIlxuXHRcdFx0XHRuYW1lPXtwcm9wcy5maWVsZC5uYW1lfVxuXHRcdFx0XHRwbGFjZWhvbGRlcj17cHJvcHMuZmllbGQucGxhY2Vob2xkZXJ9XG5cdFx0XHRcdG9uQ2hhbmdlPXtwcm9wcy5vbkNoYW5nZX1cblx0XHRcdFx0bWF4TGVuZ3RoPXtwcm9wcy5maWVsZC5kYXRhLm1heGxlbmd0aH1cblx0XHRcdFx0dmFsdWU9e3Byb3BzLnZhbHVlfVxuXHRcdFx0XHRyZWY9e3Byb3BzLnJlZkNvbGxlY3Rvcn0vPlxuXHRcdDwvZGl2PlxuXHQpO1xufVxuXG5UZXh0RmllbGQucHJvcFR5cGVzID0gZmllbGQ7XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRGaWVsZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvZmllbGRzL1RleHRGaWVsZC5qc3giLCJpbXBvcnQgaW50ZXJhY3QgZnJvbSAnaW50ZXJhY3QuanMnO1xuXG53aW5kb3cuaW50ZXJhY3QgPSBpbnRlcmFjdDtcblxuLyoqXG4gKiBIYW5kbGVzIGRyYWdnYWJsZS9kcm9wcGFibGUgaXRlbXMuXG4gKiBAY2xhc3NcbiAqL1xudmFyIERyYWdEcm9wID0gZnVuY3Rpb24oY2FudmFzLCBzZXR0aW5ncywgY2FsbGJhY2tzID0ge30pIHtcblx0dGhpcy5fY2FudmFzID0gY2FudmFzO1xuXHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cdHRoaXMuX2NhbGxiYWNrcyA9IGNhbGxiYWNrcztcblxuXHR0aGlzLnVpID0ge1xuXHRcdGRyYWc6IFtdLFxuXHRcdGRyb3A6IFtdXG5cdH07XG59O1xuXG5EcmFnRHJvcC5wcm90b3R5cGUgPSB7XG5cdGFkZERyYWdhYmxlOiBmdW5jdGlvbihlbGVtZW50LCBzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcblx0XHR2YXIgZHJhZ2FibGUgPSBuZXcgRHJhZ2FibGUoZWxlbWVudCk7XG5cblx0XHQvLyBkdXBsaWNhdGUgc2V0dGluZ3Ncblx0XHRzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKTtcblxuXHRcdC8vIG1ha2UgdGhlIGVsZW1lbnQgZHJhZ2dhYmxlXG5cdFx0ZHJhZ2FibGUuc2V0RHJhZ2FibGUoc2V0dGluZ3MpXG5cdFx0XHQub24oJ2RyYWdzdGFydCcsICgpID0+IHtcblx0XHRcdFx0dGhpcy5fY2FudmFzLmNsYXNzTGlzdC5hZGQodGhpcy5zZXR0aW5ncy5jbGFzc2VzLmlzX2RyYWdnaW5nKTtcblx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuc2V0dGluZ3MuY2xhc3Nlcy5pdGVtX2RyYWdnaW5nKTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ2RyYWdlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX2NhbnZhcy5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuc2V0dGluZ3MuY2xhc3Nlcy5pc19kcmFnZ2luZyk7XG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnNldHRpbmdzLmNsYXNzZXMuaXRlbV9kcmFnZ2luZyk7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLl9jYWxsYmFja3MuZHJhZ0VuZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrcy5kcmFnRW5kKGVsZW1lbnQsIGRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMudWkuZHJhZy5wdXNoKHRoaXMuX2NyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGRyYWdhYmxlKSk7XG5cdH0sXG5cblx0YWRkRHJvcGFibGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuXHRcdHZhciBkcm9wYWJsZSA9IG5ldyBEcm9wYWJsZShlbGVtZW50KTtcblxuXHRcdGRyb3BhYmxlLnNldERyb3BhYmxlKHNldHRpbmdzKVxuXHRcdFx0Lm9uKCdkcm9wYWN0aXZhdGUnLCAoZXZlbnQpID0+IHtcblx0XHRcdFx0Ly8gYWRkIGFjdGl2ZSBkcm9wem9uZSBmZWVkYmFja1xuXHRcdFx0XHRldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZCh0aGlzLnNldHRpbmdzLmNsYXNzZXMuZHJvcHpvbmVfaXNfYWN0aXZlKTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ2RyYWdlbnRlcicsIChldmVudCkgPT4ge1xuXHRcdFx0XHQvLyBmZWVkYmFjayB0aGUgcG9zc2liaWxpdHkgb2YgYSBkcm9wXG5cdFx0XHRcdGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuYWRkKHRoaXMuc2V0dGluZ3MuY2xhc3Nlcy5kcm9wem9uZV9pc190YXJnZXQpO1xuXHRcdFx0XHQvLyBldmVudC5yZWxhdGVkVGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2Nhbi1kcm9wJyk7XG5cdFx0XHRcdC8vIGV2ZW50LnJlbGF0ZWRUYXJnZXQudGV4dENvbnRlbnQgPSAnRHJhZ2dlZCBpbic7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdkcmFnbGVhdmUnLCAoZXZlbnQpID0+IHtcblx0XHRcdFx0Ly8gcmVtb3ZlIHRoZSBkcm9wIGZlZWRiYWNrIHN0eWxlXG5cdFx0XHRcdGV2ZW50LnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuc2V0dGluZ3MuY2xhc3Nlcy5kcm9wem9uZV9pc190YXJnZXQpO1xuXHRcdFx0XHQvLyBldmVudC5yZWxhdGVkVGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2Nhbi1kcm9wJyk7XG5cdFx0XHRcdC8vIGV2ZW50LnJlbGF0ZWRUYXJnZXQudGV4dENvbnRlbnQgPSAnRHJhZ2dlZCBvdXQnO1xuXHRcdFx0fSlcblx0XHRcdC5vbignZHJvcCcsIChldmVudCkgPT4ge1xuXHRcdFx0XHRpZiAodHlwZW9mIHRoaXMuX2NhbGxiYWNrcy5kcm9wID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2tzLmRyb3AoZXZlbnQucmVsYXRlZFRhcmdldCwgZXZlbnQudGFyZ2V0LCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5vbignZHJvcGRlYWN0aXZhdGUnLCAoZXZlbnQpID0+IHtcblx0XHRcdFx0Ly8gcmVtb3ZlIGFjdGl2ZSBkcm9wem9uZSBmZWVkYmFja1xuXHRcdFx0XHRldmVudC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnNldHRpbmdzLmNsYXNzZXMuZHJvcHpvbmVfaXNfYWN0aXZlKTtcblx0XHRcdFx0ZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5zZXR0aW5ncy5jbGFzc2VzLmRyb3B6b25lX2lzX3RhcmdldCk7XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMudWkuZHJvcC5wdXNoKHRoaXMuX2NyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGRyb3BhYmxlKSk7XG5cdH0sXG5cblx0cmVzZXREcmFnUG9zaXRpb246IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoKGVsZW1lbnQgPSB0aGlzLmdldERyYWdJbnN0YW5jZShlbGVtZW50KSkpIHtcblx0XHRcdGVsZW1lbnQuaW5zdGFuY2UucmVzZXRQb3NpdGlvbigpO1xuXHRcdH1cblx0fSxcblxuXHRnZXREcmFnSW5zdGFuY2U6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gdGhpcy51aS5kcmFnLmZpbmQoKGl0ZW0pID0+IHtcblx0XHRcdHJldHVybiBpdGVtLmVsZW1lbnQgPT09IGVsZW1lbnQ7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NyZWF0ZUluc3RhbmNlOiBmdW5jdGlvbihlbGVtZW50LCBpbnN0YW5jZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRlbGVtZW50LFxuXHRcdFx0aW5zdGFuY2Vcblx0XHR9O1xuXHR9XG59O1xuXG4vKlxuICogR2VuZXJpY2FsbHkgaGFuZGxlcyB0aGUgZHJhZ2dpbmcgYW5kIGRyb3BwaW5nIG9mIGluZGl2aWR1YWwgRE9NIG5vZGVzLlxuICogVXNlcyBpbnRlcmFjdC5qcyAoaHR0cDovL2ludGVyYWN0anMuaW8pXG4gKi9cbnZhciBEcmFnYWJsZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cblx0dGhpcy5feCA9IDA7XG5cdHRoaXMuX3kgPSAwO1xufTtcblxuRHJhZ2FibGUucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogU2V0IHVwIGEgZHJhZ2dhYmxlIGl0ZW0uXG5cdCAqL1xuXHRzZXREcmFnYWJsZTogZnVuY3Rpb24oc2V0dGluZ3MpIHtcblx0XHRyZXR1cm4gaW50ZXJhY3QodGhpcy5fZWxlbWVudClcblx0XHRcdC5kcmFnZ2FibGUoc2V0dGluZ3MpXG5cdFx0XHQub24oJ2RyYWdtb3ZlJywgc2V0dGluZ3Mub25EcmFnTW92ZSB8fCAoKGV2ZW50KSA9PiB7XG5cdFx0XHRcdHRoaXMuX3ggKz0gZXZlbnQuZHg7XG5cdFx0XHRcdHRoaXMuX3kgKz0gZXZlbnQuZHk7XG5cblx0XHRcdFx0dGhpcy5fZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPVxuXHRcdFx0XHR0aGlzLl9lbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9XG5cdFx0XHRcdFx0J3RyYW5zbGF0ZSgnICsgdGhpcy5feCArICdweCwgJyArIHRoaXMuX3kgKyAncHgpJztcblx0XHRcdH0pKTtcblx0fSxcblxuXHRyZXNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl94ID0gMDtcblx0XHR0aGlzLl95ID0gMDtcblxuXHRcdHRoaXMuX2VsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID1cblx0XHR0aGlzLl9lbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9XG5cdFx0XHQndHJhbnNsYXRlKDAsIDApJztcblx0fSxcbn07XG5cblxuLypcbiAqIEdlbmVyaWNhbGx5IGhhbmRsZXMgZHJvcCB6b25lcyBpbiB0aGUgRE9NLlxuICogVXNlcyBpbnRlcmFjdC5qcyAoaHR0cDovL2ludGVyYWN0anMuaW8pXG4gKi9cbnZhciBEcm9wYWJsZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG59O1xuXG5Ecm9wYWJsZS5wcm90b3R5cGUgPSB7XG5cdC8qKlxuXHQgKiBTZXQgdXAgYSBkcmFnZ2FibGUgaXRlbS5cblx0ICovXG5cdHNldERyb3BhYmxlOiBmdW5jdGlvbihzZXR0aW5ncykge1xuXHRcdHJldHVybiBpbnRlcmFjdCh0aGlzLl9lbGVtZW50KVxuXHRcdFx0LmRyb3B6b25lKHNldHRpbmdzKTtcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRHJhZ0Ryb3A7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9saWIvRHJhZ0Ryb3AuanMiLCIvKipcbiAqIFRha2VzIG11bHRpcGxlIGZ1bmN0aW9ucyBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGludm9rZXMgdGhlbSBjb25zZWN1dGl2ZWx5XG4gKiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50IHNpZ25hdHVyZTogKHByb3ApIGB2YWx1ZWAsIGBwcm9wbmFtZWAsIGBkcm9wbGV0X25hbWVgLCBgZHJvcGxldF90eXBlYC5cbiAqL1xuZnVuY3Rpb24gY2hhaW4oKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odmFsdWUsIHByb3BuYW1lLCBkcm9wbGV0X25hbWUsIGRyb3BsZXRfdHlwZSkge1xuXHRcdHZhciB0ZXN0ID0gdHJ1ZTtcblxuXHRcdC8vIHJ1biBlYWNoIGZ1bmN0aW9uIGluIHRoZSBjaGFpblxuXHRcdGFyZ3MuZm9yRWFjaCgoZm4pID0+IHtcblx0XHRcdGlmICghZm4uYXBwbHkodGhpcywgW3ZhbHVlLCBwcm9wbmFtZSwgZHJvcGxldF9uYW1lLCBkcm9wbGV0X3R5cGVdKSkge1xuXHRcdFx0XHR0ZXN0ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGVzdDtcblx0fTtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoZSBgdGVzdGAgdmFsdWUgaXMgdHJ1dGh5LiBJbiB0aGUgY2FzZSB0aGF0IGl0IGZhaWxzLCBhbiBFcnJvciBpcyB0aHJvd24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRlc3QgLSBUZXN0IGV4cHJlc3Npb24gcmVzdWx0XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgYmVpbmcgdGVzdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlLCBpbiBjYXNlIG9mIGZhaWx1cmUuIFdpbGwgYmUgYXBwZW5kZWQgdG8gYSBnZW5lcmFsXG4gKiBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtkcm9wbGV0X25hbWVdIC0gVGhlIG5hbWUgb2YgdGhlIERyb3BsZXQgYmVpbmcgdGVzdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RvcGxldF90eXBlXSAtIFRoZSBkcm9wbGV0VHlwZSBhdHRyaWJ1dGUgb2YgdGhlIERyb3BsZXQgYmVpbmcgdGVzdGVkXG4gKi9cbmZ1bmN0aW9uIGFzc2VydCh0ZXN0LCBwcm9wbmFtZSwgbWVzc2FnZSwgZHJvcGxldF9uYW1lLCBkcm9wbGV0X3R5cGUpIHtcblx0dmFyIGVycm9yLCBwcm9wX2lkO1xuXG5cdGlmICghdGVzdCkge1xuXHRcdGlmIChkcm9wbGV0X25hbWUpIHtcblx0XHRcdHByb3BfaWQgPSAnXCInICsgZHJvcGxldF9uYW1lICsgJ1wiJyArIChkcm9wbGV0X3R5cGUgPyAnICgnICsgZHJvcGxldF90eXBlICsgJyknIDogJycpO1xuXHRcdH1cblxuXHRcdGVycm9yID0gICdFcnJvciBpbiBEcm9wbGV0JyArXG5cdFx0XHQocHJvcF9pZCA/ICcgJyArIHByb3BfaWQgKyAnICcgOiAnICcpICtcblx0XHRcdCdwcm9wIFwiJyArIHByb3BuYW1lICsgJ1wiLiAnICsgbWVzc2FnZTtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGlzUmVxdWlyZWQodmFsdWUsIHByb3AsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlKSB7XG5cdHJldHVybiBhc3NlcnQoXG5cdFx0KHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpLCBwcm9wLCAnVmFsdWUgaXMgcmVxdWlyZWQuJywgZHJvcGxldF9uYW1lLCBkcm9wbGV0X3R5cGVcblx0KTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nTm90RW1wdHkodmFsdWUsIHByb3AsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlKSB7XG5cdHJldHVybiBhc3NlcnQoXG5cdFx0KHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09ICcnKSwgcHJvcCwgJ1ZhbHVlIGNhbm5vdCBiZSBlbXB0eS4nLCBkcm9wbGV0X25hbWUsIGRyb3BsZXRfdHlwZVxuXHQpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmcodmFsdWUsIHByb3AsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlKSB7XG5cdHJldHVybiBhc3NlcnQoXG5cdFx0KHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyksXG5cdFx0cHJvcCxcblx0XHQnVmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nLFxuXHRcdGRyb3BsZXRfbmFtZSxcblx0XHRkcm9wbGV0X3R5cGVcblx0KTtcbn1cblxuc3RyaW5nLmlzUmVxdWlyZWQgPSBjaGFpbihzdHJpbmcsIGlzUmVxdWlyZWQpO1xuc3RyaW5nLm5vdEVtcHR5ID0gY2hhaW4oc3RyaW5nLCBzdHJpbmdOb3RFbXB0eSk7XG5zdHJpbmcubm90RW1wdHkuaXNSZXF1aXJlZCA9IGNoYWluKHN0cmluZywgc3RyaW5nTm90RW1wdHksIGlzUmVxdWlyZWQpO1xuXG5mdW5jdGlvbiBvYmplY3QodmFsdWUsIHByb3AsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlKSB7XG5cdHJldHVybiBhc3NlcnQoXG5cdFx0KHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyksXG5cdFx0cHJvcCxcblx0XHQnVmFsdWUgbXVzdCBiZSBhbiBvYmplY3QuJyxcblx0XHRkcm9wbGV0X25hbWUsXG5cdFx0ZHJvcGxldF90eXBlXG5cdCk7XG59XG5cbm9iamVjdC5pc1JlcXVpcmVkID0gY2hhaW4ob2JqZWN0LCBpc1JlcXVpcmVkKTtcblxuZnVuY3Rpb24gYXJyYXkodmFsdWUsIHByb3AsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlKSB7XG5cdHJldHVybiBhc3NlcnQoXG5cdFx0QXJyYXkuaXNBcnJheSh2YWx1ZSksIHByb3AsICdWYWx1ZSBtdXN0IGJlIGFuIGFycmF5LicsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlXG5cdCk7XG59XG5cbmFycmF5LmlzUmVxdWlyZWQgPSBjaGFpbihhcnJheSwgaXNSZXF1aXJlZCk7XG5cbmZ1bmN0aW9uIGFycmF5T2YoKSB7fVxuXG5hcnJheU9mLnN0cmluZyA9IGNoYWluKFxuXHQvLyB0ZXN0IGZvciBhbiBhcnJheVxuXHRhcnJheSxcblx0Ly8gdGVzdCBhcnJheSB2YWx1ZXMgYXJlIGFsbCBzdHJpbmdzXG5cdCh2YWx1ZSwgcHJvcCwgZHJvcGxldF9uYW1lLCBkcm9wbGV0X3R5cGUpID0+IHtcblx0XHR2YXIgdGVzdCA9IHRydWUsXG5cdFx0XHRhO1xuXG5cdFx0Zm9yIChhID0gMDsgYSA8IHZhbHVlLmxlbmd0aDsgYSArPSAxKSB7XG5cdFx0XHR0ZXN0ID0gKHRlc3QgPyAodHlwZW9mIHZhbHVlW2FdID09PSAnc3RyaW5nJykgOiB0ZXN0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXNzZXJ0KFxuXHRcdFx0dGVzdCxcblx0XHRcdHByb3AsXG5cdFx0XHQnVmFsdWUgbXVzdCBiZSBhbiBhcnJheSBjb250YWluaW5nIG9ubHkgc3RyaW5ncycsXG5cdFx0XHRkcm9wbGV0X25hbWUsXG5cdFx0XHRkcm9wbGV0X3R5cGVcblx0XHQpO1xuXHR9XG4pO1xuXG5hcnJheU9mLnN0cmluZy5pc1JlcXVpcmVkID0gY2hhaW4oYXJyYXlPZi5zdHJpbmcsIGlzUmVxdWlyZWQpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdF9jaGFpbjogY2hhaW4sXG5cdF9hc3NlcnQ6IGFzc2VydCxcblx0c3RyaW5nLFxuXHRvYmplY3QsXG5cdGFycmF5LFxuXHRhcnJheU9mLFxuXHRpc1JlcXVpcmVkLFxuXHRzdHJpbmdOb3RFbXB0eVxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2xpYi9Qcm9wVHlwZXMuanMiLCJpbXBvcnQgeyBkaWFsb2dNb2RlcyB9IGZyb20gJy4uL2Fzc2V0cy9jb25zdGFudHMnO1xuaW1wb3J0IGFjdGlvbnMgZnJvbSAnLi4vc3RhdGUvYWN0aW9ucyc7XG5cbi8qKlxuICogSGFuZGxlIHByb2R1Y3Rpb24gb2YgdG91ciBkaWFsb2dzLlxuICogQHBhcmFtIHtVSX0gcGFyZW50IC0gUGFyZW50IFVJIGNsYXNzIGluc3RhbmNlLlxuICogQGNsYXNzXG4gKi9cbnZhciBUb3VyID0gZnVuY3Rpb24ocGFyZW50KSB7XG5cdHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbn07XG5cblRvdXIucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogUHJvZHVjZSB0aGUgdG91ciBpbnRyb2R1Y3Rpb24uXG5cdCAqL1xuXHRpbnRybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudC5fc2hvd0RpYWxvZyhkaWFsb2dNb2Rlcy5HRU5FUkFMLCB0aGlzLl9wYXJlbnQuZGlhbG9ncy5pbnRybylcblx0XHRcdC50aGVuKHRoaXMuX3BhcmVudC5faGlkZURpYWxvZy5iaW5kKHRoaXMuX3BhcmVudCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTdGFydHMgdGhlIHRvdXIgKGJ1dCB3aWxsIGNvbnRpbnVlIGlmIHBhdXNlZCkuXG5cdCAqL1xuXHRzdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2dyZXNzVG91cigpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTdGFydHMgb3IgcHJvZ3Jlc2VzIHRoZSB0b3VyIChieSBvbmUgZGlhbG9nKS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9wcm9ncmVzc1RvdXI6IGZ1bmN0aW9uKGluZGV4ID0gbnVsbCkge1xuXHRcdHZhciBzdGF0ZTtcblxuXHRcdC8vIGdldCBuZXh0IHRvdXIgaXRlbSBmcm9tIHN0YXRlIG9yIGRlZmF1bHRcblx0XHRpZiAoaW5kZXggPT09IG51bGwpIHtcblx0XHRcdHN0YXRlID0gKHRoaXMuX3BhcmVudC5fc3RvcmUuZ2V0U3RhdGUoKSkuVUk7XG5cdFx0XHRpbmRleCA9IChzdGF0ZS50b3VyX3N0YWdlICE9PSBudWxsKSA/IChzdGF0ZS50b3VyX3N0YWdlICsgMSkgOiAwO1xuXHRcdH1cblxuXHRcdGlmICgodGhpcy5fcGFyZW50LmRpYWxvZ3MudG91ci5sZW5ndGggLSAxKSA+PSBpbmRleCkge1xuXHRcdFx0dGhpcy5fc2V0VG91clN0YWdlKGluZGV4KTtcblx0XHRcdHJldHVybiB0aGlzLl9zaG93VG91ckVsZW1lbnQoaW5kZXgpXG5cdFx0XHRcdC50aGVuKChkaWFsb2cpID0+IHtcblx0XHRcdFx0XHR0aGlzLl9wYXJlbnQuX2hpZGVEaWFsb2coKTtcblxuXHRcdFx0XHRcdC8vIGlmIGFjdGlvbiBpcyBwYXVzZSwgd2lsbCBwYXVzZSB0aGUgdG91ciBieSBkb2luZyBub3RoaW5nXG5cdFx0XHRcdFx0aWYgKGRpYWxvZy5hY3Rpb24gPT09ICdjYW5jZWwnKSB7XG5cdFx0XHRcdFx0XHQvLyBlbmQgdGhlIHRvdXJcblx0XHRcdFx0XHRcdHRoaXMuX3NldFRvdXJTdGFnZShudWxsKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGRpYWxvZy5hY3Rpb24gIT09ICdwYXVzZScpIHtcblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzIHRoZSB0b3VyXG5cdFx0XHRcdFx0XHR0aGlzLl9wcm9ncmVzc1RvdXIoKGluZGV4ICsgMSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGVuZCBvZiB0b3VyIC0gc2V0IHN0YWdlIHRvIG51bGwgYW5kIGhpZGUgZGlhbG9nXG5cdFx0XHR0aGlzLl9zZXRUb3VyU3RhZ2UobnVsbCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGFyZW50Ll9oaWRlRGlhbG9nKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTaG93IGEgc3BlY2lmaWMgaW5kZXhlZCBlbGVtZW50IG9mIHRoZSB0b3VyLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Nob3dUb3VyRWxlbWVudChpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQuX3Nob3dEaWFsb2coXG5cdFx0XHRkaWFsb2dNb2Rlcy5UT1VSLFxuXHRcdFx0dGhpcy5fcGFyZW50LmRpYWxvZ3MudG91cltpbmRleF1cblx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIHRvdXIgc3RhZ2UgaW5kZXggKHVzaW5nIFJlZHV4KS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zZXRUb3VyU3RhZ2U6IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dGhpcy5fcGFyZW50Ll9zdG9yZS5kaXNwYXRjaChcblx0XHRcdGFjdGlvbnMuc2V0VG91clN0YWdlKHN0YWdlKVxuXHRcdCk7XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRvdXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9saWIvVG91ci5qcyIsIi8qKlxuICogQHR5cGVkZWYgRGlhbG9nRGF0YVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSBkaWFsb2cuXG4gKiBAcHJvcGVydHkge2FycmF5fHN0cmluZ30gbWVzc2FnZSAtIEVpdGhlciBhIHNpbmdsZSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncywgZGVmaW5pbmdcbiAqIGVhY2ggcGFyYWdyYXBoIG9mIHRoZSBkaWFsb2cgbWVzc2FnZS4gQmFzaWMgSFRNTCBpcyBhbGxvd2VkLlxuICogQHByb3BlcnR5IHtGb3JtQnV0dG9uW118dW5kZWZpbmVkfSBidXR0b25zIC0gQW4gYXJyYXkgb2YgRm9ybUJ1dHRvbiBidXR0b25zLCBvciBsZWF2ZSB1bmRlZmluZWRcbiAqIHRvIHVzZSB0aGUgZGVmYXVsdCBcIk9LXCIgYnV0dG9uLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IFBvcHBlciBmcm9tICdwb3BwZXIuanMnO1xuXG5pbXBvcnQgRHJhZ0Ryb3AgZnJvbSAnLi9EcmFnRHJvcCc7XG5pbXBvcnQgQ29tbXVuaWNhdG9yIGZyb20gJy4vQ29tbXVuaWNhdG9yJztcbmltcG9ydCBUb3VyIGZyb20gJy4vVG91cic7XG5pbXBvcnQgVGVtcGxhdGUgZnJvbSAnLi4vbGliL1RlbXBsYXRlJztcbmltcG9ydCB7IEdMWVBIUyB9IGZyb20gJy4uL2NvbXBvbmVudHMvdmlld3MvSWNvbi5qc3gnO1xuXG5pbXBvcnQgQ2FudmFzQ29udGFpbmVyIGZyb20gJy4uL2NvbXBvbmVudHMvY29udGFpbmVycy9DYW52YXNDb250YWluZXInO1xuXG5pbXBvcnQgYWN0aW9ucyBmcm9tICcuLi9zdGF0ZS9hY3Rpb25zJztcbmltcG9ydCBjcmVhdGVEaWFsb2dzIGZyb20gJy4uL2Fzc2V0cy9kaWFsb2dzJztcblxuaW1wb3J0IHsgZGlhbG9nTW9kZXMsIHVpU3RhdGVzLCBtZXNzYWdlQ29tbWFuZHMgfSBmcm9tICcuLi9hc3NldHMvY29uc3RhbnRzJztcblxuLyoqXG4gKiBIYW5kbGVzIFVzZXIgSW50ZXJmYWNlIGNvbXBvbmVudHMgYW5kIGFjdHMgYXMgdGhlIG1haW4gY29udHJvbGxlci5cbiAqIEBjbGFzc1xuICovXG52YXIgVUkgPSBmdW5jdGlvbihwYXJlbnQsIHNldHRpbmdzLCByZWZzLCBkYXRhLCBzdG9yZSwgdGVtcGxhdGUpIHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG5cblx0LyoqXG5cdCAqIFNldHRpbmdzIGFzIGRlZmluZWQgd2hlbiBpbnN0YW50aWF0aW5nLiBJbmhlcml0cyBmcm9tIHtAbGluayBBcHAuZGVmYXVsdHN9XG5cdCAqL1xuXHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR0aGlzLl9yZWZzID0gcmVmcztcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHRoaXMuX2RhdGEgPSBkYXRhO1xuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dGhpcy5fc3RvcmUgPSBzdG9yZTtcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGU7XG5cblx0LyoqXG5cdCAqIERpYWxvZyBvYmplY3RzIGZvciB1c2Ugd2l0aCB7QGxpbmsgQXBwI2RpYWxvZ31cblx0ICovXG5cdHRoaXMuZGlhbG9ncyA9IGNyZWF0ZURpYWxvZ3Moc2V0dGluZ3MpO1xuXG5cdC8vIFVJIGNsYXNzIHNwZWNpZmljIGRhdGEgZW50cmllc1xuXHR0aGlzLl9kYXRhLlVJID0ge1xuXHRcdGRyYWdkcm9wOiB7XG5cdFx0XHQvLyBkcm9wbGV0cyBkcmFnZHJvcCBjbGFzcyBpbnN0YW5jZVxuXHRcdFx0ZHJvcGxldHM6IHt9XG5cdFx0fSxcblxuXHRcdC8vIHRoZSBjdXJyZW50IHZpZXdwb3J0IHdpZHRoXG5cdFx0dnBfd2lkdGg6IDAsXG5cblx0XHQvLyB0aGUgZHJhZyBoYW5kbGUgcG9zaXRpb25cblx0XHRkcmFnSGFuZGxlUG9zaXRpb246IDAsXG5cblx0XHQvLyBoYXMgdGhlIGRyYWcgaGFuZGxlIGJlZW4gbW92ZWQ/XG5cdFx0ZHJhZ0hhbmRsZU1vdmVkOiBmYWxzZVxuXHR9O1xuXG5cdHRoaXMuX2NvbW1zID0gbmV3IENvbW11bmljYXRvcignYXBwJywgd2luZG93LmxvY2F0aW9uLm9yaWdpbiwge1xuXHRcdG1lc3NhZ2U6IHRoaXMuX2hhbmRsZUFwcE1lc3NhZ2UuYmluZCh0aGlzKVxuXHR9KTtcblxuXHR0aGlzLl90b3VyID0gbmV3IFRvdXIodGhpcyk7XG5cblx0Ly8gc2V0IHVwIGxpYnJhcnkgbWV0aG9kcyBmb3IgcGFzc2luZyB0byBSZWFjdCBjb21wb25lbnRzXG5cdHRoaXMubGlicmFyeU1ldGhvZHMgPSB7XG5cdFx0Z2V0RHJvcGxldEJ5SWQ6IHRoaXMuZ2V0RHJvcGxldEJ5SWQuYmluZCh0aGlzKSxcblx0XHRzZXRVSVBvcHBlckF0dGFjaG1lbnQ6IHRoaXMuX3NldFVJUG9wcGVyQXR0YWNobWVudC5iaW5kKHRoaXMpLFxuXHRcdHpvbmVEZXRhY2hBdHRhY2htZW50OiB0aGlzLnpvbmVEZXRhY2hBdHRhY2htZW50LmJpbmQodGhpcyksXG5cdFx0em9uZUdldEF0dGFjaG1lbnQ6IHRoaXMuem9uZUdldEF0dGFjaG1lbnQuYmluZCh0aGlzKSxcblx0XHRpc1ZhbGlkRHJvcDogdGhpcy5faXNWYWxpZERyb3AuYmluZCh0aGlzKSxcblx0XHR0b29sczoge1xuXHRcdFx0ZGlhbG9nOiB0aGlzLl9wYXJlbnQuZGlhbG9nLmJpbmQodGhpcy5fcGFyZW50KSxcblx0XHRcdGhpZGVEaWFsb2c6IHRoaXMuX2hpZGVEaWFsb2cuYmluZCh0aGlzKSxcblx0XHRcdHN0YXJ0VG91cjogdGhpcy5fdG91ci5zdGFydC5iaW5kKHRoaXMuX3RvdXIpLFxuXHRcdFx0cmVzZXQ6IHRoaXMuX3BhcmVudC5yZXNldC5iaW5kKHRoaXMuX3BhcmVudCksXG5cdFx0XHR1cGRhdGVWaWV3OiB0aGlzLl91cGRhdGVWaWV3LmJpbmQodGhpcylcblx0XHR9XG5cdH07XG5cblx0Ly8gcGVyZm9ybSBiaW5kaW5ncyBmb3IgbWV0aG9kcyBjb21tb25seSB1c2VkIHdpdGhpbiBwcm9taXNlc1xuXHR0aGlzLl9oaWRlRGlhbG9nID0gdGhpcy5faGlkZURpYWxvZy5iaW5kKHRoaXMpO1xuXHR0aGlzLl9zaG93RGlhbG9nID0gdGhpcy5fc2hvd0RpYWxvZy5iaW5kKHRoaXMpO1xuXG5cdC8vIHNob3cgaW50cm9kdWN0aW9uIChvciBub3QpXG5cdGlmICh0aGlzLnNldHRpbmdzLnNob3dJbnRybykge1xuXHRcdHRoaXMuX3RvdXIuaW50cm8oKTtcblx0fVxuXG5cdC8vIGdlbmVyYWwgcXVldWVzXG5cdHRoaXMucXVldWVzID0ge1xuXHRcdGRyYWdkcm9wQmluZGluZ3M6IFtdXG5cdH07XG5cblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpKTtcbn07XG5cblVJLnByb3RvdHlwZSA9IHtcblx0LyoqXG5cdCAqIFNlbmRzIHJlbmRlcigpIGNhbGwgdG8gdGhlIFJlYWN0IGNhbnZhcy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fY2FudmFzID0gcmVuZGVyKFxuXHRcdFx0PFByb3ZpZGVyIHN0b3JlPXt0aGlzLl9zdG9yZX0+XG5cdFx0XHRcdDxDYW52YXNDb250YWluZXJcblx0XHRcdFx0XHRkYXRhPXt0aGlzLl9kYXRhfVxuXHRcdFx0XHRcdHNldHRpbmdzPXt0aGlzLnNldHRpbmdzfVxuXHRcdFx0XHRcdHJlZkNvbGxlY3Rvcj17dGhpcy5fcmVmQ29sbGVjdG9yLmJpbmQodGhpcyl9XG5cdFx0XHRcdFx0b25Nb3VudD17dGhpcy5fbW91bnRFdmVudC5iaW5kKHRoaXMpfVxuXHRcdFx0XHRcdG9uQXR0YWNobWVudENsaWNrPXt0aGlzLl9oYW5kbGVBdHRhY2htZW50Q2xpY2suYmluZCh0aGlzKX1cblx0XHRcdFx0XHRvbkRyb3BsZXRFdmVudD17dGhpcy5faGFuZGxlRHJvcGxldEV2ZW50LmJpbmQodGhpcyl9XG5cdFx0XHRcdFx0b25Ecm9wWm9uZUV2ZW50PXt0aGlzLl9oYW5kbGVEcm9wWm9uZUV2ZW50LmJpbmQodGhpcyl9XG5cdFx0XHRcdFx0b25EcmFnSGFuZGxlRXZlbnQ9e3RoaXMuX2hhbmRsZURyYWdIYW5kbGVFdmVudC5iaW5kKHRoaXMpfVxuXHRcdFx0XHRcdG9uQnV0dG9uQ2xpY2s9e3RoaXMuX2hhbmRsZUJ1dHRvbkNsaWNrLmJpbmQodGhpcyl9XG5cdFx0XHRcdFx0bGliPXt0aGlzLmxpYnJhcnlNZXRob2RzfS8+XG5cdFx0XHQ8L1Byb3ZpZGVyPixcblx0XHRcdHRoaXMuX3JlZnMudWkuYXBwXG5cdFx0KTtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlcyBtZXNzYWdlcyBzZW50IHZpYSB0aGUgQ29tbXVuaWNhdG9yIGNsYXNzIChtYWlubHkgZnJvbSB0aGUgVmlldyBjbGFzcykuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtZXNzYWdlIC0gRGF0YSwgYXMgc2VudCBieSB0aGUgb3JpZ2luYXRvclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBNZXNzYWdlIElELlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2hhbmRsZUFwcE1lc3NhZ2U6IGZ1bmN0aW9uKG1lc3NhZ2UsIGlkKSB7XG5cdFx0c3dpdGNoIChtZXNzYWdlLmNtZCkge1xuXHRcdGNhc2UgJ2RpYWxvZyc6XG5cdFx0XHQvLyBhIGRpYWxvZyBpcyBiZWluZyByZXF1ZXN0ZWRcblx0XHRcdHRoaXMuX3Nob3dDb21tdW5pY2F0b3JEaWFsb2coXG5cdFx0XHRcdG1lc3NhZ2UuZGF0YS50aXRsZSxcblx0XHRcdFx0bWVzc2FnZS5kYXRhLm1lc3NhZ2UsXG5cdFx0XHRcdG1lc3NhZ2UuZGF0YS5idXR0b25zLFxuXHRcdFx0XHRpZFxuXHRcdFx0KTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBPbmUgb2YgdGhlIGRpYWxvZ01vZGVzIG1vZGVzLlxuXHQgKiBAcGFyYW0ge0RpYWxvZ0RhdGF9IGRhdGEgLSBSZWxldmFudCBkYXRhIHRvIHN0b3JlIGZvciB0aGUgZGlhbG9nIHRvIHVzZS5cblx0ICogQHJldHVybnMge0RpYWxvZ1Byb21pc2V9IGEgUHJvbWlzZSB3aGljaCB3aWxsIHJlc29sdmUgd2l0aCB0aGUgZGlhbG9nIHJlc3VsdHMuXG5cdCAqIEBkZXNjcmlwdGlvblxuXHQgKlx0RGlzcGxheXMgYSBkaWFsb2cgZWxlbWVudC4gSW4gdGhpcyBjYXNlIHRoYXQgbm8gY2FsbGJhY2tzIChgb25EaWFsb2dDb21wbGV0ZWAgb3Jcblx0ICogYG9uRGlhbG9nQ2FuY2VsYCBhcmUgZGVmaW5lZCwgYSBQcm9taXNlIGlzIHJldHVybmVkLCB0aGUgcmVzb2x2ZS9yZWplY3QgbWV0aG9kc1xuXHQgKiBvZiB3aGljaCBkZW5vdGUgY29tcGxldGlvbiBvciBjYW5jZWxsYXRpb24gb2YgdGhlIGRpYWxvZy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zaG93RGlhbG9nOiBmdW5jdGlvbihtb2RlLCBkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cdFx0XHR0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnNldERpYWxvZ01vZGUoXG5cdFx0XHRcdG1vZGUsXG5cdFx0XHRcdGRhdGEsXG5cdFx0XHRcdChkYXRhLCBhY3Rpb24sIGFjdGlvbl9kYXRhKSA9PiB7XG5cdFx0XHRcdFx0cmVzb2x2ZSh7IGRhdGEsIGFjdGlvbiwgYWN0aW9uX2RhdGEgfSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdCgpID0+IHtcblx0XHRcdFx0XHRyZXNvbHZlKHsgYWN0aW9uOiAnY2FuY2VsJyB9KTtcblx0XHRcdFx0fVxuXHRcdFx0KSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvblxuXHQgKiBIaWRlcyB0aGUgZGlhbG9nIChhZnRlciBhIHNob3J0IHRpbWVvdXQpIC0gdXNlcyBzdGF0ZSBjb21wYXJpc29uIHRvIGVuc3VyZVxuXHQgKiB0aGUgZGlhbG9nIGJlaW5nIGhpZGRlbiBpc24ndCBhIG5ldyBvbmUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaGlkZURpYWxvZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHN0YXRlID0gKHRoaXMuX3N0b3JlLmdldFN0YXRlKCkpLlVJLmRpYWxvZztcblxuXHRcdHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGlubmVyX3N0YXRlID0gKHRoaXMuX3N0b3JlLmdldFN0YXRlKCkpLlVJLmRpYWxvZztcblxuXHRcdFx0aWYgKHN0YXRlLmlkID09PSBpbm5lcl9zdGF0ZS5pZCkge1xuXHRcdFx0XHQvLyBzdGlsbCB0aGUgc2FtZSBkaWFsb2cgLSBjbG9zZSBpdFxuXHRcdFx0XHR0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnNldERpYWxvZ01vZGUoZGlhbG9nTW9kZXMuTk9ORSkpO1xuXHRcdFx0fVxuXHRcdH0uYmluZCh0aGlzKSwgMzAwKTtcblx0fSxcblxuXHRfc2hvd0NvbW11bmljYXRvckRpYWxvZyh0aXRsZSwgbWVzc2FnZSwgYnV0dG9ucywgY29tbXNfaWQpIHtcblx0XHR0aGlzLl9zaG93RGlhbG9nKFxuXHRcdFx0ZGlhbG9nTW9kZXMuR0VORVJBTCxcblx0XHRcdHtcblx0XHRcdFx0dGl0bGUsXG5cdFx0XHRcdG1lc3NhZ2UsXG5cdFx0XHRcdGJ1dHRvbnNcblx0XHRcdH1cblx0XHQpXG5cdFx0XHQudGhlbigoZGlhbG9nKSA9PiB7XG5cdFx0XHRcdHRoaXMuX2hpZGVEaWFsb2coKTtcblxuXHRcdFx0XHRpZiAoZGlhbG9nKSB7XG5cdFx0XHRcdFx0Ly8gc3VibWl0L2N1c3RvbSBjYWxsYmFja1xuXHRcdFx0XHRcdHRoaXMuX2NvbW1zLnNlbmQoJ3ZpZXcnLCB7XG5cdFx0XHRcdFx0XHRjbWQ6IG1lc3NhZ2VDb21tYW5kcy5ESUFMT0dfQ0FMTEJBQ0ssXG5cdFx0XHRcdFx0XHRkYXRhOiBkaWFsb2cuZGF0YSxcblx0XHRcdFx0XHRcdGFjdGlvbjogZGlhbG9nLmFjdGlvbixcblx0XHRcdFx0XHRcdGFjdGlvbl9kYXRhOiBkaWFsb2cuYWN0aW9uX2RhdGFcblx0XHRcdFx0XHR9LCBjb21tc19pZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gY2FuY2VsIGNhbGxiYWNrXG5cdFx0XHRcdFx0dGhpcy5fY29tbXMuc2VuZCgndmlldycsIHtcblx0XHRcdFx0XHRcdGNtZDogbWVzc2FnZUNvbW1hbmRzLkRJQUxPR19DQUxMQkFDS1xuXHRcdFx0XHRcdH0sIGNvbW1zX2lkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIC0gVGhlIGVsZW1lbnQncyBjb2xsZWN0aW9uIG5hbWUuXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBiZWluZyBjb2xsZWN0ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUgY29sbGVjdGlvbidzIGtleSBuYW1lLlxuXHQgKiBFbGVtZW50IHJlZmVyZW5jZSBjb2xsZWN0b3IuIENvbGxlY3RzIERPTSBlbGVtZW50cyBmcm9tIFJlYWN0IGNvbXBvbmVudHMuXG5cdCAqIEJpbmQgYW4gZWxlbWVudCByZWZlcmVuY2UgdXNpbmcgdGhlIHJlZiBhdHRyaWJ1dGUgYW5kIGNvbGxlY3RSZWYgZnJvbSB1dGlscy5qc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3JlZkNvbGxlY3RvcjogZnVuY3Rpb24oY29sbGVjdGlvbiwgZWxlbWVudCwga2V5KSB7XG5cdFx0aWYgKGVsZW1lbnQgIT09IG51bGwpIHtcblx0XHRcdGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRpZiAodHlwZW9mIHRoaXMuX3JlZnMuY29tcG9uZW50c1tjb2xsZWN0aW9uXSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHR0aGlzLl9yZWZzLmNvbXBvbmVudHNbY29sbGVjdGlvbl0gPSB7fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3JlZnMuY29tcG9uZW50c1tjb2xsZWN0aW9uXVtrZXldID0gZWxlbWVudDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3JlZnMuY29tcG9uZW50c1tjb2xsZWN0aW9uXSA9IGVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbiAtIFRoZSBlbGVtZW50J3MgY29sbGVjdGlvbiBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGNvbGxlY3Rpb24ncyBrZXkgbmFtZS5cblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIENhcHR1cmVzIG1vdW50IGV2ZW50cyBmcm9tIFJlYWN0IGNvbXBvbmVudHMgYnkgY29sbGVjdGlvbi9rZXkgaWRlbnRpZmllcnMuXG5cdCAqIElkZW50aWZpZXJzIGFyZSB0aGUgc2FtZSBhcyB0aGUgb25lcyBzdG9yZWQgd2l0aCBBcHAjX3JlZkNvbGxlY3RvclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X21vdW50RXZlbnQ6IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGtleSkge1xuXHRcdGlmICh0aGlzLl9nZXRSZWZlcmVuY2VkRWxlbWVudChjb2xsZWN0aW9uLCBrZXkpKSB7XG5cdFx0XHQvLyB2YWxpZCBjb21wb25lbnQgbW91bnRlZFxuXHRcdFx0c3dpdGNoIChjb2xsZWN0aW9uKSB7XG5cdFx0XHRjYXNlICdjYW52YXMnOlxuXHRcdFx0XHQvLyBhZGQgZHJhZyBiaW5kaW5nIGZvciB0aGUgZHJhZyBoYW5kbGVcblx0XHRcdFx0dGhpcy5fcXVldWVEcmFnRHJvcEJpbmRpbmcoJ2RyYWcnLCAnZHJhZ19oYW5kbGUnLCBudWxsLCB7XG5cdFx0XHRcdFx0b25EcmFnTW92ZTogdGhpcy5faGFuZGxlRHJhZ0hhbmRsZUV2ZW50LmJpbmQodGhpcylcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gcHJvY2VzcyBhbGwgZHJhZy9kcm9wIGJpbmRpbmdzXG5cdFx0XHRcdHRoaXMuX3NldERyYWdEcm9wQmluZGluZ3MoKTtcblx0XHRcdFx0dGhpcy5fcmVmcy5tb3VudGVkLmNhbnZhcyA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICd0ZW1wbGF0ZSc6XG5cdFx0XHRcdC8vIHRoaXMuX3F1ZXVlRHJhZ0Ryb3BCaW5kaW5nKCdkcm9wJywgY29sbGVjdGlvbiwga2V5KTtcblx0XHRcdFx0dGhpcy5fcmVmcy5tb3VudGVkLnRlbXBsYXRlID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ2Ryb3BsZXQnOlxuXHRcdFx0XHQvLyB0aGlzLl9xdWV1ZURyYWdEcm9wQmluZGluZygnZHJhZycsIGNvbGxlY3Rpb24sIGtleSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdkcm9wem9uZSc6XG5cdFx0XHRcdC8vIHRoaXMuX3F1ZXVlRHJhZ0Ryb3BCaW5kaW5nKCdkcm9wJywgJ2Ryb3B6b25lX3RhcmdldCcsIGtleSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICd2aWV3X2ZyYW1lJzpcblx0XHRcdFx0dGhpcy5fY29tbXMucmVnaXN0ZXJHdWVzdEFkZHJlc3MoXG5cdFx0XHRcdFx0J3ZpZXcnLFxuXHRcdFx0XHRcdHRoaXMuX3JlZnMuY29tcG9uZW50c1tjb2xsZWN0aW9uXS5jb250ZW50V2luZG93XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0dGhpcy5fcmVmcy5tb3VudGVkLnZpZXdfZnJhbWUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHRoaXMuX3JlZnMubW91bnRlZC5jYW52YXMgJiZcblx0XHRcdFx0dGhpcy5fcmVmcy5tb3VudGVkLnRlbXBsYXRlICYmXG5cdFx0XHRcdHRoaXMuX3JlZnMubW91bnRlZC52aWV3X2ZyYW1lXG5cdFx0XHRcdCkge1xuXHRcdFx0XHQvLyBhbGwgcmVxdWlyZWQgcmVmcyBtb3VudGVkIC0gc2V0IGFjdGl2ZVxuXHRcdFx0XHR0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnNldFVJU3RhdGUodWlTdGF0ZXMuQUNUSVZFKSk7XG5cblx0XHRcdFx0Ly8gcnVuIGluaXRpYWwgc2l6ZSBjYWxjdWxhdGlvbnNcblx0XHRcdFx0dGhpcy5faGFuZGxlV2luZG93UmVzaXplKCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J0NvbXBvbmVudCBtb3VudCBldmVudCBjYWxsZWQgYnV0IHJlZiB3YXMgbm90IGNvbGxlY3RlZC4gJyArXG5cdFx0XHRcdCdjb21wb25lbnQ6ICcgKyBjb2xsZWN0aW9uICsgKGtleSA/ICcvJyArIGtleSA6ICcnKVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gRWl0aGVyICdkcmFnJyBvciAnZHJvcCcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIC0gVGhlIHJlZiBjb2xsZWN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIHJlZiBrZXksIHdpdGhpbiB0aGUgY29sbGVjdGlvbi5cblx0ICogQHBhcmFtIHtvamJlY3R9IHNldHRpbmdzIC0gVGhlIHNldHRpbmdzIGZvciB0aGUgaW50ZXJhY3Rpb24uXG5cdCAqIEBkZXNjcmlwdGlvblxuXHQgKiBRdWV1ZXMgYSBkcmFnL2Ryb3AgRE9NIGJpbmRpbmcgdGlsbCB0aGUgbW91bnQgZXZlbnQgZm9yIHRoZSBDYW52YXMgY29tcG9uZW50LlxuXHQgKiBUaGlzIGlzIGRvbmUgYmVjYXVzZSB0aGUgY2FudmFzIGlzIHJlbGllZCB1cG9uIGFzIHRoZSBjb250YWluZXIgZm9yIGRyYWdnaW5nLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3F1ZXVlRHJhZ0Ryb3BCaW5kaW5nOiBmdW5jdGlvbih0eXBlLCBjb2xsZWN0aW9uLCBrZXksIHNldHRpbmdzKSB7XG5cdFx0aWYgKHRoaXMuX3JlZnMuY29tcG9uZW50cy5jYW52YXMpIHtcblx0XHRcdC8vIGNhbnZhcyBhbHJlYWR5IGV4aXN0cyAtIGltbWVkaWF0ZWx5IGJpbmRcblx0XHRcdHRoaXMuX3NldERyYWdEcm9wQmluZGluZ3MoW3sgdHlwZSwgY29sbGVjdGlvbiwga2V5LCBzZXR0aW5ncyB9XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHB1c2ggdG8gcXVldWVcblx0XHRcdHRoaXMucXVldWVzLmRyYWdkcm9wQmluZGluZ3MucHVzaCh7IHR5cGUsIGNvbGxlY3Rpb24sIGtleSwgc2V0dGluZ3MgfSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBQcm9jZXNzZXMgcXVldWVkIHVwIGRyYWcvZHJvcCBiaW5kaW5ncyBjcmVhdGVkIGJ5IFVJI19xdWV1ZURyYWdEcm9wQmluZGluZ3MuXG5cdCAqIEBwYXJhbSB7YXJyYXl9IFtxdWV1ZV0gLSBUaGUgYmluZGluZ3MgcXVldWUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfc2V0RHJhZ0Ryb3BCaW5kaW5nczogZnVuY3Rpb24ocXVldWUgPSB0aGlzLnF1ZXVlcy5kcmFnZHJvcEJpbmRpbmdzKSB7XG5cdFx0Ly8gYmluZCBkcmFnRHJvcCBoYW5kbGVycyB0byB0aGUgZWxlbWVudHMgaW4gdGhlIHF1ZXVlXG5cdFx0dGhpcy5fZGF0YS5VSS5kcmFnZHJvcC5kcm9wbGV0cyA9IG5ldyBEcmFnRHJvcChcblx0XHRcdHRoaXMuX3JlZnMuY29tcG9uZW50cy5jYW52YXMsXG5cdFx0XHR0aGlzLnNldHRpbmdzLCB7XG5cdFx0XHRcdGRyb3A6IHRoaXMuX2hhbmRsZURyb3BsZXREcm9wLmJpbmQodGhpcyksXG5cdFx0XHRcdGRyYWdFbmQ6IChlbGVtZW50KSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5VSS5kcmFnZHJvcC5kcm9wbGV0cy5yZXNldERyYWdQb3NpdGlvbihlbGVtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRxdWV1ZS5mb3JFYWNoKChpdGVtKSA9PiB7XG5cdFx0XHR2YXIgcmVmID0gdGhpcy5fZ2V0UmVmZXJlbmNlZEVsZW1lbnQoaXRlbS5jb2xsZWN0aW9uLCBpdGVtLmtleSksXG5cdFx0XHRcdGRhdGE7XG5cblx0XHRcdGlmIChpdGVtLmNvbGxlY3Rpb24gPT09ICdkcm9wem9uZV90YXJnZXQnKSB7XG5cdFx0XHRcdGRhdGEgPSB7XG5cdFx0XHRcdFx0em9uZV9pZDogaXRlbS5rZXlcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY3JlYXRlIGEgRHJhZ0Ryb3AgaW5zdGFuY2UgYW5kIGFzc2lnbiB0byB0aGUgcGFsbGV0IGl0ZW0gZGF0YVxuXHRcdFx0aWYgKGl0ZW0udHlwZSA9PT0gJ2RyYWcnKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuVUkuZHJhZ2Ryb3AuZHJvcGxldHMuYWRkRHJhZ2FibGUocmVmLCBpdGVtLnNldHRpbmdzLCBkYXRhKTtcblx0XHRcdH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSAnZHJvcCcpIHtcblx0XHRcdFx0dGhpcy5fZGF0YS5VSS5kcmFnZHJvcC5kcm9wbGV0cy5hZGREcm9wYWJsZShyZWYsIE9iamVjdC5kZWVwQXNzaWduKHt9LCB7XG5cdFx0XHRcdFx0YWNjZXB0OiB0aGlzLnNldHRpbmdzLnNlbGVjdG9ycy5kcm9wbGV0XG5cdFx0XHRcdH0sIGl0ZW0uc2V0dGluZ3MpLCBkYXRhKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlcyBkcm9wcyBvZiBkcm9wbGV0cyBpbnRvIGRyb3Agem9uZXMuIFdpbGwgYXR0YWNoIHRvIHRoZSB6b25lXG5cdCAqIGlmIHRoZSBkcm9wIGlzIHZhbGlkLlxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZC5cblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBiZWluZyBkcm9wcGVkIG9udG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YSBvYmplY3QsIGFzIHNldCB3aXRoIGFkZERyYWdhYmxlL2FkZERyb3BhYmxlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2hhbmRsZURyb3BsZXREcm9wOiBmdW5jdGlvbihlbGVtZW50LCB0YXJnZXQsIGRhdGEpIHtcblx0XHR2YXIgZHJvcF96b25lID0gdGhpcy5nZXREcm9wWm9uZUJ5SWQoZGF0YS56b25lX2lkKSxcblx0XHRcdGRyb3BsZXQgPSB0aGlzLmdldERyb3BsZXRCeUlkKGVsZW1lbnQuaWQpO1xuXG5cdFx0cmV0dXJuIHRoaXMuYXR0YWNoRHJvcGxldFRvRHJvcFpvbmUoZHJvcGxldCwgZHJvcF96b25lKTtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIGEgY2xpY2sgb24gYSBEcm9wIFpvbmUgYXR0YWNobWVudCBpdGVtLiBNYXkgcHJvZHVjZSBhbiBlZGl0b3Igd2luZG93LlxuXHQgKiBAcGFyYW0ge0Ryb3BsZXR9IGRyb3BsZXQgLSBUaGUgRHJvcGxldC5cblx0ICogQHBhcmFtIHtEcm9wWm9uZX0gZHJvcF96b25lIC0gVGhlIERyb3AgWm9uZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGF0dGFjaG1lbnRfaW5kZXggLSBUaGUgRHJvcCBab25lJ3MgYXR0YWNobWVudCBpbmRleCwgaWYgaXQgYXBwbGllcy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9oYW5kbGVBdHRhY2htZW50Q2xpY2s6IGZ1bmN0aW9uKGRyb3BsZXQsIGRyb3Bfem9uZSwgYXR0YWNobWVudF9pbmRleCkge1xuXHRcdHZhciBzdGF0ZSA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCk7XG5cblx0XHRpZiAoc3RhdGUuVUkuYWN0aXZlX2Ryb3BsZXRfaWQgPT09ICcnKSB7XG5cdFx0XHQvLyBvbmx5IGFsbG93IGVkaXRpbmcgaWYgdGhlcmUgaXMgbm8gZHJvcGxldCBwbGFjZW1lbnQgb2NjdXJpbmdcblx0XHRcdHRoaXMuX3Nob3dEaWFsb2coZGlhbG9nTW9kZXMuRURJVF9EUk9QTEVULCB7XG5cdFx0XHRcdGRyb3BsZXRfaWQ6IGRyb3BsZXQuaWQsXG5cdFx0XHRcdHpvbmVfaWQ6IGRyb3Bfem9uZS5pZCxcblx0XHRcdFx0YXR0YWNobWVudF9pbmRleFxuXHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKChkaWFsb2cpID0+IHtcblx0XHRcdFx0XHR0aGlzLl9oaWRlRGlhbG9nKCk7XG5cblx0XHRcdFx0XHRpZiAoZGlhbG9nLmFjdGlvbiA9PT0gJ3JlbW92ZV9kcm9wbGV0Jykge1xuXHRcdFx0XHRcdFx0dGhpcy56b25lRGV0YWNoQXR0YWNobWVudChcblx0XHRcdFx0XHRcdFx0ZGlhbG9nLmFjdGlvbl9kYXRhLnpvbmVfaWQsXG5cdFx0XHRcdFx0XHRcdGRpYWxvZy5hY3Rpb25fZGF0YS5hdHRhY2htZW50X2luZGV4XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZGlhbG9nLmFjdGlvbiAhPT0gJ2NhbmNlbCcpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2NvbW1pdERyb3BsZXRJbnRvRHJvcFpvbmUuYXBwbHkodGhpcywgW2RpYWxvZy5kYXRhXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KS5iaW5kKHRoaXMpKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgZXZlbnRzIGJlaW5nIGZpcmVkIGZyb20gYSBEcm9wbGV0XG5cdCAqIEBwYXJhbSB7UmVhY3RFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0Ryb3BsZXR9IGRyb3BsZXQgLSBUaGUgRHJvcGxldC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9oYW5kbGVEcm9wbGV0RXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBkcm9wbGV0KSB7XG5cdFx0dmFyIHN0YXRlO1xuXG5cdFx0aWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdHN0YXRlID0gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKTtcblxuXHRcdFx0aWYgKHN0YXRlLlVJLmFjdGl2ZV9kcm9wbGV0X2lkICE9PSBkcm9wbGV0LmlkKSB7XG5cdFx0XHRcdHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMuc2V0QWN0aXZlRHJvcGxldChkcm9wbGV0LmlkKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnNldEFjdGl2ZURyb3BsZXQoJycpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgZXZlbnRzIGJlaW5nIGZpcmVkIGZyb20gYSBEcm9wIFpvbmUuXG5cdCAqIEBwYXJhbSB7UmVhY3RFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0Ryb3Bab25lfSBkcm9wX3pvbmUgLSBUaGUgRHJvcCBab25lLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2hhbmRsZURyb3Bab25lRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBkcm9wX3pvbmUpIHtcblx0XHR2YXIgc3RhdGUgPSB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLFxuXHRcdFx0ZHJvcGxldDtcblxuXHRcdGlmIChldmVudC50eXBlID09PSAnY2xpY2snICYmXG5cdFx0XHRzdGF0ZS5VSS5hY3RpdmVfZHJvcGxldF9pZCAhPT0gJycgJiZcblx0XHRcdChkcm9wbGV0ID0gdGhpcy5nZXREcm9wbGV0QnlJZChzdGF0ZS5VSS5hY3RpdmVfZHJvcGxldF9pZCkpKSB7XG5cdFx0XHR0aGlzLmF0dGFjaERyb3BsZXRUb0Ryb3Bab25lKGRyb3BsZXQsIGRyb3Bfem9uZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGV2ZW50cyBmcm9tIHRoZSBkcmFnIGhhbmRsZSAoYmV0d2VlbiB0ZW1wbGF0ZSBhbmQgdmlldyBjb250YWluZXJzKS5cblx0ICogQHBhcmFtIHtSZWFjdEV2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaGFuZGxlRHJhZ0hhbmRsZUV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB3aWR0aDtcblxuXHRcdHN3aXRjaCAoZXZlbnQudHlwZSkge1xuXHRcdGNhc2UgJ21vdXNlZW50ZXInOlxuXHRcdGNhc2UgJ21vdXNlbGVhdmUnOlxuXHRcdFx0aWYgKCF0aGlzLl9kYXRhLlVJLmRyYWdIYW5kbGVNb3ZlZCkge1xuXHRcdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZW50ZXInKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy5zZXRUb29sdGlwQ29udGVudChcblx0XHRcdFx0XHRcdCdEcmFnIGhhbmRsZScsXG5cdFx0XHRcdFx0XHQnPGI+RHJhZzwvYj4gdGhpcyBoYW5kbGUgdG8gcmVzaXplIHRoZSB0ZW1wbGF0ZSBhbmQgdGhlIHZpZXcuJyArXG5cdFx0XHRcdFx0XHRcdCcgPGI+UHJlc3M8L2I+IHRvIHRvZ2dsZSB0aGUgZnVsbCBwYWdlIHZpZXcuJyxcblx0XHRcdFx0XHRcdEdMWVBIUy5SRVNJWkVfV0lEVEhcblx0XHRcdFx0XHQpKTtcblx0XHRcdFx0XHR0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnNob3dUb29sdGlwKFxuXHRcdFx0XHRcdFx0dGhpcy5fZ2V0UmVmZXJlbmNlZEVsZW1lbnQoJ2RyYWdfaGFuZGxlJyksXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHBsYWNlbWVudDogJ2xlZnQnLFxuXHRcdFx0XHRcdFx0XHRtb2RpZmllcnM6IHtcblx0XHRcdFx0XHRcdFx0XHRmbGlwOiBbJ2xlZnQnLCAncmlnaHQnXVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy5oaWRlVG9vbHRpcCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdkcmFnbW92ZSc6XG5cdFx0XHQvLyBpbmNyZW1lbXQgZHJhZ0hhbmRsZVBvc2l0aW9uIGJhc2VkIG9uIHggZGVsdGEgZnJvbSBpbnRlcmFjdCBpbnN0YW5jZVxuXHRcdFx0dGhpcy5fZGF0YS5VSS5kcmFnSGFuZGxlUG9zaXRpb24gKz0gZXZlbnQuZHg7XG5cblx0XHRcdGlmICghdGhpcy5fZGF0YS5VSS5kcmFnSGFuZGxlTW92ZWQpIHtcblx0XHRcdFx0Ly8gcmVtb3ZlIHRoZSB0b29sdGlwLCBpbiBjYXNlIGl0J3Mgc3RpbGwgYXJvdW5kXG5cdFx0XHRcdHRoaXMuX2RhdGEuVUkuZHJhZ0hhbmRsZU1vdmVkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy5oaWRlVG9vbHRpcCgpKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZmlndXJlIG91dCBoYW5kbGUgcG9zaXRpb24gaW4gJSBvZiB0aGUgc2NyZWVuIGFuZCBjb252ZXJ0IGl0IHRvIHBlcmNlbnQsXG5cdFx0XHQvLyB0aGVuIHNlbmQgc3RyYWlnaHQgdG8gX3NldFRlbXBsYXRlVmlld1JhdGlvIGZ1bmN0aW9uXG5cdFx0XHR0aGlzLl9zZXRUZW1wbGF0ZVZpZXdSYXRpbyhcblx0XHRcdFx0KCh0aGlzLl9kYXRhLlVJLmRyYWdfaGFuZGxlX3ggKyB0aGlzLl9kYXRhLlVJLmRyYWdIYW5kbGVQb3NpdGlvbikgL1xuXHRcdFx0XHRcdHRoaXMuX2RhdGEuVUkudnBfd2lkdGgpICogMTAwXG5cdFx0XHQpO1xuXG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdGNhc2UgJ3RvdWNoZW5kJzpcblx0XHRcdGlmICh0aGlzLl9kYXRhLlVJLmRyYWdIYW5kbGVQb3NpdGlvbiA8IDUgJiYgdGhpcy5fZGF0YS5VSS5kcmFnSGFuZGxlUG9zaXRpb24gPiAtNSkge1xuXHRcdFx0XHQvLyBsaXR0bGUgbW92ZW1lbnQgLSBhc3N1bWUgYSBjbGljay90YXAgb2NjdXJlZFxuXHRcdFx0XHR3aWR0aCA9ICh0aGlzLl9nZXRSZWZlcmVuY2VkRWxlbWVudCgnZHJhZ19oYW5kbGUnKSkub2Zmc2V0V2lkdGg7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2RhdGEuVUkuZHJhZ19oYW5kbGVfeCA8IHdpZHRoKSB7XG5cdFx0XHRcdFx0Ly8gc2V0IHRvIDUwLzUwXG5cdFx0XHRcdFx0dGhpcy5fc2V0VGVtcGxhdGVWaWV3UmF0aW8oNTApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHNldCB0byAwLzEwMFxuXHRcdFx0XHRcdHRoaXMuX3NldFRlbXBsYXRlVmlld1JhdGlvKDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHVwZGF0ZSBtZXRyaWNzIHdoZW5ldmVyIHdlJ3JlIHN0b3BwaW5nXG5cdFx0XHR0aGlzLl9oYW5kbGVXaW5kb3dSZXNpemUoKTtcblxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHZhcmlvdXMgbWV0cmljcyB3aGVuIHRoZSB3aW5kb3cgaGFzIGJlZW4gcmVzaXplZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2hhbmRsZVdpbmRvd1Jlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fZGF0YS5VSS5kcmFnX2hhbmRsZV94ID0gKHRoaXMuX2dldFJlZmVyZW5jZWRFbGVtZW50KCdkcmFnX2hhbmRsZScpKS5vZmZzZXRMZWZ0O1xuXHRcdHRoaXMuX2RhdGEuVUkudnBfd2lkdGggPVxuXHRcdFx0TWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcblxuXHRcdC8vIHJlc2V0IGRyYWdIYW5kbGVQb3NpdGlvbiBiZWNhdXNlIHRoZSBtZXRyaWNzIGhhdmUgY2hhbmdlZFxuXHRcdHRoaXMuX2RhdGEuVUkuZHJhZ0hhbmRsZVBvc2l0aW9uID0gMDtcblx0fSxcblxuXHQvKipcblx0ICogR2VuZXJpY2FsbHkgaGFuZGxlcyB0aGUgY2xpY2sgb2YgYW55IGJ1dHRvbiB3aXRoaW4gdGhlIFVJLlxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBidXR0b24gLSBUaGUgYnV0dG9uIGJlaW5nIGNsaWNrZWQuXG5cdCAqIEBwYXJhbSB7UmVhY3RFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0LlxuXHQgKi9cblx0X2hhbmRsZUJ1dHRvbkNsaWNrOiBmdW5jdGlvbihidXR0b24sIGV2ZW50KSB7XG5cdFx0dmFyIG9mZnNldCA9IHt9LFxuXHRcdFx0cmVjdCwgY2lyY2xlO1xuXG5cdFx0aWYgKGJ1dHRvbiAmJiBldmVudCAmJiBldmVudC5wYWdlWCAmJiBldmVudC5wYWdlWSAmJlxuXHRcdFx0KGNpcmNsZSA9IGJ1dHRvbi5xdWVyeVNlbGVjdG9yKHRoaXMuc2V0dGluZ3Muc2VsZWN0b3JzLmJ1dHRvbl9jaXJjbGUpKSkge1xuXHRcdFx0Ly8gZ2V0IG1ldHJpY3MgYW5kIG9mZnNldCBieSBzY3JvbGxcblx0XHRcdHJlY3QgPSBidXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRyZWN0LmxlZnRTY3JvbGxlZCA9IHJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldDtcblx0XHRcdHJlY3QudG9wU2Nyb2xsZWQgPSByZWN0LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldDtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIGN1cnNvciBvZmZzZXQgb24gdGhlIGJ1dHRvblxuXHRcdFx0b2Zmc2V0LmxlZnQgPSBldmVudC5wYWdlWCAtIChyZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQpO1xuXHRcdFx0b2Zmc2V0LnRvcCA9IGV2ZW50LnBhZ2VZIC0gKHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0KTtcblxuXHRcdFx0Ly8gcG9zaXRpb24gdGhlIGNpcmNsZSBiYXNlZCBvbiB0aGUgcG9pbnRlciBwb3NpdGlvbiBvbiB0aGUgYnV0dG9uXG5cdFx0XHRjaXJjbGUuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnNldHRpbmdzLmNsYXNzZXMuYnV0dG9uX2FuaW1hdGUpO1xuXHRcdFx0Y2lyY2xlLnN0eWxlLmxlZnQgPSBvZmZzZXQubGVmdCAtIChjaXJjbGUub2Zmc2V0V2lkdGggLyAyKSArICdweCc7XG5cdFx0XHRjaXJjbGUuc3R5bGUudG9wID0gb2Zmc2V0LnRvcCAtIChjaXJjbGUub2Zmc2V0SGVpZ2h0IC8gMikgKyAncHgnO1xuXHRcdFx0Y2lyY2xlLmNsYXNzTGlzdC5hZGQodGhpcy5zZXR0aW5ncy5jbGFzc2VzLmJ1dHRvbl9hbmltYXRlKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyAtICUgcmF0aW8gZm9yIHRoZSB0ZW1wbGF0ZVxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogU2V0cyB0aGUgdGVtcGxhdGUvdmlldyByYXRpbyBieSBnaXZpbmcgdGhlIHRlbXBsYXRlIGNvbnRhaW5lciBhICUgd2lkdGggYW5kXG5cdCAqIGFkanVzdGluZyB0aGUgdmlldyBjb250YWluZXIgYWNjb3JkaW5nbHkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfc2V0VGVtcGxhdGVWaWV3UmF0aW86IGZ1bmN0aW9uKHJhdGlvKSB7XG5cdFx0dGhpcy5fcmVmcy5jb21wb25lbnRzLnRlbXBsYXRlLnN0eWxlLmZsZXhCYXNpcyA9IHJhdGlvICsgJyUnO1xuXHRcdHRoaXMuX3JlZnMuY29tcG9uZW50cy52aWV3LnN0eWxlLmZsZXhCYXNpcyA9IE1hdGguYWJzKHJhdGlvIC0gMTAwKSArICclJztcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2tzIHRvIHNlZSBpZiBhIERyb3BsZXQgZHJvcCBvbiBhIERyb3AgWm9uZSBpcyB2YWxpZC4gSS5lLiBpdCBjYW4gYmUgZHJvcHBlZC5cblx0ICogQHBhcmFtIHtEcm9wbGV0fSBkcm9wbGV0IC0gVGhlIERyb3BsZXQgYmVpbmcgZHJvcHBlZC5cblx0ICogQHBhcmFtIHtEcm9wWm9uZX0gZHJvcF96b25lIC0gVGhlIERyb3AgWm9uZSBiZWluZyBkcm9wcGVkIGludG8uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaXNWYWxpZERyb3A6IGZ1bmN0aW9uKGRyb3BsZXQsIGRyb3Bfem9uZSkge1xuXHRcdHJldHVybiBkcm9wX3pvbmUud2lsbEFjY2VwdChkcm9wbGV0LCB0aGlzLl9zdG9yZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE9wdGlvbmFsbHkgZGlzcGxheXMgYW4gZWRpdGluZyBkaWFsb2cgYW5kIHRoZW4gYXR0YWNoZXMgdGhlIERyb3BsZXQgdG8gYSBEcm9wIFpvbmUuXG5cdCAqIEBwYXJhbSB7RHJvcGxldH0gZHJvcGxldCAtIFRoZSBEcm9wbGV0IHRvIGF0dGFjaFxuXHQgKiBAcGFyYW0ge0Ryb3Bab25lfSBkcm9wX3pvbmUgLSBUaGUgRHJvcCBab25lIHRvIGF0dGFjaCBpdCB0by5cblx0ICovXG5cdGF0dGFjaERyb3BsZXRUb0Ryb3Bab25lOiBmdW5jdGlvbihkcm9wbGV0LCBkcm9wX3pvbmUpIHtcblx0XHQvLyBjbGVhciBhY3RpdmUgZHJvcGxldFxuXHRcdHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMuc2V0QWN0aXZlRHJvcGxldCgnJykpO1xuXG5cdFx0Ly8gY2hlY2sgaWYgdmFsaWQgZHJvcFxuXHRcdGlmICh0aGlzLl9pc1ZhbGlkRHJvcChkcm9wbGV0LCBkcm9wX3pvbmUpKSB7XG5cdFx0XHRpZiAoZHJvcGxldC5lZGl0YWJsZSkge1xuXHRcdFx0XHQvLyBzaG93IGVkaXQgZGlhbG9nIGJlZm9yZSBhZGRpbmcgdGhlIGF0dGFjaG1lbnRcblx0XHRcdFx0dGhpcy5fc2hvd0RpYWxvZyhkaWFsb2dNb2Rlcy5FRElUX0RST1BMRVQsIHtcblx0XHRcdFx0XHRkcm9wbGV0X2lkOiBkcm9wbGV0LmlkLFxuXHRcdFx0XHRcdHpvbmVfaWQ6IGRyb3Bfem9uZS5pZCxcblx0XHRcdFx0XHRhdHRhY2htZW50X2luZGV4OiBudWxsXG5cdFx0XHRcdH0pXG5cdFx0XHRcdFx0LnRoZW4oKGRpYWxvZykgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5faGlkZURpYWxvZygpO1xuXG5cdFx0XHRcdFx0XHRpZiAoZGlhbG9nLmFjdGlvbiA9PT0gJ3N1Ym1pdCcpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fY29tbWl0RHJvcGxldEludG9Ecm9wWm9uZS5hcHBseSh0aGlzLCBbZGlhbG9nLmRhdGFdKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fcG9zdERyb3BsZXRBdHRhY2htZW50KGRyb3BsZXQsIGRpYWxvZy5kYXRhKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGFkZCBhdHRhY2htZW50IHdpdGhvdXQgZGlhbG9nXG5cdFx0XHRcdHRoaXMuem9uZUFkZEF0dGFjaG1lbnQoXG5cdFx0XHRcdFx0ZHJvcF96b25lLmlkLFxuXHRcdFx0XHRcdGRyb3BsZXQuaWQsXG5cdFx0XHRcdFx0ZHJvcGxldC5kYXRhXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0dGhpcy5fcG9zdERyb3BsZXRBdHRhY2htZW50KGRyb3BsZXQsIGRyb3BsZXQuZGF0YSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5kcm9wWm9uZS53YXJuT25CYWRQbGFjZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5fc2hvd0RpYWxvZyhkaWFsb2dNb2Rlcy5HRU5FUkFMLCB0aGlzLmRpYWxvZ3MuZHJvcGxldEJhZFBsYWNlbWVudClcblx0XHRcdFx0XHQudGhlbih0aGlzLl9oaWRlRGlhbG9nKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUGVyZm9ybSBhY3Rpb25zIGFmdGVyIERyb3BsZXQgYXR0YWNobWVudC5cblx0ICogQHBhcmFtIHtEcm9wbGV0fSBkcm9wbGV0IC0gVGhlIERyb3BsZXQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gVGhlIERyb3BsZXQgZGF0YSB0byBiZSBzZXQgaW50byB0aGUgRHJvcCBab25lLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Bvc3REcm9wbGV0QXR0YWNobWVudDogZnVuY3Rpb24oZHJvcGxldCwgZGF0YSkge1xuXHRcdHZhciBzdGF0ZSA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCksXG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMoc3RhdGUuem9uZXMpLFxuXHRcdFx0bm90aWNlID0gZmFsc2UsXG5cdFx0XHRrZXksIGRyb3BsZXRfb3V0cHV0O1xuXG5cdFx0Ly8gc2hvdWxkIHdlIGRpc3BsYXkgYSBcImZpcnN0IGRyb3BsZXRcIiBub3RpY2U/XG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MuZHJvcFpvbmUubm90aWNlT25GaXJzdFBsYWNlbWVudCAmJlxuXHRcdFx0KCFzdGF0ZS5hcHAuZmlyc3RfdmFsaWRfZHJvcCAmJiBrZXlzLmxlbmd0aCA+IDApKSB7XG5cdFx0XHQvLyBzZXQgZmlyc3QgZHJvcGxldCBzdGF0ZVxuXHRcdFx0dGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy5jb21wbGV0ZUZpcnN0RHJvcCgpKTtcblxuXHRcdFx0Ly8gZm9ybWF0IHRoZSBkcm9wbGV0IGZvciBkaXNwbGF5XG5cdFx0XHRkcm9wbGV0X291dHB1dCA9IFRlbXBsYXRlLmVudGl0aWVzKFxuXHRcdFx0XHRUZW1wbGF0ZS5yZW5kZXJEcm9wbGV0KFxuXHRcdFx0XHRcdGRyb3BsZXQsXG5cdFx0XHRcdFx0T2JqZWN0LmRlZXBBc3NpZ24oe30sIGRyb3BsZXQuZGF0YSwgZGF0YSksXG5cdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRmYWxzZVxuXHRcdFx0XHQpXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBzaG93IGRpYWxvZ1xuXHRcdFx0dGhpcy5fc2hvd0RpYWxvZyhcblx0XHRcdFx0ZGlhbG9nTW9kZXMuR0VORVJBTCxcblx0XHRcdFx0dGhpcy5kaWFsb2dzLmZpcnN0RHJvcGxldERyb3AoZHJvcGxldF9vdXRwdXQpXG5cdFx0XHQpXG5cdFx0XHRcdC50aGVuKHRoaXMuX2hpZGVEaWFsb2cpO1xuXHRcdH1cblxuXHRcdC8vIHNob3VsZCB3ZSBkaXNwbGF5IGEgXCJsYXN0IGRyb3BsZXRcIiBub3RpY2U/XG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MuZHJvcFpvbmUubm90aWNlT25MYXN0UGxhY2VtZW50ICYmXG5cdFx0XHQoIXN0YXRlLmFwcC5sYXN0X3ZhbGlkX2Ryb3AgJiYga2V5cy5sZW5ndGggPT09IHRoaXMuX2RhdGEucGFsbGV0Lmxlbmd0aCkpIHtcblx0XHRcdG5vdGljZSA9IHRydWU7XG5cblx0XHRcdC8vIGNoZWNrIHpvbmVzIGFsbCBoYXZlIHBsYWNlbWVudHNcblx0XHRcdGZvciAoa2V5IGluIHN0YXRlLnpvbmVzKSB7XG5cdFx0XHRcdGlmIChzdGF0ZS56b25lc1trZXldLmF0dGFjaG1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdG5vdGljZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChub3RpY2UpIHtcblx0XHRcdFx0Ly8gc2hvdyBzZXQgbGFzdCBkcm9wIHN0YXRlXG5cdFx0XHRcdHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMuY29tcGxldGVMYXN0RHJvcCgpKTtcblxuXHRcdFx0XHQvLyBzaG93IGRpYWxvZ1xuXHRcdFx0XHR0aGlzLl9zaG93RGlhbG9nKFxuXHRcdFx0XHRcdGRpYWxvZ01vZGVzLkdFTkVSQUwsXG5cdFx0XHRcdFx0dGhpcy5kaWFsb2dzLmxhc3REcm9wbGV0RHJvcFxuXHRcdFx0XHQpXG5cdFx0XHRcdFx0LnRoZW4odGhpcy5faGlkZURpYWxvZyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIFRoZSBEcm9wbGV0IGRhdGEgdG8gYmUgc2V0IGludG8gdGhlIERyb3AgWm9uZS5cblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIENhbGxlZCBhZnRlciBlZGl0aW5nIGRpYWxvZyBoYXMgYmVlbiBjb21wbGV0ZWQsIGVpdGhlciBhZGRzIGEgbmV3XG5cdCAqIERyb3AgWm9uZSBhdHRhY2htZW50IG9yIGVkaXRzIGFuIGV4aXN0aW5nIG9uZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jb21taXREcm9wbGV0SW50b0Ryb3Bab25lOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0dmFyIGRpYWxvZyA9ICh0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpKS5VSS5kaWFsb2c7XG5cblx0XHQvLyByZXNldCBkaWFsb2cgc3RhdGUgdG8gbm90aGluZ1xuXHRcdHRoaXMuX2hpZGVEaWFsb2coKTtcblxuXHRcdC8vIGRyb3BsZXQgYmVpbmcgZWRpdGVkIHByaW9yIHRvIG9yIGR1cmluZyBhdHRhdGNobWVudFxuXHRcdGlmIChkaWFsb2cuZGF0YS5hdHRhY2htZW50X2luZGV4ID09PSBudWxsKSB7XG5cdFx0XHQvLyBubyBhdHRhY2htZW50IGluZGV4IC0gdGhpcyBpcyBhIG5ldyBkcm9wXG5cdFx0XHR0aGlzLnpvbmVBZGRBdHRhY2htZW50KFxuXHRcdFx0XHRkaWFsb2cuZGF0YS56b25lX2lkLFxuXHRcdFx0XHRkaWFsb2cuZGF0YS5kcm9wbGV0X2lkLFxuXHRcdFx0XHRkYXRhXG5cdFx0XHQpO1xuXHRcdH0gZWxzZXtcblx0XHRcdHRoaXMuem9uZUVkaXRBdHRhY2htZW50KFxuXHRcdFx0XHRkaWFsb2cuZGF0YS56b25lX2lkLFxuXHRcdFx0XHRkaWFsb2cuZGF0YS5hdHRhY2htZW50X2luZGV4LFxuXHRcdFx0XHRkYXRhXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQWRkcyBhIERyb3AgWm9uZSBhdHRhY2htZW50LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gem9uZV9pZCAtIFRoZSBEcm9wIFpvbmUgSUQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBkcm9wbGV0X2lkIC0gVGhlIERyb3BsZXQgSUQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gVGhlIGRyb3BsZXQgZGF0YSB0byBiZSBzZXQgaW50byB0aGUgRHJvcCBab25lLlxuXHQgKi9cblx0em9uZUFkZEF0dGFjaG1lbnQ6IGZ1bmN0aW9uKHpvbmVfaWQsIGRyb3BsZXRfaWQsIGRhdGEpIHtcblx0XHR0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnpvbmVBZGRBdHRhY2htZW50KFxuXHRcdFx0em9uZV9pZCxcblx0XHRcdGRyb3BsZXRfaWQsXG5cdFx0XHR0cnVlLFxuXHRcdFx0ZGF0YVxuXHRcdCkpO1xuXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3Mudmlldy5hdXRvVXBkYXRlKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVWaWV3KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBFZGl0cyBhbiBleGlzdGluZyBEcm9wIFpvbmUgYXR0YWNobWVudCBhdCBgYXR0YWNobWVudF9pbmRleGAgaW5kZXguXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB6b25lX2lkIC0gVGhlIERyb3AgWm9uZSBJRC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGF0dGFjaG1lbnRfaW5kZXggLSBUaGUgZXhpc3RpbmcgYXR0YWNobWVudCBpbmRleC5cblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBUaGUgbmV3IGRyb3BsZXQgZGF0YSB0byBiZSByZXBsYWNlZCBpbnRvIHRoZSBEcm9wIFpvbmUuXG5cdCAqL1xuXHR6b25lRWRpdEF0dGFjaG1lbnQ6IGZ1bmN0aW9uKHpvbmVfaWQsIGF0dGFjaG1lbnRfaW5kZXgsIGRhdGEpIHtcblx0XHR0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnpvbmVFZGl0QXR0YWNobWVudChcblx0XHRcdHpvbmVfaWQsXG5cdFx0XHRhdHRhY2htZW50X2luZGV4LFxuXHRcdFx0ZGF0YVxuXHRcdCkpO1xuXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3Mudmlldy5hdXRvVXBkYXRlKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVWaWV3KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZXRhY2hlcyBhIERyb3BsZXQgYXR0YWNobWVudCBmcm9tIGEgRHJvcCBab25lIGJ5IGl0cyBgYXR0YWNobWVudF9pbmRleGAgaW5kZXguXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB6b25lX2lkIC0gRHJvcCBab25lIElELlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYXR0YWNobWVudF9pbmRleCAtIFRoZSBleGlzdGluZyBhdHRhY2htZW50IGluZGV4LlxuXHQgKi9cblx0em9uZURldGFjaEF0dGFjaG1lbnQ6IGZ1bmN0aW9uKHpvbmVfaWQsIGF0dGFjaG1lbnRfaW5kZXgpIHtcblx0XHR0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnpvbmVEZXRhY2hBdHRhY2htZW50KFxuXHRcdFx0em9uZV9pZCxcblx0XHRcdGF0dGFjaG1lbnRfaW5kZXhcblx0XHQpKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0cmlldmUgYSB6b25lJ3MgYXR0YWNobWVudCBieSBpdHMgYGF0dGFjaG1lbnRfaW5kZXhgIGluZGV4LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gem9uZV9pZCAtIERyb3AgWm9uZSBJRC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGF0dGFjaG1lbnRfaW5kZXggLSBUaGUgZXhpc3RpbmcgYXR0YWNobWVudCBpbmRleC5cblx0ICovXG5cdHpvbmVHZXRBdHRhY2htZW50OiBmdW5jdGlvbih6b25lX2lkLCBhdHRhY2htZW50X2luZGV4KSB7XG5cdFx0dmFyIHpvbmUsXG5cdFx0XHRzdGF0ZSA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCk7XG5cblx0XHRpZiAoc3RhdGUuem9uZXMgJiZcblx0XHRcdCh6b25lID0gc3RhdGUuem9uZXNbem9uZV9pZF0pICYmXG5cdFx0XHR6b25lLmF0dGFjaG1lbnRzICYmXG5cdFx0XHR6b25lLmF0dGFjaG1lbnRzLmxlbmd0aCA+IGF0dGFjaG1lbnRfaW5kZXhcblx0XHQpIHtcblx0XHRcdHJldHVybiB6b25lLmF0dGFjaG1lbnRzW2F0dGFjaG1lbnRfaW5kZXhdO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZW5kcyBhIGtleSB0aGUgVmlldyBmcmFtZSBmb3IgdXBkYXRpbmcuXG5cdCAqL1xuXHRfdXBkYXRlVmlldzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKTtcblxuXHRcdHRoaXMuX2NvbW1zLnNlbmQoJ3ZpZXcnLCB7XG5cdFx0XHRjbWQ6IG1lc3NhZ2VDb21tYW5kcy5SRUxPQUQsXG5cdFx0XHRkYXRhOiB7XG5cdFx0XHRcdG1hcmt1cDogdGhpcy5fdGVtcGxhdGUucmVuZGVyQXNIVE1MKFxuXHRcdFx0XHRcdHN0YXRlLnpvbmVzXG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogT2J0YWlucyBhbiBlbGVtZW50IHN0b3JlZCBpbiB0aGUgaW50ZXJuYWwgcmVmcyBjb2xsZWN0aW9uXG5cdCAqL1xuXHRfZ2V0UmVmZXJlbmNlZEVsZW1lbnQ6IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGtleSkge1xuXHRcdHZhciByZWY7XG5cblx0XHRpZiAoXG5cdFx0XHQoKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnIHx8ICFrZXkpICYmIChyZWYgPSB0aGlzLl9yZWZzLmNvbXBvbmVudHNbY29sbGVjdGlvbl0pKSB8fFxuXHRcdFx0KHJlZiA9IHRoaXMuX3JlZnMuY29tcG9uZW50c1tjb2xsZWN0aW9uXVtrZXldKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIHJlZjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2VkIGVsZW1lbnQgYXQgJyArIGNvbGxlY3Rpb24gKyAnKCcgKyBrZXkgK1xuXHRcdFx0XHQnKSBjb3VsZCBub3QgYmUgZm91bmQuJyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgYSBEcm9wbGV0IGluc3RhbmNlIGJ5IGl0cyBJRC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gSUQgb2YgdGhlIERyb3BsZXQgdG8gcmV0cmlldmUuXG5cdCAqL1xuXHRnZXREcm9wbGV0QnlJZDogZnVuY3Rpb24oaWQpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YS5wYWxsZXQuZmluZCgoZWxlbWVudCkgPT4ge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQuaWQgPT09IGlkO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgYSBEcm9wIFpvbmUgaW5zdGFuY2UgYnkgaXRzIElELlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBJRCBvZiB0aGUgRHJvcCBab25lIHRvIHJldHJpZXZlLlxuXHQgKi9cblx0Z2V0RHJvcFpvbmVCeUlkOiBmdW5jdGlvbihpZCkge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhLmRyb3Bfem9uZXNbaWRdIHx8IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGF0dGFjaG1lbnQgLSBUaGUgZWxlbWVudCB0byBhdHRhY2ggdG8uXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBiZWluZyBhdHRhY2hlZC5cblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgcG9wcGVyIGBvcHRpb25zYCBvYmplY3QgKHNlZSBsaW5rKS5cblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIFVzaW5nICdwb3BwZXInLCBzZXRzIHRoZSBhbiBhdHRhY2htZW50IGZyb20gdGhlIGBhdHRhY2htZW50YCBub2RlIHRvIGFuIGBlbGVtZW50YFxuXHQgKiBkZWZpbmluZyB0aGUgXCJwb3B1cFwiIHRvIGJlIGRpc3BsYXllZC5cblx0ICogQHNlZSBodHRwczovL3BvcHBlci5qcy5vcmcvcG9wcGVyLWRvY3VtZW50YXRpb24uaHRtbCNuZXdfUG9wcGVyX25ld1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3NldFVJUG9wcGVyQXR0YWNobWVudDogZnVuY3Rpb24oYXR0YWNobWVudCwgZWxlbWVudCwgb3B0aW9ucykge1xuXHRcdHZhciBhdHRhY2hlZDtcblxuXHRcdGlmIChhdHRhY2htZW50IGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbGVtZW50KSB7XG5cdFx0XHRhdHRhY2hlZCA9IGF0dGFjaG1lbnQ7XG5cdFx0fSBlbHNlIGlmIChhdHRhY2htZW50ICYmIGF0dGFjaG1lbnQuc2VsZWN0b3IpIHtcblx0XHRcdGF0dGFjaGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhdHRhY2htZW50LnNlbGVjdG9yKTtcblx0XHR9XG5cblx0XHRpZiAoYXR0YWNoZWQpIHtcblx0XHRcdHJldHVybiBuZXcgUG9wcGVyKFxuXHRcdFx0XHRhdHRhY2hlZCxcblx0XHRcdFx0ZWxlbWVudCxcblx0XHRcdFx0YXR0YWNobWVudC5vcHRpb25zIHx8IG9wdGlvbnNcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignX3NldFVJUG9wcGVyQXR0YWNobWVudDogQXR0YWNobWVudCBvciBzZWxlY3RvciBjb3VsZCBub3QgYmUgZm91bmQuJyk7XG5cdFx0fVxuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBVSTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2xpYi9VSS5qc3giLCIvLyBKUyBQb2x5ZmlsbHMgLSBkb2Vzbid0IGV4cG9ydCBhbnl0aGluZywganVzdCBtb2RpZmllcyBleGlzdGluZyBPYmplY3Qgc3BlY3Ncbk9iamVjdC5kZWVwQXNzaWduID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJBcmdzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgdG8sIGZyb20sIGluZGV4LCBrZXk7XG5cblx0aWYgKHRhcmdldCA9PSBudWxsKSB7IC8vIFR5cGVFcnJvciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuXHR9XG5cblx0dG8gPSAodHlwZW9mIHZhckFyZ3MgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0KEFycmF5LmlzQXJyYXkodmFyQXJncykgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikpID9cblx0XHRBcnJheSh0YXJnZXQpIDogLy8gYXJyYXlzIHRvIHJldGFpbiB0aGVpciBpZGVudGl0eVxuXHRcdE9iamVjdCh0YXJnZXQpOyAvLyBvdGhlcndpc2UgdXNlIGFuIG9iamVjdFxuXG5cdGZvciAoaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcblx0XHRmcm9tID0gYXJndW1lbnRzW2luZGV4XTtcblxuXHRcdGlmIChmcm9tICE9IG51bGwgfHwgdHlwZW9mIGZyb20gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRmb3IgKGtleSBpbiBmcm9tKSB7XG5cdFx0XHRcdGlmIChmcm9tLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIGZyb21ba2V5XSA9PT0gJ29iamVjdCcgJiYgZnJvbVtrZXldICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHRvW2tleV0gPSBPYmplY3QuZGVlcEFzc2lnbihcblx0XHRcdFx0XHRcdFx0KEFycmF5LmlzQXJyYXkoZnJvbVtrZXldKSA/IFtdIDoge30pLFxuXHRcdFx0XHRcdFx0XHR0b1trZXldLFxuXHRcdFx0XHRcdFx0XHRmcm9tW2tleV1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuLyoqXG4gKiBDdXJyeSBpbXBsZW1lbnRhdGlvbiBmb3IgZnVuY3Rpb25zXG4gKi9cbkZ1bmN0aW9uLnByb3RvdHlwZS5jdXJyeSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG5cdFx0Zm4gPSB0aGlzO1xuXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHQvLyByZXR1cm4gcmVzdWx0IG9mIG9yaWdpbmFsIGZ1bmN0aW9uIHdpdGggY3VycmllZCBhcmd1bWVudHMgYmVmb3JlIGludm9jYXRpb24gYXJndW1lbnRzXG5cdFx0cmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcblx0fTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9saWIvcG9seWZpbGxzLmpzIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAncmVkdXgnO1xuXG5pbXBvcnQgZGVmYXVsdFN0YXRlIGZyb20gJy4uL2Fzc2V0cy9kZWZhdWx0LXN0YXRlJztcbmltcG9ydCB7IGFjdGlvblR5cGVzLCB1aVN0YXRlcywgdG91ck1vZGVzIH0gZnJvbSAnLi4vYXNzZXRzL2NvbnN0YW50cyc7XG5pbXBvcnQgU3RvcmFnZSBmcm9tICcuLi9saWIvU3RvcmFnZSc7XG5cbnZhciBkaWFsb2dfaWQgPSAwLFxuXHRzdG9yYWdlID0gbmV3IFN0b3JhZ2UoJ3RhZ19hcHAnKTtcblxuLyoqXG4gKiBTZXRzIGFwcGxpY2F0aW9uIHN0YXRlIHZhbHVlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFwcChzdGF0ZSA9IGRlZmF1bHRTdGF0ZS5hcHAsIGFjdGlvbikge1xuXHR2YXIgYWN0aXZlLCBuZXdzdGF0ZSwga2V5O1xuXG5cdHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcblx0Ly8gc2V0IHVpIHN0YXRlXG5cdGNhc2UgYWN0aW9uVHlwZXMuVUlfU1RBVEU6XG5cdFx0Ly8gc2V0ICdhY3RpdmUnIGZsYWcgYmFzZWQgb24gdGhlIHVpX3N0YXRlIHZhbHVlXG5cdFx0c3dpdGNoIChhY3Rpb24udWlfc3RhdGUpIHtcblx0XHRjYXNlIHVpU3RhdGVzLkFDVElWRTpcblx0XHRcdGFjdGl2ZSA9IHRydWU7XG5cdFx0XHRicmVhaztcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRhY3RpdmUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRuZXdzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG5cdFx0XHR1aV9zdGF0ZTogYWN0aW9uLnVpX3N0YXRlLFxuXHRcdFx0YWN0aXZlXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gc3RvcmVTdGF0ZShuZXdzdGF0ZSwgJ2FwcCcpO1xuXG5cdGNhc2UgYWN0aW9uVHlwZXMuUkVTRVRfQVBQOlxuXHRcdG5ld3N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcblx0XHRcdGZpcnN0X3ZhbGlkX2Ryb3A6IGZhbHNlLFxuXHRcdFx0bGFzdF92YWxpZF9kcm9wOiBmYWxzZVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHN0b3JlU3RhdGUobmV3c3RhdGUsICdhcHAnKTtcblxuXHRjYXNlIGFjdGlvblR5cGVzLkNPTVBMRVRFX0ZJUlNUX0RST1A6XG5cdGNhc2UgYWN0aW9uVHlwZXMuQ09NUExFVEVfTEFTVF9EUk9QOlxuXHRcdGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9uVHlwZXMuQ09NUExFVEVfRklSU1RfRFJPUCkge1xuXHRcdFx0bmV3c3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuXHRcdFx0XHRmaXJzdF92YWxpZF9kcm9wOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3c3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuXHRcdFx0XHRsYXN0X3ZhbGlkX2Ryb3A6IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdG9yZVN0YXRlKG5ld3N0YXRlLCAnYXBwJyk7XG5cblx0ZGVmYXVsdDpcblx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn1cblxuLyoqXG4gKiBTZXRzIGRyb3Agem9uZSBzdGF0ZSB2YWx1ZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHpvbmVzKHN0YXRlID0gZGVmYXVsdFN0YXRlLnpvbmVzLCBhY3Rpb24pIHtcblx0dmFyIHpvbmVzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuXG5cdHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcblx0Y2FzZSBhY3Rpb25UeXBlcy5aT05FX0FERF9BVFRBQ0hNRU5UOlxuXHRcdGlmICghem9uZXNbYWN0aW9uLmlkXSkge1xuXHRcdFx0em9uZXNbYWN0aW9uLmlkXSA9IHtcblx0XHRcdFx0YXR0YWNobWVudHM6IFtdXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIGF0dGFjaCB0aGUgZHJvcGxldFxuXHRcdHpvbmVzW2FjdGlvbi5pZF0uYXR0YWNobWVudHMucHVzaCh7XG5cdFx0XHRkcm9wbGV0X2lkOiBhY3Rpb24uZHJvcGxldF9pZCxcblx0XHRcdGRhdGE6IGFjdGlvbi5kYXRhXG5cdFx0fSk7XG5cblx0XHRicmVhaztcblxuXHRjYXNlIGFjdGlvblR5cGVzLlpPTkVfRURJVF9BVFRBQ0hNRU5UOlxuXHRcdGlmICh6b25lc1thY3Rpb24uaWRdLmF0dGFjaG1lbnRzW2FjdGlvbi5hdHRhY2htZW50X2luZGV4XSkge1xuXHRcdFx0em9uZXNbYWN0aW9uLmlkXS5hdHRhY2htZW50c1thY3Rpb24uYXR0YWNobWVudF9pbmRleF0uZGF0YSA9IGFjdGlvbi5kYXRhO1xuXHRcdH1cblxuXHRcdGJyZWFrO1xuXG5cdGNhc2UgYWN0aW9uVHlwZXMuWk9ORV9ERVRBQ0hfQVRUQUNITUVOVDpcblx0XHQvLyBkZXRhY2ggdGhlIGF0dGFjaG1lbnQgYnkgaW5kZXhcblx0XHRpZiAoYWN0aW9uLmF0dGFjaG1lbnRfaW5kZXggIT09IG51bGwgJiZcblx0XHRcdGFjdGlvbi5hdHRhY2htZW50X2luZGV4IDwgem9uZXNbYWN0aW9uLmlkXS5hdHRhY2htZW50cy5sZW5ndGgpIHtcblx0XHRcdHpvbmVzW2FjdGlvbi5pZF0uYXR0YWNobWVudHMuc3BsaWNlKGFjdGlvbi5hdHRhY2htZW50X2luZGV4LCAxKTtcblx0XHR9XG5cblx0XHRicmVhaztcblxuXHRjYXNlIGFjdGlvblR5cGVzLlpPTkVfQ0xFQVJfQUxMX0FUVEFDSE1FTlRTOlxuXHRcdHpvbmVzID0ge307XG5cdFx0YnJlYWs7XG5cblx0ZGVmYXVsdDpcblx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cblxuXHRyZXR1cm4gc3RvcmVTdGF0ZSh6b25lcywgJ3pvbmVzJyk7XG59XG5cbi8qKlxuICogU2V0cyBVSSBzdGF0ZSB2YWx1ZXMuIFRoaXMgc3RhdGUgY29sbGVjdGlvbiBpcyBub24gcGVyc2lzdGFudCBhbmQgd2lsbCBub3QgYmUgc3RvcmVkXG4gKiB3aXRoaW4gbG9jYWwvc2Vzc2lvbiBzdG9yYWdlLiBEdWUgdG8gdGhhdCBmYWN0LCBpdCBpcyBzYWZlIHRvIHBsYWNlIGNpcmN1bGFyIHJlZmVyZW5jZXMsXG4gKiBmdW5jdGlvbnMgYW5kIGxhcmdlIHF1YW50aXRpZXMgb2YgZGF0YSBpbiBoZXJlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVUkoc3RhdGUgPSBkZWZhdWx0U3RhdGUuVUksIGFjdGlvbikge1xuXHRzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cdGNhc2UgYWN0aW9uVHlwZXMuU0VUX0RJQUxPR19NT0RFOlxuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuXHRcdFx0ZGlhbG9nOiB7XG5cdFx0XHRcdG1vZGU6IGFjdGlvbi5tb2RlLFxuXHRcdFx0XHRkYXRhOiBhY3Rpb24uZGF0YSxcblx0XHRcdFx0b25EaWFsb2dDb21wbGV0ZTogYWN0aW9uLm9uRGlhbG9nQ29tcGxldGUsXG5cdFx0XHRcdG9uRGlhbG9nQ2FuY2VsOiBhY3Rpb24ub25EaWFsb2dDYW5jZWwsXG5cdFx0XHRcdG92ZXJsYXk6ICh0eXBlb2YgYWN0aW9uLm92ZXJsYXkgIT09ICd1bmRlZmluZWQnID8gYWN0aW9uLm92ZXJsYXkgOiB0cnVlKSxcblx0XHRcdFx0YXR0YWNobWVudDogYWN0aW9uLmF0dGFjaG1lbnQsXG5cdFx0XHRcdGlkOiAnZGlhbG9nLScgKyAoKytkaWFsb2dfaWQpXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0Y2FzZSBhY3Rpb25UeXBlcy5TRVRfVE9VUl9TVEFHRTpcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcblx0XHRcdHRvdXJfc3RhZ2U6IGFjdGlvbi5zdGFnZVxuXHRcdH0pO1xuXG5cdGNhc2UgYWN0aW9uVHlwZXMuU0VUX0FDVElWRV9EUk9QTEVUOlxuXHRcdC8vIHNldCB0aGUgYWN0aXZlIGRyb3BsZXQgKGkuZS4gdGhlIG9uZSB0aGF0IHdpbGwgYmUgXCJkcm9wcGVkXCIgd2hlbiBhXG5cdFx0Ly8gZHJvcCB6b25lIGlzIG5leHQgY2xpY2tlZFxuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuXHRcdFx0YWN0aXZlX2Ryb3BsZXRfaWQ6IGFjdGlvbi5kcm9wbGV0X2lkXG5cdFx0fSk7XG5cblx0Y2FzZSBhY3Rpb25UeXBlcy5TSE9XX1RPT0xUSVA6XG5cdGNhc2UgYWN0aW9uVHlwZXMuSElERV9UT09MVElQOlxuXHRcdGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9uVHlwZXMuU0hPV19UT09MVElQKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcblx0XHRcdFx0dG9vbHRpcDoge1xuXHRcdFx0XHRcdHNob3c6IHRydWUsXG5cdFx0XHRcdFx0YXR0YWNobWVudDogYWN0aW9uLmF0dGFjaG1lbnQsXG5cdFx0XHRcdFx0b3B0aW9uczogYWN0aW9uLm9wdGlvbnMsXG5cdFx0XHRcdFx0Y29udGVudDogc3RhdGUudG9vbHRpcC5jb250ZW50LFxuXHRcdFx0XHRcdHRpdGxlOiBzdGF0ZS50b29sdGlwLnRpdGxlLFxuXHRcdFx0XHRcdGljb25HbHlwaDogc3RhdGUudG9vbHRpcC5pY29uR2x5cGhcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuXHRcdFx0XHR0b29sdGlwOiB7XG5cdFx0XHRcdFx0c2hvdzogZmFsc2UsXG5cdFx0XHRcdFx0YXR0YWNobWVudDogbnVsbCxcblx0XHRcdFx0XHRvcHRpb25zOiBudWxsLFxuXHRcdFx0XHRcdGNvbnRlbnQ6ICcnLFxuXHRcdFx0XHRcdHRpdGxlOiAnJyxcblx0XHRcdFx0XHRpY29uR2x5cGg6ICcnXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRjYXNlIGFjdGlvblR5cGVzLlNFVF9UT09MVElQX0NPTlRFTlQ6XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG5cdFx0XHR0b29sdGlwOiB7XG5cdFx0XHRcdHNob3c6IHN0YXRlLnRvb2x0aXAuc2hvdyxcblx0XHRcdFx0Y29udGVudDogYWN0aW9uLmNvbnRlbnQsXG5cdFx0XHRcdHRpdGxlOiBhY3Rpb24udGl0bGUsXG5cdFx0XHRcdGljb25HbHlwaDogYWN0aW9uLmljb25HbHlwaFxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdGRlZmF1bHQ6XG5cdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG59XG5cbi8qKlxuICogU3RvcmVzIHN0YXRlIGludG8gbG9jYWwvc2Vzc2lvbiBzdG9yYWdlIGZvciByZWNhbGwgb24gcmVsb2FkaW5nIHRoZSBhcHAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzdG9yZVN0YXRlKHN0YXRlLCBrZXkpIHtcblx0dmFyIGN1cnJlbnRfc3RhdGUgPSBzdG9yYWdlLmdldCgnc3RhdGUnKSxcblx0XHRuZXdfc3RhdGU7XG5cblx0bmV3X3N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFN0YXRlLCBjdXJyZW50X3N0YXRlKTtcblx0bmV3X3N0YXRlW2tleV0gPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG5cdG5ld19zdGF0ZS5VSSA9IG51bGw7XG5cblx0c3RvcmFnZS5zZXQoJ3N0YXRlJywgbmV3X3N0YXRlKTtcblxuXHRyZXR1cm4gc3RhdGU7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgY29tYmluZVJlZHVjZXJzKHtcblx0YXBwLFxuXHR6b25lcyxcblx0VUlcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvc3RhdGUvcmVkdWNlcnMuanMiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFzZTY0LWpzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGltcG9ydCB1cmwoLy9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PUZpcmErTW9ub3xNdWxpOjQwMCw3MDApO1wiLCBcIlwiXSk7XG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogcmVzZXQgKi9cXG4qIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG5cXG5odG1sLCBib2R5LCBkaXYsIHNwYW4sIG9iamVjdCwgaWZyYW1lLFxcbmgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIHAsIGJsb2NrcXVvdGUsIHByZSxcXG5hYmJyLCBhZGRyZXNzLCBjaXRlLCBjb2RlLFxcbmRlbCwgZGZuLCBlbSwgaW1nLCBpbnMsIGtiZCwgcSwgc2FtcCxcXG5zbWFsbCwgc3Ryb25nLCBzdWIsIHN1cCwgdmFyLFxcbmIsIGksXFxuZGwsIGR0LCBkZCwgb2wsIHVsLCBsaSxcXG5maWVsZHNldCwgZm9ybSwgbGFiZWwsIGxlZ2VuZCxcXG50YWJsZSwgY2FwdGlvbiwgdGJvZHksIHRmb290LCB0aGVhZCwgdHIsIHRoLCB0ZCxcXG5hcnRpY2xlLCBhc2lkZSwgY2FudmFzLCBkZXRhaWxzLCBmaWdjYXB0aW9uLCBmaWd1cmUsXFxuZm9vdGVyLCBoZWFkZXIsIGhncm91cCwgbWVudSwgbmF2LCBzZWN0aW9uLCBzdW1tYXJ5LFxcbnRpbWUsIG1hcmssIGF1ZGlvLCB2aWRlbyB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgYm9yZGVyOiAwO1xcbiAgb3V0bGluZTogMDtcXG4gIGZvbnQtc2l6ZTogMTAwJTtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgbWluLWhlaWdodDogMDtcXG4gIG1pbi13aWR0aDogMDsgfVxcblxcbmJvZHkge1xcbiAgbGluZS1oZWlnaHQ6IDE7IH1cXG5cXG5hcnRpY2xlLCBhc2lkZSwgZGV0YWlscywgZmlnY2FwdGlvbiwgZmlndXJlLFxcbmZvb3RlciwgaGVhZGVyLCBoZ3JvdXAsIG1lbnUsIG5hdiwgc2VjdGlvbiB7XFxuICBkaXNwbGF5OiBibG9jazsgfVxcblxcbm5hdiB1bCB7XFxuICBsaXN0LXN0eWxlOiBub25lOyB9XFxuXFxuYmxvY2txdW90ZSwgcSB7XFxuICBxdW90ZXM6IG5vbmU7IH1cXG5cXG5ibG9ja3F1b3RlOmJlZm9yZSwgYmxvY2txdW90ZTphZnRlcixcXG5xOmJlZm9yZSwgcTphZnRlciB7XFxuICBjb250ZW50OiAnJztcXG4gIGNvbnRlbnQ6IG5vbmU7IH1cXG5cXG5hIHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBmb250LXNpemU6IDEwMCU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgfVxcblxcbi8qIGNoYW5nZSBjb2xvdXJzIHRvIHN1aXQgeW91ciBuZWVkcyAqL1xcbmlucyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmY5O1xcbiAgY29sb3I6ICMwMDA7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG5cXG4vKiBjaGFuZ2UgY29sb3VycyB0byBzdWl0IHlvdXIgbmVlZHMgKi9cXG5tYXJrIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZjk7XFxuICBjb2xvcjogIzAwMDtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG4gIGZvbnQtd2VpZ2h0OiBib2xkOyB9XFxuXFxuZGVsIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoOyB9XFxuXFxuYWJiclt0aXRsZV0sIGRmblt0aXRsZV0ge1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IGRvdHRlZDtcXG4gIGN1cnNvcjogaGVscDsgfVxcblxcbnRhYmxlIHtcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICBib3JkZXItc3BhY2luZzogMDsgfVxcblxcbi8qIGNoYW5nZSBib3JkZXIgY29sb3VyIHRvIHN1aXQgeW91ciBuZWVkcyAqL1xcbmhyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgaGVpZ2h0OiAxcHg7XFxuICBib3JkZXI6IDA7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI2NjY2NjYztcXG4gIG1hcmdpbjogMWVtIDA7XFxuICBwYWRkaW5nOiAwOyB9XFxuXFxuaW5wdXQsIHNlbGVjdCB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuXFxuYm9keSB7XFxuICBmb250LWZhbWlseTogXFxcIk11bGlcXFwiLCBzYW5zLXNlcmlmO1xcbiAgbGluZS1oZWlnaHQ6IDE0MCU7XFxuICBjb2xvcjogIzMzMzsgfVxcblxcbmgxIHtcXG4gIGZvbnQtc2l6ZTogMjRweDtcXG4gIGZvbnQtc2l6ZTogMS41cmVtOyB9XFxuXFxuaDIge1xcbiAgZm9udC1zaXplOiAyMnB4O1xcbiAgZm9udC1zaXplOiAxLjM3NXJlbTsgfVxcblxcbmgzIHtcXG4gIGZvbnQtc2l6ZTogMjBweDtcXG4gIGZvbnQtc2l6ZTogMS4yNXJlbTsgfVxcblxcbnAge1xcbiAgbWFyZ2luOiAuNzVlbSAwO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgZm9udC1zaXplOiAxcmVtOyB9XFxuXFxucDpmaXJzdC1jaGlsZCB7XFxuICBtYXJnaW4tdG9wOiAwOyB9XFxuXFxucDpsYXN0LWNoaWxkIHtcXG4gIG1hcmdpbi1ib3R0b206IDA7IH1cXG5cXG5jb2RlIHtcXG4gIGZvbnQ6IDE2cHgvMTIwJSBcXFwiRmlyYSBNb25vXFxcIiwgbW9ub3NwYWNlOyB9XFxuICBjb2RlIHNwYW4ge1xcbiAgICBmb250LXNpemU6IDEycHg7XFxuICAgIGZvbnQtc2l6ZTogMC43NXJlbTsgfVxcblxcbi52aWV3IGlmcmFtZSB7XFxuICB6LWluZGV4OiAxOyB9XFxuXFxuLm92ZXJsYXksXFxuLnZpZXcgLmRyYWctbWFzayB7XFxuICB6LWluZGV4OiAyOyB9XFxuXFxuLmRyb3BsZXQsXFxuLmRyYWctaGFuZGxlIHtcXG4gIHotaW5kZXg6IDM7IH1cXG5cXG4uZGlhbG9nIHtcXG4gIHotaW5kZXg6IDQ7IH1cXG4gIC5kaWFsb2cgLmRpYWxvZy1jb250YWluZXJbeC1wbGFjZW1lbnRdIC5hcnJvdzpiZWZvcmUge1xcbiAgICB6LWluZGV4OiA2OyB9XFxuICAuZGlhbG9nIC5kaWFsb2ctY29udGFpbmVyW3gtcGxhY2VtZW50XSAuYXJyb3c6YWZ0ZXIge1xcbiAgICB6LWluZGV4OiA1OyB9XFxuXFxuLnRvb2x0aXAge1xcbiAgei1pbmRleDogMTA7IH1cXG4gIC50b29sdGlwIC5hcnJvdzpiZWZvcmUge1xcbiAgICB6LWluZGV4OiAxMjsgfVxcbiAgLnRvb2x0aXAgLmFycm93OmFmdGVyIHtcXG4gICAgei1pbmRleDogMTE7IH1cXG5cXG4uYnV0dG9uOmFmdGVyIHtcXG4gIHotaW5kZXg6IDE7IH1cXG5cXG4uYnV0dG9uIHNwYW4ge1xcbiAgei1pbmRleDogMjsgfVxcblxcbi5sb2dvIHtcXG4gIGxldHRlci1zcGFjaW5nOiAxcHg7IH1cXG4gIC5sb2dvIGIge1xcbiAgICBjb2xvcjogIzE5MmZjZTsgfVxcblxcbioge1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG46bm90KHN2Zykge1xcbiAgY3Vyc29yOiBkZWZhdWx0OyB9XFxuXFxuOmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmU7IH1cXG5cXG46Oi1tb3otZm9jdXMtaW5uZXIge1xcbiAgYm9yZGVyOiAwOyB9XFxuXFxuLmhpZGRlbiB7XFxuICBkaXNwbGF5OiBub25lOyB9XFxuXFxuLyogbWFpbiBsYXlvdXQgKi9cXG5ib2R5IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7IH1cXG5cXG4uYXBwLFxcbi50YWctY2FudmFzIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbiAgbGVmdDogMDtcXG4gIHRvcDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIHJpZ2h0OiAwOyB9XFxuXFxuLnRhZy1jYW52YXMge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IH1cXG4gIC50YWctY2FudmFzIGhlYWRlciB7XFxuICAgIGZsZXgtc2hyaW5rOiAwOyB9XFxuICAudGFnLWNhbnZhcyAubWFpbiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZ3JvdzogMTsgfVxcbiAgICAudGFnLWNhbnZhcyAubWFpbiA+ICo6bm90KC5kcmFnLWhhbmRsZSkge1xcbiAgICAgIGZsZXgtYmFzaXM6IDUwJTsgfVxcbiAgICAudGFnLWNhbnZhcyAubWFpbiAuZHJhZy1oYW5kbGUge1xcbiAgICAgIGZsZXgtYmFzaXM6IDIwcHg7IH1cXG4gIC50YWctY2FudmFzIC5wYWxsZXQge1xcbiAgICBmbGV4LXNocmluazogMDsgfVxcblxcbmhlYWRlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjO1xcbiAgcGFkZGluZzogNXB4IDEwcHg7XFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjZjNmM2YzIDAlLCAjZjFmMWYxIDEwMCUpOyB9XFxuICBoZWFkZXIgLmxvZ28ge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDFlbTsgfVxcbiAgaGVhZGVyIHAge1xcbiAgICBtYXJnaW46IDA7IH1cXG4gIGhlYWRlciAudG9vbGJhciB7XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvOyB9XFxuXFxuLnRvb2xiYXIgdWwge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBwYWRkaW5nOiAwOyB9XFxuICAudG9vbGJhciB1bCBsaSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA1cHg7XFxuICAgIHBhZGRpbmctbGVmdDogNXB4OyB9XFxuICAgIC50b29sYmFyIHVsIGxpLnNlcGFyYXRvciB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDcuNXB4O1xcbiAgICAgIHBhZGRpbmctbGVmdDogOS41cHg7XFxuICAgICAgYm9yZGVyLWxlZnQ6IDJweCBzb2xpZCAjY2NjOyB9XFxuICAgIC50b29sYmFyIHVsIGxpLnJ1biAuYnV0dG9uIHtcXG4gICAgICBib3JkZXItY29sb3I6ICMzMTlmMmU7XFxuICAgICAgY29sb3I6ICMzMTlmMmU7IH1cXG4gICAgICAudG9vbGJhciB1bCBsaS5ydW4gLmJ1dHRvbiAuY2lyY2xlIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzMTlmMmU7IH1cXG4gICAgICAudG9vbGJhciB1bCBsaS5ydW4gLmJ1dHRvbjpob3ZlciA+IHNwYW4ge1xcbiAgICAgICAgY29sb3I6ICNmZmY7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNTFjYzRkOyB9XFxuXFxuLnRvb2xiYXIgLmJ1dHRvbiB7XFxuICBmb250LXdlaWdodDogYm9sZGVyO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgZm9udC1zaXplOiAwLjg3NXJlbTsgfVxcbiAgLnRvb2xiYXIgLmJ1dHRvbiBzcGFuIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjsgfVxcblxcbi50ZW1wbGF0ZSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjY2NjO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZjZmRjYzsgfVxcbiAgLnRlbXBsYXRlIC50ZW1wbGF0ZS1pbm5lciB7XFxuICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICBmbGV4LWdyb3c6IDE7IH1cXG4gIC50ZW1wbGF0ZSBwcmUge1xcbiAgICBtYXJnaW46IDEwcHg7XFxuICAgIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgICAtbW96LXRhYi1zaXplOiAzO1xcbiAgICB0YWItc2l6ZTogMzsgfVxcbiAgICAudGVtcGxhdGUgcHJlICoge1xcbiAgICAgIHVzZXItc2VsZWN0OiB0ZXh0O1xcbiAgICAgIGN1cnNvcjogdGV4dDsgfVxcbiAgLnRlbXBsYXRlIC5obGpzIHtcXG4gICAgZm9udC1zaXplOiAxLjEyNWVtO1xcbiAgICBsaW5lLWhlaWdodDogMTMwJTsgfVxcbiAgICAudGVtcGxhdGUgLmhsanMgLmRyb3Atem9uZSAuaGxqcy1zdHJpbmcge1xcbiAgICAgIGNvbG9yOiB3aGl0ZTsgfVxcbiAgLnRlbXBsYXRlIC5pbnN0cnVjdGlvbiB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBmbGV4LXNocmluazogMDtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiA1cHg7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNjE3MmVjOyB9XFxuXFxuLnZpZXcge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjY2NjOyB9XFxuICAudmlldyBpZnJhbWUsXFxuICAudmlldyAuZHJhZy1tYXNrIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB0b3A6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7IH1cXG4gIC52aWV3IC5kcmFnLW1hc2sge1xcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7IH1cXG5cXG4uZHJhZ2dpbmcgLnZpZXcgLmRyYWctbWFzayB7XFxuICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbiAgb3BhY2l0eTogLjc7IH1cXG5cXG4ucGFsbGV0IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI2NjYztcXG4gIHBhZGRpbmc6IDVweCAxMHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTsgfVxcbiAgLnBhbGxldCAuZHJvcGxldCB7XFxuICAgIG1hcmdpbjogNXB4IDEwcHggNXB4IDA7IH1cXG5cXG5idXR0b246Oi1tb3otZm9jdXMtaW5uZXIge1xcbiAgcGFkZGluZzogMDtcXG4gIGJvcmRlcjogMDsgfVxcblxcbi5idXR0b24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBib3JkZXI6IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgZm9udC1zaXplOiAwLjg3NXJlbTtcXG4gIGNvbG9yOiAjMzMzO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBjdXJzb3I6IHBvaW50ZXI7IH1cXG4gIC5idXR0b24gPiBzcGFuIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjO1xcbiAgICBwYWRkaW5nOiA1cHggMTBweDsgfVxcbiAgLmJ1dHRvbjpob3ZlciA+IHNwYW4sXFxuICAuYnV0dG9uOmZvY3VzID4gc3BhbiB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC0ycHgsIC0ycHgpO1xcbiAgICBib3gtc2hhZG93OiAycHggMnB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlOyB9XFxuICAuYnV0dG9uIHNwYW4uY2lyY2xlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICBvcGFjaXR5OiAuNztcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgcGFkZGluZy10b3A6IDEwMCU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2EwYTBhMDtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7IH1cXG4gICAgLmJ1dHRvbiBzcGFuLmNpcmNsZS5hbmltYXRlIHtcXG4gICAgICBhbmltYXRpb246IGJ1dHRvbi1jaXJjbGUtb3V0IDAuNnMgY3ViaWMtYmV6aWVyKDAuNzcsIDAsIDAuMTc1LCAxKTsgfVxcbiAgLmJ1dHRvbiAuaWNvbiB7XFxuICAgIG1hcmdpbjogMCA1cHggMXB4IDA7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG5cXG4ucHNldWRvLWJ1dHRvbiB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjY2NjO1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgcGFkZGluZzogMXB4IDVweDtcXG4gIGNvbG9yOiAjNGQ0ZDRkOyB9XFxuICAucHNldWRvLWJ1dHRvbiA+ICoge1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuICAucHNldWRvLWJ1dHRvbiBzdmcge1xcbiAgICBtYXJnaW4tYm90dG9tOiAuMTVlbTsgfVxcbiAgLnBzZXVkby1idXR0b24ucnVuIHtcXG4gICAgY29sb3I6ICM1MWNjNGQ7XFxuICAgIGZpbGw6ICM1MWNjNGQ7IH1cXG5cXG5Aa2V5ZnJhbWVzIGJ1dHRvbi1jaXJjbGUtb3V0IHtcXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDYpO1xcbiAgICBvcGFjaXR5OiAwOyB9IH1cXG5cXG4uZHJvcC16b25lIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGZvbnQtZmFtaWx5OiBcXFwiRmlyYSBNb25vXFxcIiwgbW9ub3NwYWNlOyB9XFxuICAuZHJvcC16b25lIC50YXJnZXQtb3V0ZXIge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgLmRyb3Atem9uZSAudGFyZ2V0IGIge1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIHBhZGRpbmc6IDJweCA1cHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM2MTcyZWM7XFxuICAgIGxpbmUtaGVpZ2h0OiAxMjAlO1xcbiAgICBjb2xvcjogd2hpdGU7IH1cXG4gIC5kcm9wLXpvbmUgLnRhcmdldC5oaWRkZW4ge1xcbiAgICBkaXNwbGF5OiBub25lOyB9XFxuICAuZHJvcC16b25lIC5hdHRhY2htZW50cyA+ICoge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIG1hcmdpbjogMXB4O1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIHBhZGRpbmc6IDFweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzUxY2M0ZDsgfVxcbiAgLmRyb3Atem9uZSAuYXR0YWNobWVudHMgLmVsZW1lbnQge1xcbiAgICBkaXNwbGF5OiBibG9jazsgfVxcblxcbi5kcm9wLXpvbmUuYWNjZXB0IC50YXJnZXQgYixcXG4uZHJvcGxldC1hY3RpdmUgLmRyb3Atem9uZS53aWxsLWFjY2VwdCAudGFyZ2V0OmhvdmVyIGIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzUxY2M0ZDsgfVxcblxcbi5kcm9wLXpvbmUuZGVjbGluZSAudGFyZ2V0IGIsXFxuLmRyb3BsZXQtYWN0aXZlIC5kcm9wLXpvbmUud2lsbC1kZWNsaW5lIC50YXJnZXQ6aG92ZXIgYiB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmY1MTVjOyB9XFxuXFxuLmRyb3Atem9uZTpub3QoLnBvc3NpYmxlLXRhcmdldCkgLmRyb3B6b25lLWF0dGFjaG1lbnQ6aG92ZXIge1xcbiAgY29sb3I6ICNmZmY7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzE5ZjJlO1xcbiAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXFxuLmRyb3BsZXQtYWN0aXZlIC5kcm9wLXpvbmUgLnRhcmdldCBiIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMxOTJmY2U7IH1cXG5cXG4uZHJvcGxldC1hY3RpdmUgLmRyb3Atem9uZSAudGFyZ2V0OmhvdmVyIGIge1xcbiAgYm94LXNoYWRvdzogMnB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMik7IH1cXG5cXG4uZHJvcGxldCB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICBib3JkZXI6IDA7XFxuICBoZWlnaHQ6IDM1cHg7XFxuICBwYWRkaW5nOiAwO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY3Vyc29yOiBwb2ludGVyOyB9XFxuICAuZHJvcGxldCAubGFiZWwge1xcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMTVzIGN1YmljLWJlemllcigwLjc3LCAwLCAwLjE3NSwgMSksIGNvbG9yIDAuMTVzIGN1YmljLWJlemllcigwLjc3LCAwLCAwLjE3NSwgMSksIGJvcmRlci1jb2xvciAwLjE1cyBjdWJpYy1iZXppZXIoMC43NywgMCwgMC4xNzUsIDEpLCBvcGFjaXR5IDAuNXMgY3ViaWMtYmV6aWVyKDAuNzcsIDAsIDAuMTc1LCAxKTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjYTBhMGEwO1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogNXB4O1xcbiAgICBoZWlnaHQ6IDM1cHg7XFxuICAgIHBhZGRpbmc6IDVweCAxMHB4O1xcbiAgICBsaW5lLWhlaWdodDogMTIwJTtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICBmb250LXNpemU6IDAuODc1cmVtO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICBjb2xvcjogIzMzMztcXG4gICAgY3Vyc29yOiBwb2ludGVyOyB9XFxuICAgIC5kcm9wbGV0IC5sYWJlbCAuaWNvbiB7XFxuICAgICAgdHJhbnNpdGlvbjogZmlsbCAwLjE1cyBjdWJpYy1iZXppZXIoMC43NywgMCwgMC4xNzUsIDEpO1xcbiAgICAgIG1hcmdpbi1yaWdodDogLjVlbTsgfVxcbiAgLmRyb3BsZXQuYWN0aXZlIC5sYWJlbCB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYTBhMGEwOyB9XFxuICAgIC5kcm9wbGV0LmFjdGl2ZSAubGFiZWwgLmljb24ge1xcbiAgICAgIGZpbGw6ICNmZmY7IH1cXG4gIC5kcm9wbGV0Lml0ZW0tZHJhZ2dpbmcgLmxhYmVsIHtcXG4gICAgb3BhY2l0eTogMC41O1xcbiAgICBib3gtc2hhZG93OiAycHggMnB4IHJnYmEoMCwgMCwgMCwgMC4yKTsgfVxcbiAgLmRyb3BsZXQudHlwZS10ZXh0IC5sYWJlbCB7XFxuICAgIGJvcmRlci1jb2xvcjogIzJmOWVkODsgfVxcbiAgLmRyb3BsZXQudHlwZS10ZXh0OmhvdmVyIC5sYWJlbCB7XFxuICAgIGNvbG9yOiAjMmY5ZWQ4OyB9XFxuICAuZHJvcGxldC50eXBlLXRleHQuYWN0aXZlIC5sYWJlbCB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBib3JkZXItY29sb3I6ICMxZDcxOWQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxZDcxOWQ7IH1cXG4gIC5kcm9wbGV0LnR5cGUtYXR0cmlidXRlIC5sYWJlbCB7XFxuICAgIGJvcmRlci1jb2xvcjogIzUxY2M0ZDsgfVxcbiAgLmRyb3BsZXQudHlwZS1hdHRyaWJ1dGU6aG92ZXIgLmxhYmVsIHtcXG4gICAgY29sb3I6ICM1MWNjNGQ7IH1cXG4gIC5kcm9wbGV0LnR5cGUtYXR0cmlidXRlLmFjdGl2ZSAubGFiZWwge1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gICAgYm9yZGVyLWNvbG9yOiAjMzE5ZjJlO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzE5ZjJlOyB9XFxuICAuZHJvcGxldC50eXBlLWVsZW1lbnQgLmxhYmVsIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjYzA0NGYxOyB9XFxuICAuZHJvcGxldC50eXBlLWVsZW1lbnQ6aG92ZXIgLmxhYmVsIHtcXG4gICAgY29sb3I6ICNjMDQ0ZjE7IH1cXG4gIC5kcm9wbGV0LnR5cGUtZWxlbWVudC5hY3RpdmUgLmxhYmVsIHtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIGJvcmRlci1jb2xvcjogI2EwMTBkODtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2EwMTBkODsgfVxcblxcbi5kaWFsb2cge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIHRvcDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIGJhY2tncm91bmQ6ICNjY2M7XFxuICAvKiBUaGUgRmFsbGJhY2sgKi9cXG4gIGJhY2tncm91bmQ6IHJnYmEoMjA0LCAyMDQsIDIwNCwgMC43KTsgfVxcbiAgLmRpYWxvZy52aXNpYmxlIHtcXG4gICAgZGlzcGxheTogZmxleDsgfVxcbiAgLmRpYWxvZy5uby1vdmVybGF5LnZpc2libGUge1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgYmFja2dyb3VuZDogbm9uZTsgfVxcbiAgLmRpYWxvZyAuZGlhbG9nLWNvbnRhaW5lciB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcbiAgICBib3gtc2hhZG93OiA0cHggNHB4IHJnYmEoMCwgMCwgMCwgMC4xKTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2EwYTBhMDtcXG4gICAgbWF4LXdpZHRoOiA1MDBweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZiZmJmYjsgfVxcbiAgLmRpYWxvZyAuZGlhbG9nLWhlYWRpbmcge1xcbiAgICBwYWRkaW5nOiAyMHB4O1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYzsgfVxcbiAgICAuZGlhbG9nIC5kaWFsb2ctaGVhZGluZyAuaWNvbiB7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAuNWVtOyB9XFxuICAgIC5kaWFsb2cgLmRpYWxvZy1oZWFkaW5nIHA6bnRoLW9mLXR5cGUobisyKSB7XFxuICAgICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMC44NzVyZW07IH1cXG4gIC5kaWFsb2cgLmJ1dHRvbiB7XFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgZm9udC1zaXplOiAxcmVtOyB9XFxuICAgIC5kaWFsb2cgLmJ1dHRvbiA+IHNwYW4ge1xcbiAgICAgIHBhZGRpbmc6IDcuNXB4IDE1cHg7IH1cXG5cXG4ucG9wdXBbeC1wbGFjZW1lbnRePVxcXCJ0b3BcXFwiXSB7XFxuICBtYXJnaW4tYm90dG9tOiAyMHB4OyB9XFxuXFxuLnBvcHVwW3gtcGxhY2VtZW50Xj1cXFwiYm90dG9tXFxcIl0ge1xcbiAgbWFyZ2luLXRvcDogMjBweDsgfVxcblxcbi5wb3B1cFt4LXBsYWNlbWVudF49XFxcInJpZ2h0XFxcIl0ge1xcbiAgbWFyZ2luLWxlZnQ6IDIwcHg7IH1cXG5cXG4ucG9wdXBbeC1wbGFjZW1lbnRePVxcXCJsZWZ0XFxcIl0ge1xcbiAgbWFyZ2luLXJpZ2h0OiAyMHB4OyB9XFxuXFxuLnBvcHVwW3gtcGxhY2VtZW50XSAuYXJyb3cge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHdpZHRoOiA0MHB4O1xcbiAgaGVpZ2h0OiA0MHB4OyB9XFxuICAucG9wdXBbeC1wbGFjZW1lbnRdIC5hcnJvdzpiZWZvcmUsIC5wb3B1cFt4LXBsYWNlbWVudF0gLmFycm93OmFmdGVyIHtcXG4gICAgY29udGVudDogJyc7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAwO1xcbiAgICB3aWR0aDogMDtcXG4gICAgYm9yZGVyOiAyMHB4IHNvbGlkICNmYmZiZmI7IH1cXG4gIC5wb3B1cFt4LXBsYWNlbWVudF0gLmFycm93OmFmdGVyIHtcXG4gICAgYm9yZGVyOiAyMnB4IHNvbGlkICNhMGEwYTA7IH1cXG5cXG4ucG9wdXBbeC1wbGFjZW1lbnRePVxcXCJ0b3BcXFwiXSAuYXJyb3csXFxuLnBvcHVwW3gtcGxhY2VtZW50Xj1cXFwiYm90dG9tXFxcIl0gLmFycm93IHtcXG4gIGhlaWdodDogMjBweDsgfVxcblxcbi5wb3B1cFt4LXBsYWNlbWVudF49XFxcImxlZnRcXFwiXSAuYXJyb3csXFxuLnBvcHVwW3gtcGxhY2VtZW50Xj1cXFwicmlnaHRcXFwiXSAuYXJyb3cge1xcbiAgd2lkdGg6IDIwcHg7IH1cXG5cXG4ucG9wdXBbeC1wbGFjZW1lbnRePVxcXCJ0b3BcXFwiXSAuYXJyb3cge1xcbiAgYm90dG9tOiAtMjBweDtcXG4gIG1hcmdpbi1sZWZ0OiAtMTBweDsgfVxcbiAgLnBvcHVwW3gtcGxhY2VtZW50Xj1cXFwidG9wXFxcIl0gLmFycm93OmJlZm9yZSB7XFxuICAgIGJvcmRlci1jb2xvcjogI2ZiZmJmYiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDsgfVxcbiAgLnBvcHVwW3gtcGxhY2VtZW50Xj1cXFwidG9wXFxcIl0gLmFycm93OmFmdGVyIHtcXG4gICAgbGVmdDogLTJweDtcXG4gICAgdG9wOiAtMXB4O1xcbiAgICBib3JkZXItY29sb3I6ICNhMGEwYTAgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7IH1cXG5cXG4ucG9wdXBbeC1wbGFjZW1lbnRePVxcXCJib3R0b21cXFwiXSAuYXJyb3cge1xcbiAgdG9wOiAtMjBweDtcXG4gIG1hcmdpbi1sZWZ0OiAtMTBweDsgfVxcbiAgLnBvcHVwW3gtcGxhY2VtZW50Xj1cXFwiYm90dG9tXFxcIl0gLmFycm93OmJlZm9yZSB7XFxuICAgIHRvcDogLTIwcHg7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgI2ZiZmJmYiB0cmFuc3BhcmVudDsgfVxcbiAgLnBvcHVwW3gtcGxhY2VtZW50Xj1cXFwiYm90dG9tXFxcIl0gLmFycm93OmFmdGVyIHtcXG4gICAgbGVmdDogLTJweDtcXG4gICAgdG9wOiAtMjFweDtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjYTBhMGEwIHRyYW5zcGFyZW50OyB9XFxuXFxuLnBvcHVwW3gtcGxhY2VtZW50Xj1cXFwibGVmdFxcXCJdIC5hcnJvdyB7XFxuICByaWdodDogLTIwcHg7IH1cXG4gIC5wb3B1cFt4LXBsYWNlbWVudF49XFxcImxlZnRcXFwiXSAuYXJyb3c6YmVmb3JlIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjZmJmYmZiOyB9XFxuICAucG9wdXBbeC1wbGFjZW1lbnRePVxcXCJsZWZ0XFxcIl0gLmFycm93OmFmdGVyIHtcXG4gICAgbGVmdDogLTFweDtcXG4gICAgdG9wOiAtMnB4O1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICNhMGEwYTA7IH1cXG5cXG4ucG9wdXBbeC1wbGFjZW1lbnRePVxcXCJyaWdodFxcXCJdIC5hcnJvdyB7XFxuICBsZWZ0OiAtMjBweDsgfVxcbiAgLnBvcHVwW3gtcGxhY2VtZW50Xj1cXFwicmlnaHRcXFwiXSAuYXJyb3c6YmVmb3JlIHtcXG4gICAgbGVmdDogYXV0bztcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgI2ZiZmJmYiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDsgfVxcbiAgLnBvcHVwW3gtcGxhY2VtZW50Xj1cXFwicmlnaHRcXFwiXSAuYXJyb3c6YWZ0ZXIge1xcbiAgICBsZWZ0OiBhdXRvO1xcbiAgICByaWdodDogLTFweDtcXG4gICAgdG9wOiAtMnB4O1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50ICNhMGEwYTAgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7IH1cXG5cXG4ucG9wdXAgY29kZSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGJveC1zaGFkb3c6IDJweCAycHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgbWFyZ2luOiAxZW0gMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZzogNXB4O1xcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZm9udC1zaXplOiAwLjc1cmVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZjZmRjYzsgfVxcblxcbmZvcm0gZmllbGRzZXQ6bm90KC5idXR0b25zKSB7XFxuICBwYWRkaW5nOiAwIDIwcHg7XFxuICBtYXJnaW46IDEwcHggMDsgfVxcblxcbmZvcm0gZmllbGRzZXQuYnV0dG9ucyB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjY2NjO1xcbiAgcGFkZGluZzogMjBweDsgfVxcbiAgZm9ybSBmaWVsZHNldC5idXR0b25zIGJ1dHRvbiB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgbWFyZ2luOiAwIC4yNWVtOyB9XFxuICAgIGZvcm0gZmllbGRzZXQuYnV0dG9ucyBidXR0b24ucHVsbC1sZWZ0IHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcblxcbmZvcm0gbGVnZW5kIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7IH1cXG5cXG5mb3JtIC5maWVsZCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIG1hcmdpbjogMTBweCAwOyB9XFxuICBmb3JtIC5maWVsZCBsYWJlbCB7XFxuICAgIHdpZHRoOiA0MCU7IH1cXG5cXG5pbnB1dCxcXG5zZWxlY3QsXFxuYnV0dG9uIHtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiTXVsaVxcXCIsIHNhbnMtc2VyaWY7IH1cXG5cXG5pbnB1dCxcXG5zZWxlY3Qge1xcbiAgdXNlci1zZWxlY3Q6IGFsbDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGZvbnQtc2l6ZTogMC44NzVyZW07XFxuICBwYWRkaW5nOiA1cHg7IH1cXG5cXG5idXR0b24ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICBidXR0b24ucHJpbWFyeSwgYnV0dG9uLmRhbmdlciB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7IH1cXG4gIGJ1dHRvbi5wcmltYXJ5ID4gc3BhbiB7XFxuICAgIGJvcmRlci1jb2xvcjogIzYxNzJlYztcXG4gICAgY29sb3I6ICM2MTcyZWM7IH1cXG4gIGJ1dHRvbi5wcmltYXJ5IC5jaXJjbGUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMWQzNWU0OyB9XFxuICBidXR0b24ucHJpbWFyeTpob3ZlciA+IHNwYW4sXFxuICBidXR0b24ucHJpbWFyeTpmb2N1cyA+IHNwYW4ge1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzc4ODZlZjsgfVxcbiAgYnV0dG9uLmRhbmdlciA+IHNwYW4ge1xcbiAgICBib3JkZXItY29sb3I6ICNmZjUxNWM7XFxuICAgIGNvbG9yOiAjZmY1MTVjOyB9XFxuICBidXR0b24uZGFuZ2VyIC5jaXJjbGUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmYwNTE0OyB9XFxuICBidXR0b24uZGFuZ2VyOmhvdmVyID4gc3BhbixcXG4gIGJ1dHRvbi5kYW5nZXI6Zm9jdXMgPiBzcGFuIHtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZjZiNzQ7IH1cXG5cXG4uaWNvbiB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTsgfVxcbiAgLmljb24gdXNlIHtcXG4gICAgZmlsbDogY3VycmVudENvbG9yOyB9XFxuXFxuLmRyYWctaGFuZGxlIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICBjdXJzb3I6IGNvbC1yZXNpemU7IH1cXG4gIC5kcmFnLWhhbmRsZTphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4xNXMgY3ViaWMtYmV6aWVyKDAuNzcsIDAsIDAuMTc1LCAxKTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIHRvcDogNTAlO1xcbiAgICBtYXJnaW4tdG9wOiAtMjVweDtcXG4gICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICAgIHdpZHRoOiA4cHg7XFxuICAgIGhlaWdodDogNTBweDtcXG4gICAgYm9yZGVyLWxlZnQ6IDJweCBzb2xpZCAjY2NjO1xcbiAgICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCAjY2NjOyB9XFxuICAuZHJhZy1oYW5kbGU6aG92ZXIsIC5kcmFnLWhhbmRsZS5pdGVtLWRyYWdnaW5nIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDsgfVxcbiAgLmRyYWctaGFuZGxlOmhvdmVyOmFmdGVyLCAuZHJhZy1oYW5kbGUuaXRlbS1kcmFnZ2luZzphZnRlciB7XFxuICAgIGhlaWdodDogMTAwcHg7XFxuICAgIG1hcmdpbi10b3A6IC01MHB4OyB9XFxuXFxuLnRvb2x0aXAge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbWF4LXdpZHRoOiA0MDBweDsgfVxcbiAgLnRvb2x0aXAgLmNvbnRlbnQge1xcbiAgICBib3gtc2hhZG93OiA0cHggNHB4IHJnYmEoMCwgMCwgMCwgMC4xKTtcXG4gICAgcGFkZGluZzogMTBweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZiZmJmYjsgfVxcbiAgICAudG9vbHRpcCAuY29udGVudCBoMiB7XFxuICAgICAgZm9udC1zaXplOiAxOHB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMS4xMjVyZW07IH1cXG4gICAgICAudG9vbHRpcCAuY29udGVudCBoMiAuaWNvbiB7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IC41ZW07XFxuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAgICAgZmlsbDogIzE5MmZjZTsgfVxcbiAgLnRvb2x0aXAgLmFycm93OmFmdGVyIHtcXG4gICAgZGlzcGxheTogbm9uZTsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vfi9uanAtdGFnL3NyYy9zdHlsZXMvbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXApIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIHZhciBiYXNlNjQgPSBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuICByZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaWVlZTc1NC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24oaG9zdCkge1xuXG4gIHZhciBwcm9wZXJ0aWVzID0ge1xuICAgIGJyb3dzZXI6IFtcbiAgICAgIFsvbXNpZSAoW1xcLlxcX1xcZF0rKS8sIFwiaWVcIl0sXG4gICAgICBbL3RyaWRlbnRcXC8uKj9ydjooW1xcLlxcX1xcZF0rKS8sIFwiaWVcIl0sXG4gICAgICBbL2ZpcmVmb3hcXC8oW1xcLlxcX1xcZF0rKS8sIFwiZmlyZWZveFwiXSxcbiAgICAgIFsvY2hyb21lXFwvKFtcXC5cXF9cXGRdKykvLCBcImNocm9tZVwiXSxcbiAgICAgIFsvdmVyc2lvblxcLyhbXFwuXFxfXFxkXSspLio/c2FmYXJpLywgXCJzYWZhcmlcIl0sXG4gICAgICBbL21vYmlsZSBzYWZhcmkgKFtcXC5cXF9cXGRdKykvLCBcInNhZmFyaVwiXSxcbiAgICAgIFsvYW5kcm9pZC4qP3ZlcnNpb25cXC8oW1xcLlxcX1xcZF0rKS4qP3NhZmFyaS8sIFwiY29tLmFuZHJvaWQuYnJvd3NlclwiXSxcbiAgICAgIFsvY3Jpb3NcXC8oW1xcLlxcX1xcZF0rKS4qP3NhZmFyaS8sIFwiY2hyb21lXCJdLFxuICAgICAgWy9vcGVyYS8sIFwib3BlcmFcIl0sXG4gICAgICBbL29wZXJhXFwvKFtcXC5cXF9cXGRdKykvLCBcIm9wZXJhXCJdLFxuICAgICAgWy9vcGVyYSAoW1xcLlxcX1xcZF0rKS8sIFwib3BlcmFcIl0sXG4gICAgICBbL29wZXJhIG1pbmkuKj92ZXJzaW9uXFwvKFtcXC5cXF9cXGRdKykvLCBcIm9wZXJhLm1pbmlcIl0sXG4gICAgICBbL29waW9zXFwvKFthLXpcXC5cXF9cXGRdKykvLCBcIm9wZXJhXCJdLFxuICAgICAgWy9ibGFja2JlcnJ5LywgXCJibGFja2JlcnJ5XCJdLFxuICAgICAgWy9ibGFja2JlcnJ5Lio/dmVyc2lvblxcLyhbXFwuXFxfXFxkXSspLywgXCJibGFja2JlcnJ5XCJdLFxuICAgICAgWy9iYlxcZCsuKj92ZXJzaW9uXFwvKFtcXC5cXF9cXGRdKykvLCBcImJsYWNrYmVycnlcIl0sXG4gICAgICBbL3JpbS4qP3ZlcnNpb25cXC8oW1xcLlxcX1xcZF0rKS8sIFwiYmxhY2tiZXJyeVwiXSxcbiAgICAgIFsvaWNld2Vhc2VsXFwvKFtcXC5cXF9cXGRdKykvLCBcImljZXdlYXNlbFwiXSxcbiAgICAgIFsvZWRnZVxcLyhbXFwuXFxkXSspLywgXCJlZGdlXCJdXG4gICAgXSxcbiAgICBvczogW1xuICAgICAgWy9saW51eCAoKShbYS16XFwuXFxfXFxkXSspLywgXCJsaW51eFwiXSxcbiAgICAgIFsvbWFjIG9zIHgvLCBcIm1hY29zXCJdLFxuICAgICAgWy9tYWMgb3MgeC4qPyhbXFwuXFxfXFxkXSspLywgXCJtYWNvc1wiXSxcbiAgICAgIFsvb3MgKFtcXC5cXF9cXGRdKykgbGlrZSBtYWMgb3MvLCBcImlvc1wiXSxcbiAgICAgIFsvb3BlbmJzZCAoKShbYS16XFwuXFxfXFxkXSspLywgXCJvcGVuYnNkXCJdLFxuICAgICAgWy9hbmRyb2lkLywgXCJhbmRyb2lkXCJdLFxuICAgICAgWy9hbmRyb2lkIChbYS16XFwuXFxfXFxkXSspOy8sIFwiYW5kcm9pZFwiXSxcbiAgICAgIFsvbW96aWxsYVxcL1thLXpcXC5cXF9cXGRdKyBcXCgoPzptb2JpbGUpfCg/OnRhYmxldCkvLCBcImZpcmVmb3hvc1wiXSxcbiAgICAgIFsvd2luZG93c1xccyooPzpudCk/XFxzKihbXFwuXFxfXFxkXSspLywgXCJ3aW5kb3dzXCJdLFxuICAgICAgWy93aW5kb3dzIHBob25lLio/KFtcXC5cXF9cXGRdKykvLCBcIndpbmRvd3MucGhvbmVcIl0sXG4gICAgICBbL3dpbmRvd3MgbW9iaWxlLywgXCJ3aW5kb3dzLm1vYmlsZVwiXSxcbiAgICAgIFsvYmxhY2tiZXJyeS8sIFwiYmxhY2tiZXJyeW9zXCJdLFxuICAgICAgWy9iYlxcZCsvLCBcImJsYWNrYmVycnlvc1wiXSxcbiAgICAgIFsvcmltLio/b3NcXHMqKFtcXC5cXF9cXGRdKykvLCBcImJsYWNrYmVycnlvc1wiXVxuICAgIF0sXG4gICAgZGV2aWNlOiBbXG4gICAgICBbL2lwYWQvLCBcImlwYWRcIl0sXG4gICAgICBbL2lwaG9uZS8sIFwiaXBob25lXCJdLFxuICAgICAgWy9sdW1pYS8sIFwibHVtaWFcIl0sXG4gICAgICBbL2h0Yy8sIFwiaHRjXCJdLFxuICAgICAgWy9uZXh1cy8sIFwibmV4dXNcIl0sXG4gICAgICBbL2dhbGF4eSBuZXh1cy8sIFwiZ2FsYXh5Lm5leHVzXCJdLFxuICAgICAgWy9ub2tpYS8sIFwibm9raWFcIl0sXG4gICAgICBbLyBndFxcLS8sIFwiZ2FsYXh5XCJdLFxuICAgICAgWy8gc21cXC0vLCBcImdhbGF4eVwiXSxcbiAgICAgIFsveGJveC8sIFwieGJveFwiXSxcbiAgICAgIFsvKD86YmJcXGQrKXwoPzpibGFja2JlcnJ5KXwoPzogcmltICkvLCBcImJsYWNrYmVycnlcIl1cbiAgICBdXG4gIH07XG5cbiAgdmFyIFVOS05PV04gPSBcIlVua25vd25cIjtcblxuICB2YXIgcHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuXG4gIGZ1bmN0aW9uIFNuaWZmcigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBwcm9wZXJ0eU5hbWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHlOYW1lKSB7XG4gICAgICBzZWxmW3Byb3BlcnR5TmFtZV0gPSB7XG4gICAgICAgIG5hbWU6IFVOS05PV04sXG4gICAgICAgIHZlcnNpb246IFtdLFxuICAgICAgICB2ZXJzaW9uU3RyaW5nOiBVTktOT1dOXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGV0ZXJtaW5lUHJvcGVydHkoc2VsZiwgcHJvcGVydHlOYW1lLCB1c2VyQWdlbnQpIHtcbiAgICBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0uZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eU1hdGNoZXIpIHtcbiAgICAgIHZhciBwcm9wZXJ0eVJlZ2V4ID0gcHJvcGVydHlNYXRjaGVyWzBdO1xuICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBwcm9wZXJ0eU1hdGNoZXJbMV07XG5cbiAgICAgIHZhciBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaChwcm9wZXJ0eVJlZ2V4KTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHNlbGZbcHJvcGVydHlOYW1lXS5uYW1lID0gcHJvcGVydHlWYWx1ZTtcblxuICAgICAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICBzZWxmW3Byb3BlcnR5TmFtZV0udmVyc2lvblN0cmluZyA9IG1hdGNoWzJdO1xuICAgICAgICAgIHNlbGZbcHJvcGVydHlOYW1lXS52ZXJzaW9uID0gW107XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICBzZWxmW3Byb3BlcnR5TmFtZV0udmVyc2lvblN0cmluZyA9IG1hdGNoWzFdLnJlcGxhY2UoL18vZywgXCIuXCIpO1xuICAgICAgICAgIHNlbGZbcHJvcGVydHlOYW1lXS52ZXJzaW9uID0gcGFyc2VWZXJzaW9uKG1hdGNoWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmW3Byb3BlcnR5TmFtZV0udmVyc2lvblN0cmluZyA9IFVOS05PV047XG4gICAgICAgICAgc2VsZltwcm9wZXJ0eU5hbWVdLnZlcnNpb24gPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VWZXJzaW9uKHZlcnNpb25TdHJpbmcpIHtcbiAgICByZXR1cm4gdmVyc2lvblN0cmluZy5zcGxpdCgvW1xcLl9dLykubWFwKGZ1bmN0aW9uKHZlcnNpb25QYXJ0KSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQodmVyc2lvblBhcnQpO1xuICAgIH0pO1xuICB9XG5cbiAgU25pZmZyLnByb3RvdHlwZS5zbmlmZiA9IGZ1bmN0aW9uKHVzZXJBZ2VudFN0cmluZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdXNlckFnZW50ID0gKHVzZXJBZ2VudFN0cmluZyB8fCBuYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBwcm9wZXJ0eU5hbWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHlOYW1lKSB7XG4gICAgICBkZXRlcm1pbmVQcm9wZXJ0eShzZWxmLCBwcm9wZXJ0eU5hbWUsIHVzZXJBZ2VudCk7XG4gICAgfSk7XG4gIH07XG5cblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNuaWZmcjtcbiAgfSBlbHNlIHtcbiAgICBob3N0LlNuaWZmciA9IG5ldyBTbmlmZnIoKTtcbiAgICBob3N0LlNuaWZmci5zbmlmZihuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxufSkodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25pZmZyL3NyYy9zbmlmZnIuanNcbi8vIG1vZHVsZSBpZCA9IDI5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xudmFyIHN0eWxlc0luRG9tID0ge30sXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuXHRcdHZhciBtZW1vO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG1lbW87XG5cdFx0fTtcblx0fSxcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHNlbGYubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcblx0fSksXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXHR9KSxcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdLFxuXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vZml4VXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YXR0YWNoVGFnQXR0cnMoc3R5bGVFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhsaW5rRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XG5cdHJldHVybiBsaW5rRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gYXR0YWNoVGFnQXR0cnMoZWxlbWVudCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcblx0XHRpZihuZXdPYmopIHtcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0LyogSWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpe1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XG5cblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKVxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmwgKlxcKCAqKC4rPykgKlxcKS9nLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qc1xuLy8gbW9kdWxlIGlkID0gMjkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9tYWluLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L25qcC10YWcvc3JjL3N0eWxlcy9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBzcHJpdGUgPSByZXF1aXJlKFwiL1VzZXJzL25laWxhbmRlcnNvbi9TaXRlcy90YWctbGlnaHRzaG93L25vZGVfbW9kdWxlcy9zdmctc3ByaXRlLWxvYWRlci9saWIvd2ViL2dsb2JhbC1zcHJpdGVcIik7XG52YXIgaW1hZ2UgPSBcIjxzeW1ib2wgdmlld0JveD1cXFwiMCAwIDggOFxcXCIgaWQ9XFxcImljb24tY29tcGFzc1xcXCIgPiA8cGF0aCBkPVxcXCJNNCAwYy0yLjIgMC00IDEuOC00IDRzMS44IDQgNCA0IDQtMS44IDQtNC0xLjgtNC00LTR6bTAgMWMxLjY2IDAgMyAxLjM0IDMgM3MtMS4zNCAzLTMgMy0zLTEuMzQtMy0zIDEuMzQtMyAzLTN6bTIgMWwtMyAxLTEgMyAzLTEgMS0zem0tMiAxLjVjLjI4IDAgLjUuMjIuNS41cy0uMjIuNS0uNS41LS41LS4yMi0uNS0uNS4yMi0uNS41LS41elxcXCIvPiA8L3N5bWJvbD5cIjtcbm1vZHVsZS5leHBvcnRzID0gc3ByaXRlLmFkZChpbWFnZSwgXCJpY29uLWNvbXBhc3NcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvY29tcGFzcy5zdmdcbi8vIG1vZHVsZSBpZCA9IDMwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBzcHJpdGUgPSByZXF1aXJlKFwiL1VzZXJzL25laWxhbmRlcnNvbi9TaXRlcy90YWctbGlnaHRzaG93L25vZGVfbW9kdWxlcy9zdmctc3ByaXRlLWxvYWRlci9saWIvd2ViL2dsb2JhbC1zcHJpdGVcIik7XG52YXIgaW1hZ2UgPSBcIjxzeW1ib2wgdmlld0JveD1cXFwiMCAwIDggOFxcXCIgaWQ9XFxcImljb24tbGlnaHRidWxiXFxcIiA+IDxwYXRoIGQ9XFxcIk0zLjQxIDBhLjUuNSAwIDAgMC0uMTMuMDZsLTMgMS41YS41LjUgMCAxIDAgLjQ0Ljg4bDMtMS41YS41LjUgMCAwIDAtLjMxLS45NHptMSAxLjVhLjUuNSAwIDAgMC0uMTMuMDZsLTQgMmEuNS41IDAgMSAwIC40NC44OGw0LTJhLjUuNSAwIDAgMC0uMzEtLjk0em0wIDJhLjUuNSAwIDAgMC0uMTMuMDZsLTMgMS41YS41LjUgMCAwIDAgLjIyLjk0aDJhLjUuNSAwIDAgMCAuMTYtMWwxLjA2LS41NmEuNS41IDAgMCAwLS4zMS0uOTR6bS0yLjU2IDMuNWEuNS41IDAgMCAwIC4xNiAxaDFhLjUuNSAwIDEgMCAwLTFoLTFhLjUuNSAwIDAgMC0uMDkgMCAuNS41IDAgMCAwLS4wNiAwelxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMSlcXFwiLz4gPC9zeW1ib2w+XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHNwcml0ZS5hZGQoaW1hZ2UsIFwiaWNvbi1saWdodGJ1bGJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvbGlnaHRidWxiLnN2Z1xuLy8gbW9kdWxlIGlkID0gMzAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIHNwcml0ZSA9IHJlcXVpcmUoXCIvVXNlcnMvbmVpbGFuZGVyc29uL1NpdGVzL3RhZy1saWdodHNob3cvbm9kZV9tb2R1bGVzL3N2Zy1zcHJpdGUtbG9hZGVyL2xpYi93ZWIvZ2xvYmFsLXNwcml0ZVwiKTtcbnZhciBpbWFnZSA9IFwiPHN5bWJvbCB2aWV3Qm94PVxcXCIwIDAgOCA4XFxcIiBpZD1cXFwiaWNvbi1sb29wLWNpcmN1bGFyXFxcIiA+IDxwYXRoIGQ9XFxcIk00IDBjLTEuNjUgMC0zIDEuMzUtMyAzaC0xbDEuNSAyIDEuNS0yaC0xYzAtMS4xMS44OS0yIDItMnYtMXptMi41IDFsLTEuNSAyaDFjMCAxLjExLS44OSAyLTIgMnYxYzEuNjUgMCAzLTEuMzUgMy0zaDFsLTEuNS0yelxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMCAxKVxcXCIvPiA8L3N5bWJvbD5cIjtcbm1vZHVsZS5leHBvcnRzID0gc3ByaXRlLmFkZChpbWFnZSwgXCJpY29uLWxvb3AtY2lyY3VsYXJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvbG9vcC1jaXJjdWxhci5zdmdcbi8vIG1vZHVsZSBpZCA9IDMwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBzcHJpdGUgPSByZXF1aXJlKFwiL1VzZXJzL25laWxhbmRlcnNvbi9TaXRlcy90YWctbGlnaHRzaG93L25vZGVfbW9kdWxlcy9zdmctc3ByaXRlLWxvYWRlci9saWIvd2ViL2dsb2JhbC1zcHJpdGVcIik7XG52YXIgaW1hZ2UgPSBcIjxzeW1ib2wgdmlld0JveD1cXFwiMCAwIDggOFxcXCIgaWQ9XFxcImljb24tbWVkaWEtcGxheVxcXCIgPiA8cGF0aCBkPVxcXCJNMCAwdjZsNi0zLTYtM3pcXFwiIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDEgMSlcXFwiLz4gPC9zeW1ib2w+XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHNwcml0ZS5hZGQoaW1hZ2UsIFwiaWNvbi1tZWRpYS1wbGF5XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9uanAtdGFnL3NyYy9pbWcvc3ZnL21lZGlhLXBsYXkuc3ZnXG4vLyBtb2R1bGUgaWQgPSAzMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgc3ByaXRlID0gcmVxdWlyZShcIi9Vc2Vycy9uZWlsYW5kZXJzb24vU2l0ZXMvdGFnLWxpZ2h0c2hvdy9ub2RlX21vZHVsZXMvc3ZnLXNwcml0ZS1sb2FkZXIvbGliL3dlYi9nbG9iYWwtc3ByaXRlXCIpO1xudmFyIGltYWdlID0gXCI8c3ltYm9sIHZpZXdCb3g9XFxcIjAgMCA4IDhcXFwiIGlkPVxcXCJpY29uLXB1enpsZS1waWVjZVxcXCIgPiA8cGF0aCBkPVxcXCJNMyAwYy0uMjggMC0uNTQuMS0uNzIuMjgtLjE4LjE4LS4yOC40NC0uMjguNzIgMCAuMjguMTguNDguMjguNzIuMDMuMDYuMDMuMTYuMDMuMjhoLTIuMzF2NmgyLjMxYzAtLjEyLS4wMS0uMjItLjAzLS4yOC0uMS0uMjQtLjI4LS40NC0uMjgtLjcyIDAtLjI4LjEtLjU0LjI4LS43Mi4xOC0uMTguNDQtLjI4LjcyLS4yOC4yOCAwIC41NC4xLjcyLjI4LjE4LjE4LjI4LjQ0LjI4LjcyIDAgLjI4LS4xOC40OC0uMjguNzItLjAzLjA2LS4wMy4xNi0uMDMuMjhoMi4zMXYtMi4zMWMuMTIgMCAuMjIuMDEuMjguMDMuMjQuMS40NC4yOC43Mi4yOC4yOCAwIC41NC0uMS43Mi0uMjguMTgtLjE4LjI4LS40NC4yOC0uNzIgMC0uMjgtLjEtLjU0LS4yOC0uNzItLjE4LS4xOC0uNDQtLjI4LS43Mi0uMjgtLjI4IDAtLjQ4LjE4LS43Mi4yOC0uMDYuMDMtLjE2LjAzLS4yOC4wM3YtMi4zMWgtMi4zMWMwLS4xMi4wMS0uMjIuMDMtLjI4LjEtLjI0LjI4LS40NC4yOC0uNzIgMC0uMjgtLjEtLjU0LS4yOC0uNzItLjE4LS4xOC0uNDQtLjI4LS43Mi0uMjh6XFxcIi8+IDwvc3ltYm9sPlwiO1xubW9kdWxlLmV4cG9ydHMgPSBzcHJpdGUuYWRkKGltYWdlLCBcImljb24tcHV6emxlLXBpZWNlXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9uanAtdGFnL3NyYy9pbWcvc3ZnL3B1enpsZS1waWVjZS5zdmdcbi8vIG1vZHVsZSBpZCA9IDMwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBzcHJpdGUgPSByZXF1aXJlKFwiL1VzZXJzL25laWxhbmRlcnNvbi9TaXRlcy90YWctbGlnaHRzaG93L25vZGVfbW9kdWxlcy9zdmctc3ByaXRlLWxvYWRlci9saWIvd2ViL2dsb2JhbC1zcHJpdGVcIik7XG52YXIgaW1hZ2UgPSBcIjxzeW1ib2wgdmlld0JveD1cXFwiMCAwIDggOFxcXCIgaWQ9XFxcImljb24tcmVzaXplLXdpZHRoXFxcIiA+IDxwYXRoIGQ9XFxcIk0zIDBsLTMgMi41IDMgMi41di0yaDJ2MmwzLTIuNS0zLTIuNXYyaC0ydi0yelxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMCAxKVxcXCIvPiA8L3N5bWJvbD5cIjtcbm1vZHVsZS5leHBvcnRzID0gc3ByaXRlLmFkZChpbWFnZSwgXCJpY29uLXJlc2l6ZS13aWR0aFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbmpwLXRhZy9zcmMvaW1nL3N2Zy9yZXNpemUtd2lkdGguc3ZnXG4vLyBtb2R1bGUgaWQgPSAzMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgc3ByaXRlID0gcmVxdWlyZShcIi9Vc2Vycy9uZWlsYW5kZXJzb24vU2l0ZXMvdGFnLWxpZ2h0c2hvdy9ub2RlX21vZHVsZXMvc3ZnLXNwcml0ZS1sb2FkZXIvbGliL3dlYi9nbG9iYWwtc3ByaXRlXCIpO1xudmFyIGltYWdlID0gXCI8c3ltYm9sIHZpZXdCb3g9XFxcIjAgMCA4IDhcXFwiIGlkPVxcXCJpY29uLXRhZ1xcXCIgPiA8cGF0aCBkPVxcXCJNMCAwdjNsNSA1IDMtMy01LTVoLTN6bTIgMWMuNTUgMCAxIC40NSAxIDFzLS40NSAxLTEgMS0xLS40NS0xLTEgLjQ1LTEgMS0xelxcXCIvPiA8L3N5bWJvbD5cIjtcbm1vZHVsZS5leHBvcnRzID0gc3ByaXRlLmFkZChpbWFnZSwgXCJpY29uLXRhZ1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbmpwLXRhZy9zcmMvaW1nL3N2Zy90YWcuc3ZnXG4vLyBtb2R1bGUgaWQgPSAzMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgc3ByaXRlID0gcmVxdWlyZShcIi9Vc2Vycy9uZWlsYW5kZXJzb24vU2l0ZXMvdGFnLWxpZ2h0c2hvdy9ub2RlX21vZHVsZXMvc3ZnLXNwcml0ZS1sb2FkZXIvbGliL3dlYi9nbG9iYWwtc3ByaXRlXCIpO1xudmFyIGltYWdlID0gXCI8c3ltYm9sIHZpZXdCb3g9XFxcIjAgMCA4IDhcXFwiIGlkPVxcXCJpY29uLXRleHRcXFwiID4gPHBhdGggZD1cXFwiTTAgMHYyaC41YzAtLjU1LjQ1LTEgMS0xaDEuNXY1LjVjMCAuMjgtLjIyLjUtLjUuNWgtLjV2MWg0di0xaC0uNWMtLjI4IDAtLjUtLjIyLS41LS41di01LjVoMS41Yy41NSAwIDEgLjQ1IDEgMWguNXYtMmgtOHpcXFwiLz4gPC9zeW1ib2w+XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHNwcml0ZS5hZGQoaW1hZ2UsIFwiaWNvbi10ZXh0XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9uanAtdGFnL3NyYy9pbWcvc3ZnL3RleHQuc3ZnXG4vLyBtb2R1bGUgaWQgPSAzMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNuaWZmciA9IHJlcXVpcmUoJ3NuaWZmcicpO1xuXG4vKipcbiAqIExpc3Qgb2YgU1ZHIGF0dHJpYnV0ZXMgdG8gZml4IHVybCB0YXJnZXQgaW4gdGhlbVxuICogQHR5cGUge3N0cmluZ1tdfVxuICovXG52YXIgZml4QXR0cmlidXRlcyA9IFtcbiAgJ2NsaXBQYXRoJyxcbiAgJ2NvbG9yUHJvZmlsZScsXG4gICdzcmMnLFxuICAnY3Vyc29yJyxcbiAgJ2ZpbGwnLFxuICAnZmlsdGVyJyxcbiAgJ21hcmtlcicsXG4gICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXJNaWQnLFxuICAnbWFya2VyRW5kJyxcbiAgJ21hc2snLFxuICAnc3Ryb2tlJ1xuXTtcblxuLyoqXG4gKiBRdWVyeSB0byBmaW5kJ2VtXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgZml4QXR0cmlidXRlc1F1ZXJ5ID0gJ1snICsgZml4QXR0cmlidXRlcy5qb2luKCddLFsnKSArICddJztcbi8qKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFVSSV9GVU5DX1JFR0VYID0gL151cmxcXCgoLiopXFwpJC87XG5cbi8qKlxuICogQ29udmVydCBhcnJheS1saWtlIHRvIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gYXJyYXlMaWtlXG4gKiBAcmV0dXJucyB7QXJyYXkuPCo+fVxuICovXG5mdW5jdGlvbiBhcnJheUZyb20oYXJyYXlMaWtlKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheUxpa2UsIDApO1xufVxuXG4vKipcbiAqIEhhbmRsZXMgZm9yYmlkZGVuIHN5bWJvbHMgd2hpY2ggY2Fubm90IGJlIGRpcmVjdGx5IHVzZWQgaW5zaWRlIGF0dHJpYnV0ZXMgd2l0aCB1cmwoLi4uKSBjb250ZW50LlxuICogQWRkcyBsZWFkaW5nIHNsYXNoIGZvciB0aGUgYnJhY2tldHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm4ge3N0cmluZ30gZW5jb2RlZCB1cmxcbiAqL1xuZnVuY3Rpb24gZW5jb2RlVXJsRm9yRW1iZWRkaW5nKHVybCkge1xuICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcKHxcXCkvZywgXCJcXFxcJCZcIik7XG59XG5cbi8qKlxuICogUmVwbGFjZXMgcHJlZml4IGluIGB1cmwoKWAgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHN2Z1xuICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRVcmxQcmVmaXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdVcmxQcmVmaXhcbiAqL1xuZnVuY3Rpb24gYmFzZVVybFdvcmtBcm91bmQoc3ZnLCBjdXJyZW50VXJsUHJlZml4LCBuZXdVcmxQcmVmaXgpIHtcbiAgdmFyIG5vZGVzID0gc3ZnLnF1ZXJ5U2VsZWN0b3JBbGwoZml4QXR0cmlidXRlc1F1ZXJ5KTtcblxuICBpZiAoIW5vZGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXJyYXlGcm9tKG5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKCFub2RlLmF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhcnJheUZyb20obm9kZS5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLmxvY2FsTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAoZml4QXR0cmlidXRlcy5pbmRleE9mKGF0dHJpYnV0ZU5hbWUpICE9PSAtMSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBVUklfRlVOQ19SRUdFWC5leGVjKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKTtcblxuICAgICAgICAvLyBEbyBub3QgdG91Y2ggdXJscyB3aXRoIHVuZXhwZWN0ZWQgcHJlZml4XG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXS5pbmRleE9mKGN1cnJlbnRVcmxQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgdmFyIHJlZmVyZW5jZVVybCA9IGVuY29kZVVybEZvckVtYmVkZGluZyhuZXdVcmxQcmVmaXggKyBtYXRjaFsxXS5zcGxpdChjdXJyZW50VXJsUHJlZml4KVsxXSk7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJ3VybCgnICsgcmVmZXJlbmNlVXJsICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBCZWNhdXNlIG9mIEZpcmVmb3ggYnVnICMzNTM1NzUgZ3JhZGllbnRzIGFuZCBwYXR0ZXJucyBkb24ndCB3b3JrIGlmIHRoZXkgYXJlIHdpdGhpbiBhIHN5bWJvbC5cbiAqIFRvIHdvcmthcm91bmQgdGhpcyB3ZSBtb3ZlIHRoZSBncmFkaWVudCBkZWZpbml0aW9uIG91dHNpZGUgdGhlIHN5bWJvbCBlbGVtZW50XG4gKiBAc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM1MzU3NVxuICogQHBhcmFtIHtFbGVtZW50fSBzdmdcbiAqL1xudmFyIEZpcmVmb3hTeW1ib2xCdWdXb3JrYXJvdW5kID0gZnVuY3Rpb24gKHN2Zykge1xuICB2YXIgZGVmcyA9IHN2Zy5xdWVyeVNlbGVjdG9yKCdkZWZzJyk7XG5cbiAgdmFyIG1vdmVUb0RlZnNFbGVtcyA9IHN2Zy5xdWVyeVNlbGVjdG9yQWxsKCdzeW1ib2wgbGluZWFyR3JhZGllbnQsIHN5bWJvbCByYWRpYWxHcmFkaWVudCwgc3ltYm9sIHBhdHRlcm4nKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1vdmVUb0RlZnNFbGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGRlZnMuYXBwZW5kQ2hpbGQobW92ZVRvRGVmc0VsZW1zW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGaXggZm9yIGJyb3dzZXIgKElFLCBtYXliZSBvdGhlciB0b28pIHdoaWNoIGFyZSB0aHJvd2luZyAnV3JvbmdEb2N1bWVudEVycm9yJ1xuICogaWYgeW91IGluc2VydCBhbiBlbGVtZW50IHdoaWNoIGlzIG5vdCBwYXJ0IG9mIHRoZSBkb2N1bWVudFxuICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc5ODExMDAvaG93LWRvLWktZHluYW1pY2FsbHktaW5zZXJ0LWFuLXN2Zy1pbWFnZS1pbnRvLWh0bWwjNzk4NjUxOVxuICogQHBhcmFtIHtFbGVtZW50fSBzdmdcbiAqL1xuZnVuY3Rpb24gaW1wb3J0U3ZnKHN2Zykge1xuICB0cnkge1xuICAgIGlmIChkb2N1bWVudC5pbXBvcnROb2RlKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuaW1wb3J0Tm9kZShzdmcsIHRydWUpO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxuXG4gIHJldHVybiBzdmc7XG59XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIERFRkFVTFRfVVJJX1BSRUZJWCA9ICcjJztcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgeExpbmtIcmVmID0gJ3hsaW5rOmhyZWYnO1xuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgeExpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIHN2Z09wZW5pbmcgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCInICsgeExpbmtOUyArICdcIic7XG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciBzdmdDbG9zaW5nID0gJzwvc3ZnPic7XG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciBjb250ZW50UGxhY2VIb2xkZXIgPSAne2NvbnRlbnR9JztcblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBTVkcgc3ByaXRlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3ByaXRlKCkge1xuICB2YXIgYmFzZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYmFzZScpWzBdO1xuICB2YXIgY3VycmVudFVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcjJylbMF07XG4gIHZhciBiYXNlVXJsID0gYmFzZUVsZW1lbnQgJiYgYmFzZUVsZW1lbnQuaHJlZjtcbiAgdGhpcy51cmxQcmVmaXggPSBiYXNlVXJsICYmIGJhc2VVcmwgIT09IGN1cnJlbnRVcmwgPyBjdXJyZW50VXJsICsgREVGQVVMVF9VUklfUFJFRklYIDogREVGQVVMVF9VUklfUFJFRklYO1xuXG4gIHZhciBzbmlmZnIgPSBuZXcgU25pZmZyKCk7XG4gIHNuaWZmci5zbmlmZigpO1xuICB0aGlzLmJyb3dzZXIgPSBzbmlmZnIuYnJvd3NlcjtcbiAgdGhpcy5jb250ZW50ID0gW107XG5cbiAgaWYgKHRoaXMuYnJvd3Nlci5uYW1lICE9PSAnaWUnICYmIGJhc2VVcmwpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc3ByaXRlTG9hZGVyTG9jYXRpb25VcGRhdGVkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjdXJyZW50UHJlZml4ID0gdGhpcy51cmxQcmVmaXg7XG4gICAgICB2YXIgbmV3VXJsUHJlZml4ID0gZS5kZXRhaWwubmV3VXJsLnNwbGl0KERFRkFVTFRfVVJJX1BSRUZJWClbMF0gKyBERUZBVUxUX1VSSV9QUkVGSVg7XG4gICAgICBiYXNlVXJsV29ya0Fyb3VuZCh0aGlzLnN2ZywgY3VycmVudFByZWZpeCwgbmV3VXJsUHJlZml4KTtcbiAgICAgIHRoaXMudXJsUHJlZml4ID0gbmV3VXJsUHJlZml4O1xuXG4gICAgICBpZiAodGhpcy5icm93c2VyLm5hbWUgPT09ICdmaXJlZm94JyB8fCB0aGlzLmJyb3dzZXIubmFtZSA9PT0gJ2VkZ2UnIHx8IHRoaXMuYnJvd3Nlci5uYW1lID09PSAnY2hyb21lJyAmJiB0aGlzLmJyb3dzZXIudmVyc2lvblswXSA+PSA0OSkge1xuICAgICAgICB2YXIgbm9kZXMgPSBhcnJheUZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgndXNlWyp8aHJlZl0nKSk7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaHJlZiA9IG5vZGUuZ2V0QXR0cmlidXRlKHhMaW5rSHJlZik7XG4gICAgICAgICAgaWYgKGhyZWYgJiYgaHJlZi5pbmRleE9mKGN1cnJlbnRQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKHhMaW5rTlMsIHhMaW5rSHJlZiwgbmV3VXJsUHJlZml4ICsgaHJlZi5zcGxpdChERUZBVUxUX1VSSV9QUkVGSVgpWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cbn1cblxuU3ByaXRlLnN0eWxlcyA9IFsncG9zaXRpb246YWJzb2x1dGUnLCAnd2lkdGg6MCcsICdoZWlnaHQ6MCddO1xuXG5TcHJpdGUuc3ByaXRlVGVtcGxhdGUgPSBmdW5jdGlvbigpeyByZXR1cm4gc3ZnT3BlbmluZyArICcgc3R5bGU9XCInKyBTcHJpdGUuc3R5bGVzLmpvaW4oJzsnKSArJ1wiPjxkZWZzPicgKyBjb250ZW50UGxhY2VIb2xkZXIgKyAnPC9kZWZzPicgKyBzdmdDbG9zaW5nOyB9XG5TcHJpdGUuc3ltYm9sVGVtcGxhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHN2Z09wZW5pbmcgKyAnPicgKyBjb250ZW50UGxhY2VIb2xkZXIgKyBzdmdDbG9zaW5nOyB9XG5cbi8qKlxuICogQHR5cGUge0FycmF5PFN0cmluZz59XG4gKi9cblNwcml0ZS5wcm90b3R5cGUuY29udGVudCA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICovXG5TcHJpdGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjb250ZW50LCBpZCkge1xuICBpZiAodGhpcy5zdmcpIHtcbiAgICB0aGlzLmFwcGVuZFN5bWJvbChjb250ZW50KTtcbiAgfVxuXG4gIHRoaXMuY29udGVudC5wdXNoKGNvbnRlbnQpO1xuXG4gIHJldHVybiBERUZBVUxUX1VSSV9QUkVGSVggKyBpZDtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBjb250ZW50XG4gKiBAcGFyYW0gdGVtcGxhdGVcbiAqIEByZXR1cm5zIHtFbGVtZW50fVxuICovXG5TcHJpdGUucHJvdG90eXBlLndyYXBTVkcgPSBmdW5jdGlvbiAoY29udGVudCwgdGVtcGxhdGUpIHtcbiAgdmFyIHN2Z1N0cmluZyA9IHRlbXBsYXRlLnJlcGxhY2UoY29udGVudFBsYWNlSG9sZGVyLCBjb250ZW50KTtcblxuICB2YXIgc3ZnID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdmdTdHJpbmcsICdpbWFnZS9zdmcreG1sJykuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgaW1wb3J0ZWRTdmcgPSBpbXBvcnRTdmcoc3ZnKTtcblxuICBpZiAodGhpcy5icm93c2VyLm5hbWUgIT09ICdpZScgJiYgdGhpcy51cmxQcmVmaXgpIHtcbiAgICBiYXNlVXJsV29ya0Fyb3VuZChpbXBvcnRlZFN2ZywgREVGQVVMVF9VUklfUFJFRklYLCB0aGlzLnVybFByZWZpeCk7XG4gIH1cblxuICByZXR1cm4gaW1wb3J0ZWRTdmc7XG59O1xuXG5TcHJpdGUucHJvdG90eXBlLmFwcGVuZFN5bWJvbCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHZhciBzeW1ib2wgPSB0aGlzLndyYXBTVkcoY29udGVudCwgU3ByaXRlLnN5bWJvbFRlbXBsYXRlKCkpLmNoaWxkTm9kZXNbMF07XG5cbiAgdGhpcy5zdmcucXVlcnlTZWxlY3RvcignZGVmcycpLmFwcGVuZENoaWxkKHN5bWJvbCk7XG4gIGlmICh0aGlzLmJyb3dzZXIubmFtZSA9PT0gJ2ZpcmVmb3gnKSB7XG4gICAgRmlyZWZveFN5bWJvbEJ1Z1dvcmthcm91bmQodGhpcy5zdmcpO1xuICB9XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblNwcml0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHdyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXIoKSk7XG4gIHJldHVybiB3cmFwcGVyLmlubmVySFRNTDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW3RhcmdldF1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXBlbmQ9dHJ1ZV1cbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gUmVuZGVyZWQgc3ByaXRlIG5vZGVcbiAqL1xuU3ByaXRlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBwcmVwZW5kKSB7XG4gIHRhcmdldCA9IHRhcmdldCB8fCBudWxsO1xuICBwcmVwZW5kID0gdHlwZW9mIHByZXBlbmQgPT09ICdib29sZWFuJyA/IHByZXBlbmQgOiB0cnVlO1xuXG4gIHZhciBzdmcgPSB0aGlzLndyYXBTVkcodGhpcy5jb250ZW50LmpvaW4oJycpLCBTcHJpdGUuc3ByaXRlVGVtcGxhdGUoKSk7XG5cbiAgaWYgKHRoaXMuYnJvd3Nlci5uYW1lID09PSAnZmlyZWZveCcpIHtcbiAgICBGaXJlZm94U3ltYm9sQnVnV29ya2Fyb3VuZChzdmcpO1xuICB9XG5cbiAgaWYgKHRhcmdldCkge1xuICAgIGlmIChwcmVwZW5kICYmIHRhcmdldC5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHN2ZywgdGFyZ2V0LmNoaWxkTm9kZXNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnN2ZyA9IHN2ZztcblxuICByZXR1cm4gc3ZnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3ZnLXNwcml0ZS1sb2FkZXIvbGliL3dlYi9zcHJpdGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCBBcHAgPSByZXF1aXJlKCduanAtdGFnJykuZGVmYXVsdDtcblxudmFyIGFwcCA9IG5ldyBBcHAoe1xuXHRvbkVsZW1lbnRSZW5kZXI6IGZ1bmN0aW9uKG1hcmt1cCwgZHJvcGxldCwgem9uZSwgaXNfb3V0cHV0KSB7XG5cdFx0aWYgKGRyb3BsZXQubmFtZSA9PT0gJ0xldHRlciBidXR0b24nICYmIGlzX291dHB1dCkge1xuXHRcdFx0bWFya3VwLmlubmVySFRNTCA9ICc8c3Bhbj4nICsgbWFya3VwLmlubmVySFRNTCArICc8L3NwYW4+Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFya3VwO1xuXHR9XG59KTtcblxuYXBwLmxvYWQoXG5cdCd0ZW1wbGF0ZXMvZGVmYXVsdC5odG1sJyxcblx0J3RlbXBsYXRlcy9wYWxsZXQuanNvbidcbikuY2F0Y2goKGVycm9yKSA9PiB7XG5cdGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3RhZy5qcyJdLCJzb3VyY2VSb290IjoiIn0=