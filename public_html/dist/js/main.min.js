webpackJsonp([0],{

/***/ 113:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _redux = __webpack_require__(31);

__webpack_require__(142);

__webpack_require__(278);

var _UI = __webpack_require__(141);

var _UI2 = _interopRequireDefault(_UI);

var _Droplet = __webpack_require__(23);

var _Droplet2 = _interopRequireDefault(_Droplet);

var _ajax = __webpack_require__(77);

var _ajax2 = _interopRequireDefault(_ajax);

var _Template = __webpack_require__(76);

var _Template2 = _interopRequireDefault(_Template);

var _actions = __webpack_require__(43);

var _actions2 = _interopRequireDefault(_actions);

var _reducers = __webpack_require__(143);

var _reducers2 = _interopRequireDefault(_reducers);

var _defaults = __webpack_require__(118);

var _defaults2 = _interopRequireDefault(_defaults);

var _constants = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Main application wraper.
 * @class
 */
var App = function App() {
	var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	this.settings = Object.deepAssign({}, App.defaults, settings);
	this._init();

	// set Template.onElementRender to settings, if defined
	if (settings.onElementRender) {
		_Template2.default.onElementRender = settings.onElementRender.bind(this);
	}
};

App.prototype = {
	_init: function _init() {
		this._refs = {
			ui: {
				app: document.querySelector('.app')
			},
			mounted: {},
			components: {}
		};

		// app data store (not stateful)
		this._data = {
			template: '',
			pallet: []
		};

		// templates module
		this._template = new _Template2.default(this, this.settings);
	},

	/**
  * Load the template/pallet data and activate Tag.
  */
	load: function load(url, pallet) {
		var _this = this;

		return this._template.load(url).then(function () {
			// load the HTML template and create it
			var data = _this._template.create();

			_this._data.drop_zones = data.drop_zones;
			_this._data.template = data.template;
		}).then(function () {
			// load the JSON based pallet data
			return _this._loadPallet(pallet);
		}).then(function () {
			var stored_state = false;

			// create state store
			if (stored_state) {
				// app state store - from session
				// !TODO
			} else {
				// app state store - default
				_this._store = (0, _redux.createStore)(_reducers2.default);
			}

			// activate the UI
			_this._UI = new _UI2.default(_this, _this.settings, _this._refs, _this._data, _this._store, _this._template);

			// render
			_this._UI.render();

			_this._store.dispatch(_actions2.default.setUIState(_constants.uiStates.ACTIVE));
		}).catch(function (error) {
			throw error;
		});
	},

	/**
  * Load the pallet data
  * @private
  */
	_loadPallet: function _loadPallet(url) {
		var _this2 = this;

		return _ajax2.default.get(url).then(function (response) {
			var pallet, item;

			try {
				pallet = JSON.parse(response.text);
			} catch (e) {
				return Promise.reject(new Error('Pallet data at file "' + url + '"" could not be parsed.' + ' is it valid JSON?'));
			}

			if (Array.isArray(pallet) && pallet.length) {
				for (item in pallet) {
					_this2._data.pallet.push(new _Droplet2.default(pallet[item]));
				}
			} else {
				throw new Error('Looks like the pallet at path ' + url + ' isn’t a valid array in JSON format.');
			}
		}).catch(function (error) {
			throw error;
		});
	}
};

/**
 * Default settings.
 */
App.defaults = _defaults2.default;

exports.default = App;

/***/ }),

/***/ 117:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _constants = __webpack_require__(9);

// default state for...
exports.default = {
	// general application
	app: {
		ui_state: _constants.uiStates.INITIALISING,
		active: false,
		active_droplet_id: ''
	},

	// active zones and current attachments
	zones: {},

	// dialog mode and state
	dialog: {
		mode: _constants.dialogModes.NONE,
		state: {}
	}
};

/***/ }),

/***/ 118:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = {
	classes: {
		canvas: 'tag-canvas',
		canvas_active: 'active',
		droplet_active: 'droplet-active',
		is_dragging: 'dragging',
		item_dragging: 'item-dragging',
		dropzone: 'drop-zone',
		dropzone_target: 'target',
		dropzone_is_active: 'is-active',
		dropzone_is_target: 'is-target',
		attached: 'attached',
		text_element: 'text',
		hidden: 'hidden',
		droplet: {
			node: 'droplet',
			active: 'active'
		},
		dialog: {
			main: 'dialog',
			visible: 'visible',
			container: 'dialog-container',
			heading: 'dialog-heading'
		}
	},
	selectors: {
		drop_zone: '.drop-zone .target',
		droplet: '.droplet'
	},
	template: {
		initial_flex_basis: 50
	},
	view: {
		src: 'view.html'
	},
	dropZone: {
		label: '...'
	},
	onElementRender: null
};

/***/ }),

/***/ 119:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.optionValueSet = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var optionValueSet = exports.optionValueSet = function optionValueSet(values) {
	var nodes = [],
	    key;

	if (Array.isArray(values)) {
		values.forEach(function (value, index) {
			var key = 'item-' + index;
			nodes.push(_react2.default.createElement(
				'option',
				{ key: key, value: value },
				value
			));
		});
	} else if ((typeof values === 'undefined' ? 'undefined' : _typeof(values)) === 'object') {
		for (key in values) {
			nodes.push(_react2.default.createElement(
				'option',
				{ key: key, value: key },
				values[key]
			));
		}
	}

	return nodes;
};

/***/ }),

/***/ 120:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(24);

var _View = __webpack_require__(136);

var _View2 = _interopRequireDefault(_View);

var _TemplateContainer = __webpack_require__(124);

var _TemplateContainer2 = _interopRequireDefault(_TemplateContainer);

var _DialogContainer = __webpack_require__(122);

var _DialogContainer2 = _interopRequireDefault(_DialogContainer);

var _PalletContainer = __webpack_require__(123);

var _PalletContainer2 = _interopRequireDefault(_PalletContainer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Canvas = function (_Component) {
	_inherits(Canvas, _Component);

	function Canvas(props) {
		_classCallCheck(this, Canvas);

		return _possibleConstructorReturn(this, (Canvas.__proto__ || Object.getPrototypeOf(Canvas)).call(this, props));
	}

	_createClass(Canvas, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (typeof this.props.onMount === 'function') {
				this.props.onMount('canvas');
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var classes = [this.props.settings.classes.canvas, this.props.state.ui_state];

			if (this.props.state.active_droplet_id !== '') {
				classes.push(this.props.settings.classes.droplet_active);
			}

			return _react2.default.createElement(
				'div',
				{ className: classes.join(' '),
					ref: (0, _utils.collectRef)(this.props, 'canvas')
				},
				_react2.default.createElement(
					'header',
					null,
					_react2.default.createElement(
						'h1',
						null,
						'<',
						_react2.default.createElement(
							'b',
							null,
							'Tag'
						),
						'>'
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'main' },
					_react2.default.createElement(_TemplateContainer2.default, {
						data: this.props.data,
						settings: this.props.settings,
						refCollector: this.props.refCollector,
						onMount: this.props.onMount,
						onAttachmentClick: this.props.onAttachmentClick,
						onDropZoneClick: this.props.onDropZoneClick,
						template: this.props.data.template,
						class_ui: this.props.class_ui
					}),
					_react2.default.createElement('div', { className: 'drag-handle',
						onMouseDown: this.props.onDragHandlePress,
						onMouseUp: this.props.onDragHandlePress,
						onTouchStart: this.props.onDragHandlePress,
						onTouchEnd: this.props.onDragHandlePress,
						ref: (0, _utils.collectRef)(this.props, 'drag_handle') }),
					_react2.default.createElement(_View2.default, {
						settings: this.props.settings,
						onMount: this.props.onMount,
						refCollector: this.props.refCollector })
				),
				_react2.default.createElement(_PalletContainer2.default, {
					data: this.props.data,
					settings: this.props.settings,
					onMount: this.props.onMount,
					onDropletClick: this.props.onDropletClick,
					refCollector: this.props.refCollector }),
				_react2.default.createElement('div', { className: 'overlay' }),
				_react2.default.createElement(_DialogContainer2.default, {
					data: this.props.data,
					settings: this.props.settings,
					class_ui: this.props.class_ui,
					class_template: this.props.class_template,
					onDialogComplete: this.props.onDialogComplete,
					onDialogCancel: this.props.onDialogCancel })
			);
		}
	}]);

	return Canvas;
}(_react.Component);

Canvas.propTypes = {
	// from CanvasContainer
	state: _react.PropTypes.object.isRequired,

	// from UI#render
	data: _react.PropTypes.object.isRequired,
	onMount: _react.PropTypes.func.isRequired,
	onDialogComplete: _react.PropTypes.func.isRequired,
	onDialogCancel: _react.PropTypes.func.isRequired,
	onAttachmentClick: _react.PropTypes.func.isRequired,
	onDropletClick: _react.PropTypes.func.isRequired,
	onDropZoneClick: _react.PropTypes.func.isRequired,
	onDragHandlePress: _react.PropTypes.func.isRequired,
	refCollector: _react.PropTypes.func.isRequired,
	settings: _react.PropTypes.object.isRequired,
	class_ui: _react.PropTypes.object.isRequired,
	class_template: _react.PropTypes.object.isRequired
};

exports.default = Canvas;

/***/ }),

/***/ 121:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(18);

var _Canvas = __webpack_require__(120);

var _Canvas2 = _interopRequireDefault(_Canvas);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapStateToProps = function mapStateToProps(state) {
	return {
		state: state.app
	};
};

var CanvasContainer = (0, _reactRedux.connect)(mapStateToProps)(_Canvas2.default);

exports.default = CanvasContainer;

/***/ }),

/***/ 122:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(18);

var _Dialog = __webpack_require__(125);

var _Dialog2 = _interopRequireDefault(_Dialog);

var _constants = __webpack_require__(9);

var _actions = __webpack_require__(43);

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapStateToProps = function mapStateToProps(state) {
	return {
		mode: state.dialog.mode,
		state: state.dialog.state
	};
};

var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	return {
		onDialogCancel: function onDialogCancel() {
			dispatch(_actions2.default.setDialogMode(_constants.dialogModes.NONE));
		}
	};
};

var DialogContainer = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_Dialog2.default);

exports.default = DialogContainer;

/***/ }),

/***/ 123:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(18);

var _Pallet = __webpack_require__(134);

var _Pallet2 = _interopRequireDefault(_Pallet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapStateToProps = function mapStateToProps(state) {
	return {
		activeDropletId: state.app.active_droplet_id
	};
};

var PalletContainer = (0, _reactRedux.connect)(mapStateToProps)(_Pallet2.default);

exports.default = PalletContainer;

/***/ }),

/***/ 124:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(18);

var _Template = __webpack_require__(135);

var _Template2 = _interopRequireDefault(_Template);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapStateToProps = function mapStateToProps(state) {
	return {
		zones: state.zones
	};
};

var TemplateContainer = (0, _reactRedux.connect)(mapStateToProps)(_Template2.default);

exports.default = TemplateContainer;

/***/ }),

/***/ 125:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _constants = __webpack_require__(9);

var _DialogEditDroplet = __webpack_require__(126);

var _DialogEditDroplet2 = _interopRequireDefault(_DialogEditDroplet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DialogComponents = {};

// import the dialogs used, then put into a global for referencing

DialogComponents[_constants.dialogModes.EDIT_DROPLET] = _DialogEditDroplet2.default;

function Dialog(props) {
	var Component,
	    classes = [props.settings.classes.dialog.main];

	if (props.mode !== _constants.dialogModes.NONE) {
		classes.push(props.settings.classes.dialog.visible);
	}

	// get appropriate component for dialog mode
	Component = DialogComponents[props.mode];

	if (Component) {
		return _react2.default.createElement(
			'div',
			{ className: classes.join(' ') },
			_react2.default.createElement(Component, {
				state: props.state,
				settings: props.settings,
				class_template: props.class_template,
				onDialogComplete: props.onDialogComplete,
				onDialogCancel: props.onDialogCancel,
				class_ui: props.class_ui })
		);
	} else {
		return _react2.default.createElement('div', { className: classes.join(' ') });
	}
}

Dialog.propTypes = {
	// from DialogContainer
	mode: _react.PropTypes.string,
	state: _react.PropTypes.object,

	// from Canvas
	settings: _react.PropTypes.object,
	onDialogComplete: _react.PropTypes.func,
	onDialogCancel: _react.PropTypes.func,
	class_ui: _react.PropTypes.object,
	class_template: _react.PropTypes.object
};

Dialog.defaultProps = {};

exports.default = Dialog;

/***/ }),

/***/ 126:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _FormField = __webpack_require__(32);

var _FormField2 = _interopRequireDefault(_FormField);

var _constants = __webpack_require__(9);

var _Icon = __webpack_require__(40);

var _DialogHeading = __webpack_require__(127);

var _DialogHeading2 = _interopRequireDefault(_DialogHeading);

var _Form = __webpack_require__(133);

var _Form2 = _interopRequireDefault(_Form);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var headingsByType = {
	'element': {
		text: 'Element',
		icon: _Icon.GLYPHS.TAG
	},
	'text': {
		text: 'Text item',
		icon: _Icon.GLYPHS.TEXT
	},
	'attribute': {
		text: 'Attribute',
		icon: _Icon.GLYPHS.PUZZLE_PIECE
	}
};

var DialogEditDroplet = function (_Component) {
	_inherits(DialogEditDroplet, _Component);

	function DialogEditDroplet(props) {
		_classCallCheck(this, DialogEditDroplet);

		var _this = _possibleConstructorReturn(this, (DialogEditDroplet.__proto__ || Object.getPrototypeOf(DialogEditDroplet)).call(this, props));

		if (_this.props.state && _this.props.state.droplet_id) {
			_this.droplet = _this.props.class_ui.getDropletById(_this.props.state.droplet_id);
		}

		_this.onDialogComplete = _this.onDialogComplete.bind(_this);
		_this.detachAttachment = _this.detachAttachment.bind(_this);
		return _this;
	}

	_createClass(DialogEditDroplet, [{
		key: 'onDialogComplete',
		value: function onDialogComplete(values) {
			var data = {},
			    key;

			if (typeof this.props.onDialogComplete === 'function') {
				// massage data back into format replicating Droplet.data format
				for (key in values) {
					if (values.hasOwnProperty(key)) {
						if (key === 'attrs') {
							data[key] = values[key];
						} else {
							data[key] = values[key][key];
						}
					}
				}

				data = Object.deepAssign({}, this.droplet.data, data);

				// send data to callback
				this.props.onDialogComplete(data);
			}
		}
	}, {
		key: 'detachAttachment',
		value: function detachAttachment() {
			if (this.props.state.attachment_index !== null) {
				this.props.class_ui.zoneDetachAttachment(this.props.state.zone_id, this.props.state.attachment_index);
			} else {
				throw new Error('attachment_index is null or not defined. Cannot detach');
			}

			this.props.onDialogCancel();
		}
	}, {
		key: 'getFieldsets',
		value: function getFieldsets() {
			var fieldsets = [],
			    attachment = null,
			    fieldset,
			    field,
			    attribute,
			    item;

			if (this.props.state.attachment_index !== null) {
				attachment = this.props.class_ui.zoneGetAttachment(this.props.state.zone_id, this.props.state.attachment_index);
			}

			for (attribute in this.droplet.editable) {
				fieldset = {
					key: attribute,
					legend: _constants.setLabels[attribute],
					fields: []
				};

				// add indidual fields, depending on editable attribute type
				if (attribute === 'attrs') {
					// the 'attrs' attribute, which contains key/value pairs
					for (item in this.droplet.editable[attribute]) {
						field = Object.deepAssign({}, this.droplet.editable[attribute][item]);

						// preset value from attachment
						if (attachment !== null && attachment.data.attrs && attachment.data.attrs[item]) {
							field.value = attachment.data.attrs[item];
						}

						fieldset.fields.push(new _FormField2.default(item, this.droplet.editable[attribute][item].type, field));
					}
				} else {
					// string based attributes
					field = Object.deepAssign({}, this.droplet.editable[attribute]);

					// preset value from attachment
					if (attachment !== null && attachment.data[attribute]) {
						field.value = attachment.data[attribute];
					}

					fieldset.fields.push(new _FormField2.default(attribute, this.droplet.editable[attribute].type, field));
				}

				// add fieldset to form
				fieldsets.push(fieldset);
			}

			return fieldsets;
		}
	}, {
		key: 'render',
		value: function render() {
			var fieldsets = this.getFieldsets(),
			    buttons = [],
			    classes = [this.props.settings.classes.dialog.container],
			    title,
			    notes;

			classes.push('droplet-' + this.droplet.dropletType);

			if (this.props.state.attachment_index !== null) {
				// editing
				title = 'Edit ' + headingsByType[this.droplet.dropletType].text;

				if (fieldsets.length) {
					notes = ['You can edit the Droplet using the fields below. ' + 'Change the bits you want to customise and use “Add Droplet” when you’re done.'];

					buttons.push({
						type: 'submit',
						label: 'Edit Droplet'
					});
				} else {
					notes = ['There is nothing to edit on this Droplet, but you can remove it ' + 'With the “Remove Droplet” button.'];
				}

				buttons.push({
					type: 'general',
					label: 'Remove Droplet',
					className: 'danger pull-left',
					onClick: this.detachAttachment
				});
			} else {
				// adding
				title = 'Add ' + headingsByType[this.droplet.dropletType].text;
				notes = ['You’ve found the right drop place to put this Droplet! ', 'Edit anything you would like to change and then use “Edit Droplet”.'];
				buttons = buttons.concat({
					type: 'submit',
					label: 'Add Droplet'
				});
			}

			buttons.push({
				type: 'cancel',
				onClick: this.props.onDialogCancel,
				label: 'Cancel'
			});

			return _react2.default.createElement(
				'div',
				{ className: classes.join(' ') },
				_react2.default.createElement(_DialogHeading2.default, {
					title: title,
					notes: notes,
					iconGlyph: headingsByType[this.droplet.dropletType].icon,
					className: this.props.settings.classes.dialog.heading }),
				_react2.default.createElement(_Form2.default, {
					fieldSets: fieldsets,
					buttons: buttons,
					onSubmit: this.onDialogComplete,
					onCancel: this.props.onDialogCancel })
			);
		}
	}]);

	return DialogEditDroplet;
}(_react.Component);

DialogEditDroplet.propTypes = {
	state: _react.PropTypes.object.isRequired,
	settings: _react.PropTypes.object.isRequired,
	onDialogCancel: _react.PropTypes.func,
	onDialogComplete: _react.PropTypes.func,
	class_ui: _react.PropTypes.object.isRequired
};

DialogEditDroplet.defaultProps = {
	onDialogCancel: null,
	onDialogComplete: null
};

exports.default = DialogEditDroplet;

/***/ }),

/***/ 127:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Icon = __webpack_require__(40);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DialogHeading = function DialogHeading(props) {
	var notes = [],
	    icon;

	props.notes.forEach(function (note, index) {
		return notes.push(_react2.default.createElement(
			'p',
			{ key: 'note-' + index },
			note
		));
	});

	if (props.iconGlyph) {
		icon = _react2.default.createElement(_Icon.Icon, { glyph: props.iconGlyph });
	}

	return _react2.default.createElement(
		'div',
		{ className: props.className },
		_react2.default.createElement(
			'h2',
			null,
			icon,
			_react2.default.createElement(
				'span',
				null,
				props.title
			)
		),
		notes
	);
};

DialogHeading.propTypes = {
	iconGlyph: _react.PropTypes.string,
	className: _react.PropTypes.string.isRequired,
	title: _react.PropTypes.string.isRequired,
	notes: _react.PropTypes.arrayOf(_react.PropTypes.string)
};

exports.default = DialogHeading;

/***/ }),

/***/ 128:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Button = function Button(props) {
	var type = props.type === 'submit' ? 'submit' : 'button',
	    classes = [props.className],
	    onClick = props.onClick;

	if (props.type === 'cancel') {
		classes.push('cancel');
		onClick = props.onCancel;
	} else if (props.type === 'submit') {
		classes.push('primary');
	}

	return _react2.default.createElement(
		'button',
		{
			className: classes.join(' '),
			onClick: onClick,
			type: type },
		props.label
	);
};

Button.propTypes = {
	type: _react.PropTypes.oneOf(['submit', 'cancel', 'general']).isRequired,
	label: _react.PropTypes.string.isRequired,
	className: _react.PropTypes.string,
	onClick: _react.PropTypes.func,
	onCancel: _react.PropTypes.func
};

exports.default = Button;

/***/ }),

/***/ 129:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(24);

var _DropZone = __webpack_require__(42);

var _DropZone2 = _interopRequireDefault(_DropZone);

var _DropZoneAttachment = __webpack_require__(130);

var _DropZoneAttachment2 = _interopRequireDefault(_DropZoneAttachment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DropZoneComponent = function (_Component) {
	_inherits(DropZoneComponent, _Component);

	function DropZoneComponent(props) {
		_classCallCheck(this, DropZoneComponent);

		var _this = _possibleConstructorReturn(this, (DropZoneComponent.__proto__ || Object.getPrototypeOf(DropZoneComponent)).call(this, props));

		_this.myrefs = {};
		_this.attachmentClick = _this.attachmentClick.bind(_this);
		_this.onClick = _this.onClick.bind(_this);
		return _this;
	}

	_createClass(DropZoneComponent, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (typeof this.props.onMount === 'function') {
				this.props.onMount('dropzone', this.props.zone.id);
			}
		}
	}, {
		key: 'onClick',
		value: function onClick(event) {
			event.preventDefault();
			this.props.onClick(event, this.props.zone);
		}
	}, {
		key: 'attachmentClick',
		value: function attachmentClick(event, droplet, attachmentIndex) {
			if (typeof this.props.onAttachmentClick === 'function') {
				this.props.onAttachmentClick(droplet, this.props.zone, attachmentIndex);
			}
		}
	}, {
		key: 'renderActiveAttachments',
		value: function renderActiveAttachments() {
			var _this2 = this;

			var children = [];

			this.props.activeAttachments.forEach(function (attachment, index) {
				children.push(_react2.default.createElement(_DropZoneAttachment2.default, {
					key: attachment.droplet_id + '-attachment-' + index,
					attachmentIndex: index,
					onClick: _this2.attachmentClick,
					droplet: _this2.props.class_ui.getDropletById(attachment.droplet_id),
					zone: _this2.props.zone,
					data: attachment.data }));
			});

			return children;
		}
	}, {
		key: 'render',
		value: function render() {
			var key = this.props.zone.id + '-zone',
			    target_key = this.props.zone.id + '-target',
			    target_class;

			target_class = this.props.activeAttachments.length < this.props.zone.maxAttachments ? this.props.settings.classes.dropzone_target : this.props.settings.classes.dropzone_target + ' ' + this.props.settings.classes.hidden;

			return _react2.default.createElement(
				'span',
				{
					key: key,
					className: this.props.settings.classes.dropzone,
					ref: (0, _utils.collectRef)(this.props, ['dropzone'], this.props.zone.id),
					'data-id': this.props.zone.id,
					'data-attachment': this.props.zone.attachmentId },
				_react2.default.createElement(
					'span',
					{
						className: 'attachments' },
					this.renderActiveAttachments()
				),
				_react2.default.createElement(
					'span',
					{ className: 'target-outer' },
					_react2.default.createElement(
						'span',
						{ key: target_key,
							onClick: this.onClick,
							ref: (0, _utils.collectRef)(this.props, ['dropzone_target'], this.props.zone.id),
							className: target_class },
						_react2.default.createElement(
							'b',
							null,
							this.props.settings.dropZone.label
						)
					)
				)
			);
		}
	}]);

	return DropZoneComponent;
}(_react.Component);

DropZoneComponent.propTypes = {
	zone: _react.PropTypes.instanceOf(_DropZone2.default).isRequired,
	settings: _react.PropTypes.object.isRequired,
	activeAttachments: _react.PropTypes.array.isRequired,
	onMount: _react.PropTypes.func.isRequired,
	onAttachmentClick: _react.PropTypes.func.isRequired,
	onClick: _react.PropTypes.func.isRequired,
	refCollector: _react.PropTypes.func.isRequired,
	class_ui: _react.PropTypes.object.isRequired
};

exports.default = DropZoneComponent;

/***/ }),

/***/ 130:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Template = __webpack_require__(76);

var _Template2 = _interopRequireDefault(_Template);

var _Droplet = __webpack_require__(23);

var _Droplet2 = _interopRequireDefault(_Droplet);

var _DropZone = __webpack_require__(42);

var _DropZone2 = _interopRequireDefault(_DropZone);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DropZoneAttachment = function (_Component) {
	_inherits(DropZoneAttachment, _Component);

	function DropZoneAttachment(props) {
		_classCallCheck(this, DropZoneAttachment);

		var _this = _possibleConstructorReturn(this, (DropZoneAttachment.__proto__ || Object.getPrototypeOf(DropZoneAttachment)).call(this, props));

		_this.onClick = _this.onClick.bind(_this);
		return _this;
	}

	_createClass(DropZoneAttachment, [{
		key: 'onClick',
		value: function onClick(event) {
			event.preventDefault();

			this.props.onClick(event, this.props.droplet, this.props.attachmentIndex);
		}
	}, {
		key: 'render',
		value: function render() {
			var className = 'dropzone-attachment',
			    data;

			// merge edited data with droplet data
			data = Object.deepAssign({}, this.props.droplet.data, this.props.data);

			// set classname
			className += ' ' + this.props.droplet.dropletType;

			return _react2.default.createElement(
				'span',
				{
					className: className,
					onClick: this.onClick },
				_Template2.default.renderDroplet(this.props.droplet, data, this.props.zone, false)
			);
		}
	}]);

	return DropZoneAttachment;
}(_react.Component);

DropZoneAttachment.propTypes = {
	droplet: _react.PropTypes.instanceOf(_Droplet2.default).isRequired,
	zone: _react.PropTypes.instanceOf(_DropZone2.default).isRequired,
	attachmentIndex: _react.PropTypes.number.isRequired,
	onClick: _react.PropTypes.func.isRequired,
	data: _react.PropTypes.object.isRequired
};

exports.default = DropZoneAttachment;

/***/ }),

/***/ 131:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(24);

var _Droplet = __webpack_require__(23);

var _Droplet2 = _interopRequireDefault(_Droplet);

var _Icon = __webpack_require__(40);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dropletTypeToGlyphs = {
	'text': _Icon.GLYPHS.TEXT,
	'element': _Icon.GLYPHS.TAG,
	'attribute': _Icon.GLYPHS.PUZZLE_PIECE
};

var DropletComponent = function (_Component) {
	_inherits(DropletComponent, _Component);

	function DropletComponent(props) {
		_classCallCheck(this, DropletComponent);

		var _this = _possibleConstructorReturn(this, (DropletComponent.__proto__ || Object.getPrototypeOf(DropletComponent)).call(this, props));

		_this.myrefs = {};
		_this.onClick = _this.onClick.bind(_this);
		return _this;
	}

	_createClass(DropletComponent, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (typeof this.props.onMount === 'function') {
				this.props.onMount('droplet', this.props.droplet.id);
			}
		}
	}, {
		key: 'onClick',
		value: function onClick(event) {
			event.preventDefault();
			this.props.onClick(event, this.props.droplet);
		}
	}, {
		key: 'render',
		value: function render() {
			var classes = [this.props.settings.classes.droplet.node, 'type-' + this.props.droplet.dropletType];

			if (this.props.active) {
				classes.push(this.props.settings.classes.droplet.active);
			}

			return _react2.default.createElement(
				'a',
				{ href: '#',
					id: this.props.droplet.id,
					className: classes.join(' '),
					onClick: this.onClick,
					ref: (0, _utils.collectRef)(this.props, ['droplet'], this.props.droplet.id) },
				_react2.default.createElement(
					'span',
					{ className: 'label' },
					_react2.default.createElement(_Icon.Icon, { glyph: dropletTypeToGlyphs[this.props.droplet.dropletType] }),
					this.props.droplet.name
				)
			);
		}
	}]);

	return DropletComponent;
}(_react.Component);

DropletComponent.propTypes = {
	active: _react.PropTypes.bool,
	settings: _react.PropTypes.object.isRequired,
	droplet: _react.PropTypes.instanceOf(_Droplet2.default).isRequired,
	onMount: _react.PropTypes.func,
	onClick: _react.PropTypes.func
};

exports.default = DropletComponent;

/***/ }),

/***/ 132:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _FormField = __webpack_require__(32);

var _FormField2 = _interopRequireDefault(_FormField);

var _TextField = __webpack_require__(138);

var _TextField2 = _interopRequireDefault(_TextField);

var _DropDown = __webpack_require__(137);

var _DropDown2 = _interopRequireDefault(_DropDown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldComponents = {
	'text': _TextField2.default,
	'dropdown': _DropDown2.default
};

var Fieldset = function (_Component) {
	_inherits(Fieldset, _Component);

	function Fieldset(props) {
		_classCallCheck(this, Fieldset);

		var formValues = {};

		// set default state for fields based on original values
		var _this = _possibleConstructorReturn(this, (Fieldset.__proto__ || Object.getPrototypeOf(Fieldset)).call(this, props));

		_this.props.fields.forEach(function (field) {
			return formValues[field.name] = field.value || '';
		});

		// set default form value state
		_this.state = {
			formValues: formValues
		};

		// bind functions for events
		_this.elementChange = _this.elementChange.bind(_this);
		return _this;
	}

	_createClass(Fieldset, [{
		key: 'fields',
		value: function fields() {
			var _this2 = this;

			var Component,
			    output = [];

			this.props.fields.forEach(function (field) {
				var key = 'field-' + field.name;

				Component = FieldComponents[field.type];

				switch (field.type) {
					case 'text':
						output.push(_react2.default.createElement(Component, { key: key,
							field: field,
							onChange: _this2.elementChange,
							value: _this2.state.formValues[field.name] }));
						break;

					case 'dropdown':
						output.push(_react2.default.createElement(Component, { key: key,
							field: field,
							onChange: _this2.elementChange,
							value: _this2.state.formValues[field.name] }));
				}
			});

			return output;
		}
	}, {
		key: 'elementChange',
		value: function elementChange(event) {
			var target = event.target,
			    formValues = Object.deepAssign({}, this.state.formValues);

			formValues[target.name] = target.value;

			this.setState({
				formValues: formValues
			});

			this.props.onFieldUpdate(this.props.set, target.name, target.value, formValues);
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'fieldset',
				null,
				_react2.default.createElement(
					'legend',
					null,
					this.props.legend
				),
				this.fields()
			);
		}
	}]);

	return Fieldset;
}(_react.Component);

Fieldset.propTypes = {
	set: _react.PropTypes.string.isRequired,
	onFieldUpdate: _react.PropTypes.func.isRequired,
	legend: _react.PropTypes.string,
	fields: _react.PropTypes.arrayOf(_react2.default.PropTypes.instanceOf(_FormField2.default))
};

Fieldset.defaultProps = {
	onFieldUpdate: function onFieldUpdate() {},
	fields: {}
};

exports.default = Fieldset;

/***/ }),

/***/ 133:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Fieldset = __webpack_require__(132);

var _Fieldset2 = _interopRequireDefault(_Fieldset);

var _Button = __webpack_require__(128);

var _Button2 = _interopRequireDefault(_Button);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @typedef FormOnSubmit
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @param {object} formValues - the current values of the form elements, as an object.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * @typedef FormFieldSets
 * @description
 * An array of fieldsets — each item of which contains an object defining a
 * single fieldset. See {@link FormFieldset}.
 * @example
 * var fieldsets = [
 * 	{@link FormFieldSet}...
 * ];
 */

/**
 * An object defining a single fieldset.
 * @typedef FormFieldSet
 * @property {string} key - Unique key value.
 * @property {string} legend - Legend label.
 * @property {object} fields - Fields within the fieldset. The keys of which
 * should represent the name of the field, with the values being one of
 * {@link FormField} each.
 * @example
 * var fieldset = [
 * 	{@link FormField}...
 * ]
 */


/**
 * @description
 * Takes a form specification and produces an HTML form.
 * See {@link Form.propTypes} for more information
 */
var Form = function (_Component) {
	_inherits(Form, _Component);

	function Form(props) {
		_classCallCheck(this, Form);

		var formValues = {};

		// set default state for fields based on original values
		var _this = _possibleConstructorReturn(this, (Form.__proto__ || Object.getPrototypeOf(Form)).call(this, props));

		_this.props.fieldSets.forEach(function (set) {
			formValues[set.key] = {};

			set.fields.forEach(function (field) {
				return formValues[set.key][field.name] = field.value;
			});
		});

		// set default form value state
		_this.state = {
			formValues: formValues
		};

		// bind functions for events
		_this.elementChange = _this.elementChange.bind(_this);
		return _this;
	}

	_createClass(Form, [{
		key: 'valueSet',
		value: function valueSet(values, node) {
			var nodes = [],
			    key;

			if (Array.isArray(values)) {
				values.forEach(function (value) {
					nodes.push(_react2.default.createElement(
						'node',
						{ value: value },
						value
					));
				});
			} else if ((typeof values === 'undefined' ? 'undefined' : _typeof(values)) === 'object') {
				for (key in values) {
					nodes.push(_react2.default.createElement(
						'node',
						{ value: key },
						values[key]
					));
				}
			}

			return nodes;
		}
	}, {
		key: 'fieldSets',
		value: function fieldSets() {
			var _this2 = this;

			var output = [];

			this.props.fieldSets.forEach(function (set) {
				var key = 'fieldset-' + set.key;

				output.push(_react2.default.createElement(_Fieldset2.default, {
					key: key,
					set: set.key,
					fields: set.fields,
					legend: set.legend,
					onFieldUpdate: _this2.elementChange
				}));
			});

			return output;
		}
	}, {
		key: 'elementChange',
		value: function elementChange(set, name, value, values_state) {
			var sets = Object.assign({}, this.state.formValues);

			sets[set] = values_state;

			this.setState({
				formValues: sets
			});
		}
	}, {
		key: 'onSubmit',
		value: function onSubmit(event) {
			event.preventDefault();
			this.props.onSubmit(this.state.formValues);
		}
	}, {
		key: 'getButtons',
		value: function getButtons() {
			var _this3 = this;

			var buttons = [];

			if (this.props.buttons && this.props.buttons.length) {
				this.props.buttons.forEach(function (button, index) {
					buttons.push(_react2.default.createElement(_Button2.default, {
						key: 'button-' + index,
						type: button.type,
						label: button.label,
						className: button.className,
						onCancel: _this3.props.onCancel,
						onClick: button.onClick }));
				});
			}

			return buttons;
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'form',
				{ action: '', onSubmit: this.onSubmit.bind(this) },
				_react2.default.createElement(
					'div',
					{ className: 'fields' },
					this.fieldSets()
				),
				_react2.default.createElement(
					'fieldset',
					{ className: 'buttons' },
					this.getButtons()
				)
			);
		}
	}]);

	return Form;
}(_react.Component);

/**
 * @property {function} onCancel - invoked when the form is cancelled
 * @property {FormOnSubmit} onSubmit - invoked when the form is submitted
 * @property {FormFieldSets} fieldSets - fieldsets for display
 */


Form.propTypes = {
	onCancel: _react.PropTypes.func,
	onSubmit: _react.PropTypes.func,
	fieldSets: _react.PropTypes.arrayOf(_react.PropTypes.shape({
		key: _react.PropTypes.string,
		legend: _react.PropTypes.string,
		fields: _react.PropTypes.array
	})),
	buttons: _react.PropTypes.array
};

Form.defaultProps = {
	onCancel: function onCancel() {},
	onSubmit: function onSubmit() {},
	fieldSets: {}
};

exports.default = Form;

/***/ }),

/***/ 134:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Droplet = __webpack_require__(131);

var _Droplet2 = _interopRequireDefault(_Droplet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Pallet = function (_Component) {
	_inherits(Pallet, _Component);

	function Pallet(props) {
		_classCallCheck(this, Pallet);

		return _possibleConstructorReturn(this, (Pallet.__proto__ || Object.getPrototypeOf(Pallet)).call(this, props));
	}

	_createClass(Pallet, [{
		key: 'getItems',
		value: function getItems() {
			var _this2 = this;

			var items = [];

			if (this.props.data.pallet) {
				this.props.data.pallet.forEach(function (droplet) {
					items.push(_react2.default.createElement(_Droplet2.default, { droplet: droplet,
						active: _this2.props.activeDropletId === droplet.id,
						settings: _this2.props.settings,
						onMount: _this2.props.onMount,
						onClick: _this2.props.onDropletClick,
						refCollector: _this2.props.refCollector,
						key: droplet.id }));
				});
			}

			return items;
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'section',
				{ className: 'pallet' },
				this.getItems.apply(this)
			);
		}
	}]);

	return Pallet;
}(_react.Component);

Pallet.propTypes = {
	// from PalletContainer
	activeDropletId: _react.PropTypes.string.isRequired,

	// from Canvas
	data: _react.PropTypes.object.isRequired,
	settings: _react.PropTypes.object.isRequired,
	onMount: _react.PropTypes.func,
	onDropletClick: _react.PropTypes.func.isRequired,
	refCollector: _react.PropTypes.func
};

Pallet.defaultProps = {
	data: {
		pallet: []
	}
};

exports.default = Pallet;

/***/ }),

/***/ 135:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(24);

var _DropZone = __webpack_require__(129);

var _DropZone2 = _interopRequireDefault(_DropZone);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Template = function (_Component) {
	_inherits(Template, _Component);

	function Template(props) {
		_classCallCheck(this, Template);

		return _possibleConstructorReturn(this, (Template.__proto__ || Object.getPrototypeOf(Template)).call(this, props));
	}

	_createClass(Template, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (typeof this.props.onMount === 'function') {
				this.props.onMount('template');
			}
		}

		/**
   * Uses state (from props.zones) to ascertain the attachments
   */

	}, {
		key: 'getZoneAttachments',
		value: function getZoneAttachments(dropzone_id) {
			var zone,
			    attachments = [];

			if (this.props.zones && (zone = this.props.zones[dropzone_id])) {
				attachments = zone.attachments;
			}

			return attachments;
		}
	}, {
		key: 'getTemplate',
		value: function getTemplate() {
			var _this2 = this;

			var children = [];

			this.props.template.forEach(function (node, index) {
				var key;

				switch (node.type) {
					case 'text':
						key = 'fragment-' + index;

						children.push(_react2.default.createElement(
							'span',
							{
								key: key,
								className: _this2.props.settings.classes.component },
							node.content
						));
						break;

					case 'dropzone':
						children.push(_react2.default.createElement(_DropZone2.default, {
							key: node.zone.id,
							zone: node.zone,
							settings: _this2.props.settings,
							activeAttachments: _this2.getZoneAttachments(node.zone.id),
							refCollector: _this2.props.refCollector,
							onMount: _this2.props.onMount,
							onClick: _this2.props.onDropZoneClick,
							onAttachmentClick: _this2.props.onAttachmentClick,
							class_ui: _this2.props.class_ui }));
						break;
				}
			});

			return children;
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'section',
				{ className: 'template',
					ref: (0, _utils.collectRef)(this.props, 'template') },
				_react2.default.createElement(
					'pre',
					null,
					_react2.default.createElement(
						'code',
						{ className: 'html',
							ref: (0, _utils.collectRef)(this.props, 'template_inner') },
						this.getTemplate()
					)
				)
			);
		}
	}]);

	return Template;
}(_react.Component);

Template.propTypes = {
	// from TemplateContainer
	zones: _react.PropTypes.object.isRequired,

	// from Canvas
	settings: _react.PropTypes.object.isRequired,
	template: _react.PropTypes.array.isRequired,
	onMount: _react.PropTypes.func.isRequired,
	onAttachmentClick: _react.PropTypes.func.isRequired,
	onDropZoneClick: _react.PropTypes.func.isRequired,
	refCollector: _react.PropTypes.func.isRequired,
	class_ui: _react.PropTypes.object.isRequired
};

Template.defaultProps = {
	template: ''
};

exports.default = Template;

/***/ }),

/***/ 136:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(24);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var View = function (_Component) {
	_inherits(View, _Component);

	function View(props) {
		_classCallCheck(this, View);

		return _possibleConstructorReturn(this, (View.__proto__ || Object.getPrototypeOf(View)).call(this, props));
	}

	_createClass(View, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (typeof this.props.onMount === 'function') {
				this.props.onMount('view_frame');
			}
		}
	}, {
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate() {
			// no. reloads/updates are handled by the view class
			return false;
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'section',
				{ className: 'view',
					ref: (0, _utils.collectRef)(this.props, 'view') },
				_react2.default.createElement('div', { className: 'drag-mask' }),
				_react2.default.createElement('iframe', { ref: (0, _utils.collectRef)(this.props, 'view_frame'),
					src: this.props.settings.view.src })
			);
		}
	}]);

	return View;
}(_react.Component);

View.propTypes = {
	settings: _react.PropTypes.object,
	onMount: _react.PropTypes.func,
	refCollector: _react.PropTypes.func
};

exports.default = View;

/***/ }),

/***/ 137:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _commonPropTypes = __webpack_require__(75);

var _componentUtils = __webpack_require__(119);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DropDown(props) {
	var label = props.field.label || props.field.name;

	return _react2.default.createElement(
		'div',
		{ className: 'field' },
		_react2.default.createElement(
			'label',
			null,
			label
		),
		_react2.default.createElement(
			'select',
			{
				type: 'text',
				name: props.field.name,
				onChange: props.onChange,
				value: props.value },
			(0, _componentUtils.optionValueSet)(props.field.options)
		)
	);
}

DropDown.propTypes = _commonPropTypes.field;

exports.default = DropDown;

/***/ }),

/***/ 138:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _commonPropTypes = __webpack_require__(75);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function TextField(props) {
	var label = props.field.label || props.field.name;

	return _react2.default.createElement(
		'div',
		{ className: 'field' },
		_react2.default.createElement(
			'label',
			null,
			label
		),
		_react2.default.createElement('input', {
			type: 'text',
			name: props.field.name,
			placeholder: props.field.placeholder,
			onChange: props.onChange,
			maxLength: props.field.data.maxlength,
			value: props.value })
	);
}

TextField.propTypes = _commonPropTypes.field;

exports.default = TextField;

/***/ }),

/***/ 139:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _interact = __webpack_require__(69);

var _interact2 = _interopRequireDefault(_interact);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.interact = _interact2.default;

/**
 * Handles draggable/droppable items.
 * @class
 */
var DragDrop = function DragDrop(canvas, settings) {
	var callbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	this._canvas = canvas;
	this.settings = settings;
	this._callbacks = callbacks;

	this.ui = {
		drag: [],
		drop: []
	};
};

DragDrop.prototype = {
	addDragable: function addDragable(element) {
		var _this = this;

		var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		var dragable = new Dragable(element);

		// duplicate settings
		settings = Object.assign({}, settings);

		// make the element draggable
		dragable.setDragable(settings).on('dragstart', function () {
			_this._canvas.classList.add(_this.settings.classes.is_dragging);
			element.classList.add(_this.settings.classes.item_dragging);
		}).on('dragend', function () {
			_this._canvas.classList.remove(_this.settings.classes.is_dragging);
			element.classList.remove(_this.settings.classes.item_dragging);

			if (typeof _this._callbacks.dragEnd === 'function') {
				_this._callbacks.dragEnd(element, data);
			}
		});

		this.ui.drag.push(this._createInstance(element, dragable));
	},

	addDropable: function addDropable(element) {
		var _this2 = this;

		var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		var dropable = new Dropable(element);

		dropable.setDropable(settings).on('dropactivate', function (event) {
			// add active dropzone feedback
			event.target.classList.add(_this2.settings.classes.dropzone_is_active);
		}).on('dragenter', function (event) {
			// feedback the possibility of a drop
			event.target.classList.add(_this2.settings.classes.dropzone_is_target);
			// event.relatedTarget.classList.add('can-drop');
			// event.relatedTarget.textContent = 'Dragged in';
		}).on('dragleave', function (event) {
			// remove the drop feedback style
			event.target.classList.remove(_this2.settings.classes.dropzone_is_target);
			// event.relatedTarget.classList.remove('can-drop');
			// event.relatedTarget.textContent = 'Dragged out';
		}).on('drop', function (event) {
			if (typeof _this2._callbacks.drop === 'function') {
				_this2._callbacks.drop(event.relatedTarget, event.target, data);
			}
		}).on('dropdeactivate', function (event) {
			// remove active dropzone feedback
			event.target.classList.remove(_this2.settings.classes.dropzone_is_active);
			event.target.classList.remove(_this2.settings.classes.dropzone_is_target);
		});

		this.ui.drop.push(this._createInstance(element, dropable));
	},

	resetDragPosition: function resetDragPosition(element) {
		if (element = this.getDragInstance(element)) {
			element.instance.resetPosition();
		}
	},

	getDragInstance: function getDragInstance(element) {
		return this.ui.drag.find(function (item) {
			return item.element === element;
		});
	},

	_createInstance: function _createInstance(element, instance) {
		return {
			element: element,
			instance: instance
		};
	}
};

/*
 * Generically handles the dragging and dropping of individual DOM nodes.
 * Uses interact.js (http://interactjs.io)
 */
var Dragable = function Dragable(element) {
	this._element = element;

	this._x = 0;
	this._y = 0;
};

Dragable.prototype = {
	/**
  * Set up a draggable item.
  */
	setDragable: function setDragable(settings) {
		var _this3 = this;

		return (0, _interact2.default)(this._element).draggable(settings).on('dragmove', settings.onDragMove || function (event) {
			_this3._x += event.dx;
			_this3._y += event.dy;

			_this3._element.style.webkitTransform = _this3._element.style.transform = 'translate(' + _this3._x + 'px, ' + _this3._y + 'px)';
		});
	},

	resetPosition: function resetPosition() {
		this._x = 0;
		this._y = 0;

		this._element.style.webkitTransform = this._element.style.transform = 'translate(0, 0)';
	}
};

/*
 * Generically handles drop zones in the DOM.
 * Uses interact.js (http://interactjs.io)
 */
var Dropable = function Dropable(element) {
	this._element = element;
};

Dropable.prototype = {
	/**
  * Set up a draggable item.
  */
	setDropable: function setDropable(settings) {
		return (0, _interact2.default)(this._element).dropzone(settings);
	}
};

exports.default = DragDrop;

/***/ }),

/***/ 140:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Takes multiple functions and returns a function which invokes them consecutively
 * with the same argument signature: (prop) `value`, `propname`, `droplet_name`, `droplet_type`.
 */
function chain() {
	var args = Array.prototype.slice.call(arguments);

	return function (value, propname, droplet_name, droplet_type) {
		var _this = this;

		var test = true;

		// run each function in the chain
		args.forEach(function (fn) {
			if (!fn.apply(_this, [value, propname, droplet_name, droplet_type])) {
				test = false;
			}
		});

		return test;
	};
}

/**
 * Asserts the `test` value is truthy. In the case that it fails, an Error is thrown.
 * @param {boolean} test - Test expression result
 * @param {string} propname - The name of the property being tested
 * @param {string} message - The message, in case of failure. Will be appended to a general
 * error message.
 * @param {string} [droplet_name] - The name of the Droplet being tested
 * @param {string} [toplet_type] - The dropletType attribute of the Droplet being tested
 */
function assert(test, propname, message, droplet_name, droplet_type) {
	var error, prop_id;

	if (!test) {
		if (droplet_name) {
			prop_id = '"' + droplet_name + '"' + (droplet_type ? ' (' + droplet_type + ')' : '');
		}

		error = 'Error in Droplet' + (prop_id ? ' ' + prop_id + ' ' : ' ') + 'prop "' + propname + '". ' + message;
		throw new Error(error);
	} else {
		return true;
	}
}

function isRequired(value, prop, droplet_name, droplet_type) {
	return assert(typeof value !== 'undefined', prop, 'Value is required.', droplet_name, droplet_type);
}

function stringNotEmpty(value, prop, droplet_name, droplet_type) {
	return assert(typeof value !== 'undefined' && value !== '', prop, 'Value cannot be empty.', droplet_name, droplet_type);
}

function string(value, prop, droplet_name, droplet_type) {
	return assert(typeof value === 'undefined' || typeof value === 'string', prop, 'Value must be a string.', droplet_name, droplet_type);
}

string.isRequired = chain(string, isRequired);
string.notEmpty = chain(string, stringNotEmpty);
string.notEmpty.isRequired = chain(string, stringNotEmpty, isRequired);

function object(value, prop, droplet_name, droplet_type) {
	return assert(typeof value === 'undefined' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object', prop, 'Value must be an object.', droplet_name, droplet_type);
}

object.isRequired = chain(object, isRequired);

function array(value, prop, droplet_name, droplet_type) {
	return assert(Array.isArray(value), prop, 'Value must be an array.', droplet_name, droplet_type);
}

array.isRequired = chain(array, isRequired);

function arrayOf() {}

arrayOf.string = chain(
// test for an array
array,
// test array values are all strings
function (value, prop, droplet_name, droplet_type) {
	var test = true,
	    a;

	for (a = 0; a < value.length; a += 1) {
		test = test ? typeof value[a] === 'string' : test;
	}

	return assert(test, prop, 'Value must be an array containing only strings', droplet_name, droplet_type);
});

arrayOf.string.isRequired = chain(arrayOf.string, isRequired);

exports.default = {
	_chain: chain,
	_assert: assert,
	string: string,
	object: object,
	array: array,
	arrayOf: arrayOf,
	isRequired: isRequired,
	stringNotEmpty: stringNotEmpty
};

/***/ }),

/***/ 141:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _DragDrop = __webpack_require__(139);

var _DragDrop2 = _interopRequireDefault(_DragDrop);

var _Communicator = __webpack_require__(41);

var _Communicator2 = _interopRequireDefault(_Communicator);

var _CanvasContainer = __webpack_require__(121);

var _CanvasContainer2 = _interopRequireDefault(_CanvasContainer);

var _actions = __webpack_require__(43);

var _actions2 = _interopRequireDefault(_actions);

var _constants = __webpack_require__(9);

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(71);

var _reactRedux = __webpack_require__(18);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var UI = function UI(parent, settings, refs, data, store, template) {
	/**
  * Settings as defined when instantiating. Inherits from {@link App.defaults}
  */
	this._parent = parent;
	this.settings = settings;
	this._refs = refs;
	this._data = data;
	this._store = store;
	this._template = template;

	// UI class specific data entries
	this._data.UI = {
		dragdrop: {},
		dropletEdit: {
			droplet: null,
			callback: null
		},
		vp_width: 0,
		dragHandlePosition: 0
	};

	this._comms = new _Communicator2.default('app', window.location.origin, {
		message: function message(_message) {
			console.log('message to "app"!', _message);
		}
	});

	// general queues
	this.queues = {
		dragdropBindings: []
	};

	window.addEventListener('resize', this._handleWindowResize.bind(this));
};

UI.prototype = {
	/**
  * Sends render() call to the React canvas.
  * @private
  */
	render: function render() {
		this._canvas = (0, _reactDom.render)(_react2.default.createElement(
			_reactRedux.Provider,
			{ store: this._store },
			_react2.default.createElement(_CanvasContainer2.default, {
				data: this._data,
				settings: this.settings,
				refCollector: this._refCollector.bind(this),
				onMount: this._mountEvent.bind(this),
				onDialogComplete: this._completeDialogAction.bind(this),
				onDialogCancel: this._cancelDialogAction.bind(this),
				onAttachmentClick: this._handleAttachmentClick.bind(this),
				onDropletClick: this._handleDropletClick.bind(this),
				onDropZoneClick: this._handleDropZoneClick.bind(this),
				onDragHandlePress: this._handleDragHandleEvent.bind(this),
				class_ui: this,
				class_template: this._template })
		), this._refs.ui.app);
	},

	/**
  * Displays an editor window for a Droplet.
  * @param {string} mode - One of the dropletModes modes.
  * @param {mixed} data - Relevant data to store for the dialog to use.
  * @private
  */
	_showDialog: function _showDialog(mode, data) {
		this._store.dispatch(_actions2.default.setDialogMode(mode, data));
	},

	_completeDialogAction: function _completeDialogAction(dialog_data) {
		var state = this._store.getState();

		// reset dialog state to nothing
		this._store.dispatch(_actions2.default.setDialogMode(_constants.dialogModes.NONE));

		switch (state.dialog.mode) {
			case _constants.dialogModes.EDIT_DROPLET:
				// droplet being edited prior to or during attatchment
				if (state.dialog.state.attachment_index === null) {
					// no attachment index - this is a new drop
					this.zoneAddAttachment(state.dialog.state.zone_id, state.dialog.state.droplet_id, dialog_data);
				} else {
					this.zoneEditAttachment(state.dialog.state.zone_id, state.dialog.state.attachment_index, dialog_data);
				}
		}
	},

	_cancelDialogAction: function _cancelDialogAction() {
		// noop
	},

	/**
  * Element reference collector. Collects DOM elements from React components.
  * Bind an element reference using the ref attribute and collectRef from utils.js
  * @private
  */
	_refCollector: function _refCollector(collection, element, key) {
		if (element !== null) {
			if (typeof key === 'string') {
				if (typeof this._refs.components[collection] === 'undefined') {
					this._refs.components[collection] = {};
				}

				this._refs.components[collection][key] = element;
			} else {
				this._refs.components[collection] = element;
			}
		}
	},

	/**
  * Captures mount events from React components by collection/key identifiers.
  * Identifiers are the same as the ones stored with App#_refCollector
  * @private
  */
	_mountEvent: function _mountEvent(collection, key) {
		if (this._getReferencedElement(collection, key)) {
			// valid component mounted
			switch (collection) {
				case 'canvas':
					// add drag binding for the drag handle
					this._queueDragDropBinding('drag', 'drag_handle', null, {
						onDragMove: this._handleDragHandleEvent.bind(this)
					});

					// process all drag/drop bindings
					this._setDragDropBindings();
					this._refs.mounted.canvas = true;
					break;

				case 'template':
					// this._queueDragDropBinding('drop', collection, key);
					this._refs.mounted.template = true;
					break;

				case 'droplet':
					this._queueDragDropBinding('drag', collection, key);
					break;

				case 'dropzone':
					this._queueDragDropBinding('drop', 'dropzone_target', key);
					break;

				case 'view_frame':
					this._comms.registerGuestAddress('view', this._refs.components[collection].contentWindow);

					this._refs.mounted.view_frame = true;
			}

			if (this._refs.mounted.canvas && this._refs.mounted.template && this._refs.mounted.view_frame) {
				// all required refs mounted - set active
				this._store.dispatch(_actions2.default.setUIState(_constants.uiStates.ACTIVE));

				// run initial size calculations
				this._handleWindowResize();
			}
		} else {
			throw new Error('Component mount event called but ref was not collected. ' + 'component: ' + collection + (key ? '/' + key : ''));
		}
	},

	/**
  * Queues a drag/drop DOM binding till the mount event for the Canvas component.
  * This is done because the canvas is relied upon as the container for dragging.
  * @private
  */
	_queueDragDropBinding: function _queueDragDropBinding(type, collection, key, settings) {
		if (this._refs.components.canvas) {
			// canvas already exists - immediately bind
			this._setDragDropBindings([{ type: type, collection: collection, key: key, settings: settings }]);
		} else {
			// push to queue
			this.queues.dragdropBindings.push({ type: type, collection: collection, key: key, settings: settings });
		}
	},

	_setDragDropBindings: function _setDragDropBindings() {
		var _this = this;

		var queue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.queues.dragdropBindings;

		// bind dragDrop handlers to the elements in the queue
		this._data.UI.dragdrop.droplets = new _DragDrop2.default(this._refs.components.canvas, this.settings, {
			drop: this._handleDropletDrop.bind(this),
			dragEnd: function dragEnd(element) {
				_this._data.UI.dragdrop.droplets.resetDragPosition(element);
			}
		});

		queue.forEach(function (item) {
			var ref = _this._getReferencedElement(item.collection, item.key),
			    data;

			if (item.collection === 'dropzone_target') {
				data = {
					zone_id: item.key
				};
			}

			// create a DragDrop instance and assign to the pallet item data
			if (item.type === 'drag') {
				_this._data.UI.dragdrop.droplets.addDragable(ref, item.settings, data);
			} else if (item.type === 'drop') {
				_this._data.UI.dragdrop.droplets.addDropable(ref, Object.deepAssign({}, {
					accept: _this.settings.selectors.droplet
				}, item.settings), data);
			}
		});
	},

	/**
  * Handles drops of droplets into drop zones. Will attach to the zone
  * if the drop is valid.
  * @param {HTMLElement} element - The element being dragged.
  * @param {HTMLElement} target - The target being dropped onto.
  * @param {object} data - data object, as set with addDragable/addDropable.
  * @private
  */
	_handleDropletDrop: function _handleDropletDrop(element, target, data) {
		var drop_zone = this.getDropZoneById(data.zone_id),
		    droplet = this.getDropletById(element.id);

		return this.attachDropletToDropZone(droplet, drop_zone);
	},

	_handleAttachmentClick: function _handleAttachmentClick(droplet, drop_zone, attachment_index) {
		this._showDialog(_constants.dialogModes.EDIT_DROPLET, {
			droplet_id: droplet.id,
			zone_id: drop_zone.id,
			attachment_index: attachment_index
		});
	},

	_handleDropletClick: function _handleDropletClick(event, droplet) {
		var state = this._store.getState();

		if (state.app.active_droplet_id !== droplet.id) {
			this._store.dispatch(_actions2.default.setActiveDroplet(droplet.id));
		}
	},

	_handleDropZoneClick: function _handleDropZoneClick(event, drop_zone) {
		var state = this._store.getState(),
		    droplet;

		if (state.app.active_droplet_id !== 0 && (droplet = this.getDropletById(state.app.active_droplet_id))) {
			this.attachDropletToDropZone(droplet, drop_zone);
		}
	},

	/**
  * Handles events from the drag handle (between template and view containers)
  * @private
  */
	_handleDragHandleEvent: function _handleDragHandleEvent(event) {
		var width;

		switch (event.type) {
			case 'dragmove':
				// incrememt dragHandlePosition based on x delta from interact instance
				this._data.UI.dragHandlePosition += event.dx;

				// figure out handle position in % of the screen and convert it to percent,
				// then send straight to _setTemplateViewRatio function
				this._setTemplateViewRatio((this._data.UI.drag_handle_x + this._data.UI.dragHandlePosition) / this._data.UI.vp_width * 100);

				break;

			case 'mouseup':
			case 'touchend':
				if (this._data.UI.dragHandlePosition < 5 && this._data.UI.dragHandlePosition > -5) {
					// little movement - assume a click/tap occured
					width = this._getReferencedElement('drag_handle').offsetWidth;

					if (this._data.UI.drag_handle_x < width) {
						// set to 50/50
						this._setTemplateViewRatio(50);
					} else {
						// set to 0/100
						this._setTemplateViewRatio(0);
					}
				}

				// update metrics whenever we're stopping
				this._handleWindowResize();
				break;
		}
	},

	_handleWindowResize: function _handleWindowResize() {
		this._data.UI.drag_handle_x = this._getReferencedElement('drag_handle').offsetLeft;
		this._data.UI.vp_width = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);

		// reset dragHandlePosition because the metrics have changed
		this._data.UI.dragHandlePosition = 0;
	},

	/**
  * @param {number} ratio - % ratio for the template
  * @description
  * Sets the template/view ratio by giving the template container a % width and
  * adjusting the view container accordingly.
  * @private
  */
	_setTemplateViewRatio: function _setTemplateViewRatio(ratio) {
		this._refs.components.template.style.flexBasis = ratio + '%';
		this._refs.components.view.style.flexBasis = Math.abs(ratio - 100) + '%';
	},

	_isValidDrop: function _isValidDrop(droplet, drop_zone) {
		return drop_zone.willAccept(droplet, this._store);
	},

	attachDropletToDropZone: function attachDropletToDropZone(droplet, drop_zone) {
		// clear active droplet
		this._store.dispatch(_actions2.default.setActiveDroplet(''));

		// check if valid drop
		if (this._isValidDrop(droplet, drop_zone)) {
			if (droplet.editable) {
				// show edit dialog before adding the attachment
				this._showDialog(_constants.dialogModes.EDIT_DROPLET, {
					droplet_id: droplet.id,
					zone_id: drop_zone.id,
					attachment_index: null
				});
			} else {
				// add attachment without dialog
				this.zoneAddAttachment(drop_zone.id, droplet.id, droplet.data);
			}

			return true;
		} else {
			return false;
		}
	},

	zoneAddAttachment: function zoneAddAttachment(zone_id, droplet_id, data) {
		this._store.dispatch(_actions2.default.zoneAddAttachment(zone_id, droplet_id, true, data));

		this._updateView();
	},

	zoneEditAttachment: function zoneEditAttachment(zone_id, attachment_index, data) {
		this._store.dispatch(_actions2.default.zoneEditAttachment(zone_id, attachment_index, data));

		this._updateView();
	},

	zoneDetachAttachment: function zoneDetachAttachment(zone_id, attachment_index) {
		this._store.dispatch(_actions2.default.zoneDetachAttachment(zone_id, attachment_index));
	},

	/**
  * Retrieve a zone's attachment (by index)
  */
	zoneGetAttachment: function zoneGetAttachment(zone_id, attachment_index) {
		var zone,
		    state = this._store.getState();

		if (state.zones && (zone = state.zones[zone_id]) && zone.attachments && zone.attachments.length > attachment_index) {
			return zone.attachments[attachment_index];
		}

		return null;
	},

	_updateView: function _updateView() {
		var state = this._store.getState();

		this._comms.send('view', {
			cmd: _constants.messageCommands.RELOAD,
			data: {
				markup: this._template.renderAsHTML(state.zones)
			}
		});
	},

	/**
  * Obtains an element stored in the internal refs collection
  */
	_getReferencedElement: function _getReferencedElement(collection, key) {
		var ref;

		if ((typeof key === 'undefined' || !key) && (ref = this._refs.components[collection]) || (ref = this._refs.components[collection][key])) {
			return ref;
		} else {
			throw new Error('Referenced element at ' + collection + '(' + key + ') could not be found.');
		}
	},

	getDropletById: function getDropletById(id) {
		return this._data.pallet.find(function (element) {
			return element.id === id;
		});
	},

	getDropZoneById: function getDropZoneById(id) {
		return this._data.drop_zones[id] || null;
	}
};

exports.default = UI;

/***/ }),

/***/ 142:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// JS Polyfills - doesn't export anything, just modifies existing Object specs
Object.deepAssign = function (target, varArgs) {
	'use strict';

	var to, from, index, key;

	if (target == null) {
		// TypeError if undefined or null
		throw new TypeError('Cannot convert undefined or null to object');
	}

	to = typeof varArgs !== 'undefined' && Array.isArray(varArgs) && arguments.length === 2 ? Array(target) : // arrays to retain their identity
	Object(target); // otherwise use an object

	for (index = 1; index < arguments.length; index++) {
		from = arguments[index];

		if (from != null || typeof from === 'undefined') {
			for (key in from) {
				if (from.hasOwnProperty(key)) {
					if (_typeof(from[key]) === 'object' && from[key] != null) {
						to[key] = Object.deepAssign(Array.isArray(from[key]) ? [] : {}, to[key], from[key]);
					} else {
						to[key] = from[key];
					}
				}
			}
		}
	}

	return to;
};

/***/ }),

/***/ 143:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _defaultState = __webpack_require__(117);

var _defaultState2 = _interopRequireDefault(_defaultState);

var _constants = __webpack_require__(9);

var _redux = __webpack_require__(31);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets application state values
 */
function app() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _defaultState2.default.app;
	var action = arguments[1];

	var active;

	switch (action.type) {
		// set ui state
		case _constants.actionTypes.UI_STATE:
			// set 'active' flag based on the ui_state value
			switch (action.ui_state) {
				case _constants.uiStates.ACTIVE:
					active = true;
					break;

				default:
					active = false;
			}

			return Object.assign({}, state, {
				ui_state: action.ui_state,
				active: active
			});

		case _constants.actionTypes.SET_ACTIVE_DROPLET:
			// set the active droplet (i.e. the one that will be "dropped" when a
			// drop zone is next clicked
			return Object.assign({}, state, {
				active_droplet_id: action.droplet_id
			});

		default:
			return state;
	}
}

/**
 * Sets drop zone state values
 */
function zones() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _defaultState2.default.zones;
	var action = arguments[1];

	var zones = Object.assign({}, state);

	switch (action.type) {
		case _constants.actionTypes.ZONE_ADD_ATTACHMENT:
			if (!zones[action.id]) {
				zones[action.id] = {
					attachments: []
				};
			}

			// attach the droplet
			zones[action.id].attachments.push({
				droplet_id: action.droplet_id,
				data: action.data
			});

			break;

		case _constants.actionTypes.ZONE_EDIT_ATTACHMENT:
			if (zones[action.id].attachments[action.attachment_index]) {
				zones[action.id].attachments[action.attachment_index].data = action.data;
			}

			break;

		case _constants.actionTypes.ZONE_DETACH_ATTACHMENT:
			// detach the attachment by index
			if (action.attachment_index !== null && action.attachment_index < zones[action.id].attachments.length) {
				zones[action.id].attachments.splice(action.attachment_index, 1);
			}

			break;

		default:
			return state;
	}

	return zones;
}

function dialog() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _defaultState2.default.dialog;
	var action = arguments[1];

	switch (action.type) {
		case _constants.actionTypes.SET_DIALOG_MODE:
			return Object.assign({}, state, {
				mode: action.mode,
				state: action.state
			});

		default:
			return state;
	}
}

exports.default = (0, _redux.combineReducers)({
	app: app,
	zones: zones,
	dialog: dialog
});

/***/ }),

/***/ 144:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),

/***/ 145:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(144)
var ieee754 = __webpack_require__(164)
var isArray = __webpack_require__(166)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)))

/***/ }),

/***/ 147:
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(148)(undefined);
// imports
exports.push([module.i, "@import url(//fonts.googleapis.com/css?family=Fira+Mono|Muli:400,700);", ""]);

// module
exports.push([module.i, "/* reset */\nhtml, body, div, span, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\nabbr, address, cite, code,\ndel, dfn, em, img, ins, kbd, q, samp,\nsmall, strong, sub, sup, var,\nb, i,\ndl, dt, dd, ol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section, summary,\ntime, mark, audio, video {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  outline: 0;\n  font-size: 100%;\n  vertical-align: baseline;\n  background: transparent; }\n\nbody {\n  line-height: 1; }\n\narticle, aside, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section {\n  display: block; }\n\nnav ul {\n  list-style: none; }\n\nblockquote, q {\n  quotes: none; }\n\nblockquote:before, blockquote:after,\nq:before, q:after {\n  content: '';\n  content: none; }\n\na {\n  margin: 0;\n  padding: 0;\n  font-size: 100%;\n  vertical-align: baseline;\n  background: transparent; }\n\n/* change colours to suit your needs */\nins {\n  background-color: #ff9;\n  color: #000;\n  text-decoration: none; }\n\n/* change colours to suit your needs */\nmark {\n  background-color: #ff9;\n  color: #000;\n  font-style: italic;\n  font-weight: bold; }\n\ndel {\n  text-decoration: line-through; }\n\nabbr[title], dfn[title] {\n  border-bottom: 1px dotted;\n  cursor: help; }\n\ntable {\n  border-collapse: collapse;\n  border-spacing: 0; }\n\n/* change border colour to suit your needs */\nhr {\n  display: block;\n  height: 1px;\n  border: 0;\n  border-top: 1px solid #cccccc;\n  margin: 1em 0;\n  padding: 0; }\n\ninput, select {\n  vertical-align: middle; }\n\nbody {\n  font-family: \"Muli\", sans-serif;\n  line-height: 140%;\n  color: #333; }\n\nh1 {\n  font-size: 24px;\n  font-size: 1.5rem; }\n\nh2 {\n  font-size: 22px;\n  font-size: 1.375rem; }\n\nh3 {\n  font-size: 20px;\n  font-size: 1.25rem; }\n\np {\n  margin: .75em 0;\n  font-size: 16px;\n  font-size: 1rem; }\n\np:first-child {\n  margin-top: 0; }\n\np:last-child {\n  margin-bottom: 0; }\n\npre {\n  font-family: \"Fira Mono\", monospace; }\n\n.view iframe {\n  z-index: 1; }\n\n.overlay,\n.view .drag-mask {\n  z-index: 2; }\n\n.droplet,\n.drag-handle {\n  z-index: 3; }\n\n.dialog {\n  z-index: 4; }\n\n* {\n  box-sizing: border-box; }\n\n/* main layout */\nbody {\n  background-color: #fff; }\n\n.app,\n.tag-canvas {\n  position: absolute;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  right: 0; }\n\n.tag-canvas {\n  display: flex;\n  flex-direction: column; }\n  .tag-canvas header {\n    flex-shrink: 0; }\n  .tag-canvas .main {\n    display: flex;\n    flex-grow: 1; }\n    .tag-canvas .main > *:not(.drag-handle) {\n      flex-basis: 50%; }\n    .tag-canvas .main .drag-handle {\n      flex-basis: 20px; }\n  .tag-canvas .pallet {\n    flex-shrink: 0; }\n\nheader {\n  padding: 10px;\n  border-bottom: 1px solid #ccc; }\n  header h1 {\n    letter-spacing: 1px; }\n    header h1 b {\n      color: #464ae0; }\n\n.template {\n  overflow: auto;\n  border-right: 1px solid #ccc;\n  background-color: #eee; }\n  .template pre {\n    margin: 10px;\n    line-height: 130%;\n    tab-size: 3; }\n  .template .hljs {\n    font-size: 1.125em;\n    line-height: 130%; }\n    .template .hljs .drop-zone .hljs-string {\n      color: white; }\n\n.droplet-active .template,\n.dragging .template {\n  background-color: #f3ffc6; }\n\n.view {\n  position: relative;\n  border-left: 1px solid #ccc; }\n  .view iframe,\n  .view .drag-mask {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%; }\n  .view .drag-mask {\n    visibility: hidden;\n    background-color: #fff; }\n\n.dragging .view .drag-mask {\n  visibility: visible;\n  opacity: .7; }\n\n.pallet {\n  display: flex;\n  flex-wrap: wrap;\n  border-top: 1px solid #ccc;\n  padding: 5px 10px;\n  background-color: #eee; }\n  .pallet .droplet {\n    margin: 5px 10px 5px 0; }\n\n.drop-zone {\n  display: inline-block; }\n  .drop-zone .target-outer {\n    display: inline-block;\n    position: relative; }\n  .drop-zone .target b {\n    border-radius: 3px;\n    padding: 2px 5px;\n    background-color: #959eff;\n    line-height: 120%;\n    color: white; }\n  .drop-zone .target.is-active b {\n    background-color: #464ae0; }\n  .drop-zone .target.is-target b {\n    box-shadow: 0 0 5px #ff515c;\n    background-color: #ff515c; }\n  .drop-zone .target.hidden {\n    display: none; }\n  .drop-zone .attachments > * {\n    display: inline-block;\n    margin: 1px;\n    border-radius: 3px;\n    padding: 1px;\n    background-color: #61ff4d; }\n  .drop-zone .attachments .element {\n    display: block; }\n\n.drop-zone:hover .target {\n  background-color: skyblue;\n  cursor: pointer; }\n\n.droplet-active .drop-zone .target b {\n  background-color: #464ae0; }\n\n.droplet-active .drop-zone .target:hover b {\n  box-shadow: 0 0 5px #ff515c;\n  background-color: #ff515c; }\n\n.droplet {\n  height: 35px;\n  text-decoration: none; }\n  .droplet .label {\n    transition: background-color 0.15s cubic-bezier(0.77, 0, 0.175, 1), color 0.15s cubic-bezier(0.77, 0, 0.175, 1), border-color 0.15s cubic-bezier(0.77, 0, 0.175, 1), opacity 0.5s cubic-bezier(0.77, 0, 0.175, 1);\n    display: flex;\n    align-items: center;\n    opacity: 1;\n    border-radius: 3px;\n    border: 1px solid #a0a0a0;\n    border-left-width: 5px;\n    height: 35px;\n    padding: 5px 10px;\n    line-height: 120%;\n    font-size: 14px;\n    font-size: 0.875rem;\n    background-color: #fff;\n    color: #333; }\n    .droplet .label .icon {\n      transition: fill 0.15s cubic-bezier(0.77, 0, 0.175, 1);\n      margin-right: .5em; }\n  .droplet:hover .label,\n  .droplet:active .label,\n  .droplet.active .label {\n    color: #fff;\n    background-color: #a0a0a0; }\n    .droplet:hover .label .icon,\n    .droplet:active .label .icon,\n    .droplet.active .label .icon {\n      fill: #fff; }\n  .droplet.item-dragging .label {\n    opacity: 0.5;\n    box-shadow: -2px 2px rgba(0, 0, 0, 0.3); }\n  .droplet.type-text .label {\n    border-color: #959eff; }\n  .droplet.type-text:hover .label,\n  .droplet.type-text:active .label,\n  .droplet.type-text.active .label {\n    border-color: #464ae0;\n    background-color: #464ae0; }\n  .droplet.type-attribute .label {\n    border-color: #61ff4d; }\n  .droplet.type-attribute:hover .label,\n  .droplet.type-attribute:active .label,\n  .droplet.type-attribute.active .label {\n    border-color: #3b9e2f;\n    background-color: #3b9e2f; }\n  .droplet.type-element .label {\n    border-color: #cc49ff; }\n  .droplet.type-element:hover .label,\n  .droplet.type-element:active .label,\n  .droplet.type-element.active .label {\n    border-color: #8f32b4;\n    background-color: #8f32b4; }\n\n.dialog {\n  position: fixed;\n  display: none;\n  justify-content: center;\n  align-items: center;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  background: #ccc;\n  /* The Fallback */\n  background: rgba(204, 204, 204, 0.7); }\n  .dialog.visible {\n    display: flex; }\n  .dialog .dialog-container {\n    box-shadow: -5px 5px rgba(0, 0, 0, 0.1);\n    max-width: 500px;\n    background-color: #fff; }\n  .dialog .dialog-heading {\n    padding: 20px;\n    border-bottom: 1px solid #ccc; }\n    .dialog .dialog-heading .icon {\n      margin-right: .5em; }\n    .dialog .dialog-heading p:nth-of-type(n+2) {\n      font-size: 14px;\n      font-size: 0.875rem; }\n\nform fieldset:not(.buttons) {\n  padding: 0 20px;\n  margin: 10px 0; }\n\nform fieldset.buttons {\n  content: '';\n  display: table;\n  clear: both;\n  border-top: 1px solid #ccc;\n  padding: 20px; }\n  form fieldset.buttons button {\n    float: right;\n    margin: 0 .25em; }\n    form fieldset.buttons button.pull-left {\n      float: left; }\n\nform legend {\n  font-weight: bolder; }\n\nform .field {\n  display: flex;\n  align-items: center;\n  margin: 10px 0; }\n  form .field label {\n    width: 40%; }\n\ninput,\nbutton,\nselect {\n  font-size: 14px;\n  font-size: 0.875rem;\n  padding: 5px; }\n\nbutton {\n  position: relative;\n  border: 0;\n  padding: 10px 15px;\n  background-color: #ccc; }\n  button:hover, button:focus {\n    left: 2px;\n    top: -2px;\n    cursor: pointer;\n    box-shadow: -2px 2px rgba(0, 0, 0, 0.3);\n    background-color: #d9d9d9; }\n  button:active {\n    left: 0;\n    top: 0;\n    box-shadow: none; }\n  button.primary {\n    background-color: #959eff; }\n    button.primary.primary:hover, button.primary.primary:focus {\n      background-color: #afb5ff; }\n  button.danger {\n    color: #fff;\n    background-color: #ff515c; }\n    button.danger.danger:hover, button.danger.danger:focus {\n      background-color: #ff6b74; }\n\n.icon {\n  fill: #333; }\n\n.drag-handle {\n  position: relative;\n  background-color: #eee;\n  cursor: col-resize; }\n  .drag-handle:after {\n    content: '';\n    transition: all 0.15s cubic-bezier(0.77, 0, 0.175, 1);\n    position: absolute;\n    box-sizing: border-box;\n    left: 50%;\n    top: 50%;\n    margin-top: -25px;\n    margin-left: -4px;\n    width: 8px;\n    height: 50px;\n    border-left: 2px solid #ccc;\n    border-right: 2px solid #ccc; }\n  .drag-handle:hover, .drag-handle.item-dragging {\n    background-color: #f4f4f4; }\n  .drag-handle:hover:after, .drag-handle.item-dragging:after {\n    height: 100px;\n    margin-top: -50px; }\n", ""]);

// exports


/***/ }),

/***/ 148:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap) {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
  var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

  return '/*# ' + data + ' */';
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(145).Buffer))

/***/ }),

/***/ 164:
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ 166:
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ 23:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A single `editable` defiition to produce one field.
 * @typedef EditableItemDefinition
 * @property {string} type - One of 'text', 'longtext', 'dropdown', 'checkbox', or 'radio'.
 * @property {bool} [required] - Whether the field must be filled in or not.
 * @property {mixed} [value] - Either an array of values, or a single string value.
 * @property {string} [placeholder] - In the case of a text value, this will show in place of empty values.
 * @property {string} [selected] - In the case of an array value, this set the value as 'selected'.
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _PropTypes = __webpack_require__(140);

var _PropTypes2 = _interopRequireDefault(_PropTypes);

var _FormField = __webpack_require__(32);

var _FormField2 = _interopRequireDefault(_FormField);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Droplet,
    droplet_id = 0;

/**
 * Individual droplet class. Handles validation of props in a similar fashion to
 * React, but (probably) with a lot less style.
 * @class
 */
Droplet = function Droplet() {
	var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	var id = arguments[1];

	if (typeof id === 'number') {
		this.id = 'droplet_' + id;
	} else {
		this.id = 'droplet_' + ++droplet_id;
	}

	this._originalSettings = Object.deepAssign({}, settings);
	this.data = {};
	this.name = null;
	this.dropletType = null;
	this.attachmentIds = [];

	this.init();
};

Droplet.prototype = {
	/**
  * Initialisation.
  * @private
  */
	init: function init() {
		// set base properties for all droplets
		this._validateAndSet(['name', 'dropletType', 'attachmentIds', 'editable'], this);

		// check droplet type is valid
		switch (this.dropletType) {
			case 'element':
			case 'text':
			case 'attribute':
				this._setExtraFields();
				break;

			default:
				throw new Error('Droplet type ' + this.dropletType + ' is invalid.');
		}
	},

	/**
  * Registers type specific fields for validation.
  * @private
  */
	_setExtraFields: function _setExtraFields() {
		switch (this.dropletType) {
			case 'text':
				this._validateAndSet(['value'], this.data);
				break;

			case 'element':
				this._validateAndSet(['attrs', 'tagName', 'innerHTML'], this.data);
				break;

			case 'attribute':
				this._validateAndSet(['key', 'value'], this.data);
				break;
		}
	},

	/**
  * Validates (using the PropType functions) and sets the instance values
  * given the defined properties.
  */
	_validateAndSet: function _validateAndSet(values, context) {
		var _this = this;

		values.forEach(function (value) {
			if (Droplet.PropTypes.hasOwnProperty(value)) {
				if (Droplet.PropTypes[value](_this._originalSettings[value], value, _this._originalSettings.name || null, _this._originalSettings.dropletType || null)) {
					context[value] = _this._originalSettings[value];
				}
			} else {
				throw new Error('Droplet property "' + value + '" definition does not exist.');
			}
		});
	}
};

/**
 * Designed as a PropType validator much like string, isRequired, arrayOf etc, this
 * function specifically tests the validity of the `editable` prop and its children.
 */
Droplet._validateEditableSet = function (value, prop, droplet_name, droplet_type) {
	var attribute,
	    key,
	    attrkey,
	    prop_error = 'Error in Droplet prop ' + droplet_name + ' (' + prop + '):';

	// allow undefined values
	if (typeof value === 'undefined') {
		return true;
	}

	// testing the droplet value
	if (_PropTypes2.default._assert((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object', prop, 'Value must be an object.', droplet_name, droplet_type)) {
		// continue testing
		for (key in value) {
			// testing individual attributes
			attribute = value[key];

			// attribute is unrecognised or not an object
			if (Droplet.editableAttributes.indexOf(key) === -1 || (typeof attribute === 'undefined' ? 'undefined' : _typeof(attribute)) !== 'object') {
				throw new Error(prop_error + ' "' + key + '" is not an editable attribute or is of the wrong type');
			}

			// attribute is 'attrs', but is not an object of objects
			if (key === 'attrs') {
				for (attrkey in attribute) {
					Droplet._validateEditableItem(attrkey, attribute[attrkey], prop_error);
				}
			} else {
				Droplet._validateEditableItem(key, attribute, prop_error);
			}
		}
	}

	return true;
};

Droplet._validateEditableItem = function (item, data, error_prefix) {
	var error = error_prefix + item + ' - ';

	if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
		throw new Error(error + 'not an EditableItemDefinition object');
	}

	// check "type" exists
	if (typeof data.type === 'undefined') {
		throw new Error(error + 'doesn’t contain ‘type’ value');
	}

	// check "type" is valid
	if (Droplet.editableFieldTypes.indexOf(data.type) === -1) {
		throw new Error(error + 'invalid type attribute "' + data.type + '"');
	}

	// run checks on the editable attributes that match FormField data attributes
	_FormField2.default.validateDataAttribute(data, item, error_prefix);

	return true;
};

/**
 * Defines the possible prop types for Droplets. Some are always required.
 * @prop {string} value - Droplet 'value'. When used as an `attribute` type value, can be
 * set to `null` to define a value-less attribute.
 * @prop {string} name - Droplet name (used as a label).
 * @prop {string[]} attachmentIds - Drop zone attachment IDs.
 * @prop {string} dropletType - Droplet type. One of `element`, `text` or `attribute`.
 * @prop {object} [attrs] - Droplet attributes, in the case of the `element` type.
 * @prop {string} tagname - Droplet tagName attribute, i.e. the actual HTMLElement used.
 * Requred when type is `element`.
 * @prop {string} innerHTML - Droplet's innerHTML.
 * @prop {EditableItemDefinition} editable - Editable properties of `element` types. [add link to tutorial!].
 * @prop {string} key - Attribute keys (names) of `attribute` types.
 */
Droplet.PropTypes = {
	value: _PropTypes2.default.string.isRequired,
	name: _PropTypes2.default.string.notEmpty.isRequired,
	attachmentIds: _PropTypes2.default.arrayOf.string.isRequired,
	dropletType: _PropTypes2.default.string.isRequired,
	attrs: _PropTypes2.default.object,
	tagName: _PropTypes2.default.string.notEmpty.isRequired,
	innerHTML: _PropTypes2.default.string,
	editable: Droplet._validateEditableSet,
	key: _PropTypes2.default.string.notEmpty.isRequired
};

Droplet.editableAttributes = ['value', 'attrs', 'tagName', 'innerHTML'];

Droplet.editableFieldTypes = ['text', 'longtext', 'dropdown', 'checkbox', 'radio'];

exports.default = Droplet;

/***/ }),

/***/ 24:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var registerGeneralEvent = exports.registerGeneralEvent = function registerGeneralEvent(component, id, info) {
	var args = arguments;

	return function (event) {
		event.preventDefault();
		if (typeof component.props.onEvent === 'function') {
			component.props.onEvent.apply(component, [event, info, id].concat(Array.prototype.slice.call(args, 3)));
		}
	}.bind(this);
};

var collectRef = exports.collectRef = function collectRef(props, collection, key) {
	return function (ref) {
		if (typeof props.refCollector === 'function') {
			props.refCollector(collection, ref, key);
		} else {
			throw new Error('ref collection used but no collector has been set up for ' + collection + (key ? '/' + key : ''));
		}
	};
};

/**
 * Returns a function for validating specific keys within an object property.
 */
var validatePropKeys = exports.validatePropKeys = function validatePropKeys(require) {
	return function (props, key, component) {
		var a;

		for (a = 0; a < require.length; a += 1) {
			if (!props[key].hasOwnProperty(require[a]) && props[key][require[a]] !== undefined) {
				return new Error('Prop	`' + key + '` does not contain definition `' + require[a] + '` in ' + component + ' component.');
			}
		}
	};
};

/**
 * Escapes a string for use as a match within a regex
 * @see http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex/6969486#6969486
 */
var escapeRegExp = exports.escapeRegExp = function escapeRegExp(str) {
	return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\$&');
};

/***/ }),

/***/ 275:
/***/ (function(module, exports) {

(function(host) {

  var properties = {
    browser: [
      [/msie ([\.\_\d]+)/, "ie"],
      [/trident\/.*?rv:([\.\_\d]+)/, "ie"],
      [/firefox\/([\.\_\d]+)/, "firefox"],
      [/chrome\/([\.\_\d]+)/, "chrome"],
      [/version\/([\.\_\d]+).*?safari/, "safari"],
      [/mobile safari ([\.\_\d]+)/, "safari"],
      [/android.*?version\/([\.\_\d]+).*?safari/, "com.android.browser"],
      [/crios\/([\.\_\d]+).*?safari/, "chrome"],
      [/opera/, "opera"],
      [/opera\/([\.\_\d]+)/, "opera"],
      [/opera ([\.\_\d]+)/, "opera"],
      [/opera mini.*?version\/([\.\_\d]+)/, "opera.mini"],
      [/opios\/([a-z\.\_\d]+)/, "opera"],
      [/blackberry/, "blackberry"],
      [/blackberry.*?version\/([\.\_\d]+)/, "blackberry"],
      [/bb\d+.*?version\/([\.\_\d]+)/, "blackberry"],
      [/rim.*?version\/([\.\_\d]+)/, "blackberry"],
      [/iceweasel\/([\.\_\d]+)/, "iceweasel"],
      [/edge\/([\.\d]+)/, "edge"]
    ],
    os: [
      [/linux ()([a-z\.\_\d]+)/, "linux"],
      [/mac os x/, "macos"],
      [/mac os x.*?([\.\_\d]+)/, "macos"],
      [/os ([\.\_\d]+) like mac os/, "ios"],
      [/openbsd ()([a-z\.\_\d]+)/, "openbsd"],
      [/android/, "android"],
      [/android ([a-z\.\_\d]+);/, "android"],
      [/mozilla\/[a-z\.\_\d]+ \((?:mobile)|(?:tablet)/, "firefoxos"],
      [/windows\s*(?:nt)?\s*([\.\_\d]+)/, "windows"],
      [/windows phone.*?([\.\_\d]+)/, "windows.phone"],
      [/windows mobile/, "windows.mobile"],
      [/blackberry/, "blackberryos"],
      [/bb\d+/, "blackberryos"],
      [/rim.*?os\s*([\.\_\d]+)/, "blackberryos"]
    ],
    device: [
      [/ipad/, "ipad"],
      [/iphone/, "iphone"],
      [/lumia/, "lumia"],
      [/htc/, "htc"],
      [/nexus/, "nexus"],
      [/galaxy nexus/, "galaxy.nexus"],
      [/nokia/, "nokia"],
      [/ gt\-/, "galaxy"],
      [/ sm\-/, "galaxy"],
      [/xbox/, "xbox"],
      [/(?:bb\d+)|(?:blackberry)|(?: rim )/, "blackberry"]
    ]
  };

  var UNKNOWN = "Unknown";

  var propertyNames = Object.keys(properties);

  function Sniffr() {
    var self = this;

    propertyNames.forEach(function(propertyName) {
      self[propertyName] = {
        name: UNKNOWN,
        version: [],
        versionString: UNKNOWN
      };
    });
  }

  function determineProperty(self, propertyName, userAgent) {
    properties[propertyName].forEach(function(propertyMatcher) {
      var propertyRegex = propertyMatcher[0];
      var propertyValue = propertyMatcher[1];

      var match = userAgent.match(propertyRegex);

      if (match) {
        self[propertyName].name = propertyValue;

        if (match[2]) {
          self[propertyName].versionString = match[2];
          self[propertyName].version = [];
        } else if (match[1]) {
          self[propertyName].versionString = match[1].replace(/_/g, ".");
          self[propertyName].version = parseVersion(match[1]);
        } else {
          self[propertyName].versionString = UNKNOWN;
          self[propertyName].version = [];
        }
      }
    });
  }

  function parseVersion(versionString) {
    return versionString.split(/[\._]/).map(function(versionPart) {
      return parseInt(versionPart);
    });
  }

  Sniffr.prototype.sniff = function(userAgentString) {
    var self = this;
    var userAgent = (userAgentString || navigator.userAgent || "").toLowerCase();

    propertyNames.forEach(function(propertyName) {
      determineProperty(self, propertyName, userAgent);
    });
  };


  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Sniffr;
  } else {
    host.Sniffr = new Sniffr();
    host.Sniffr.sniff(navigator.userAgent);
  }
})(this);


/***/ }),

/***/ 276:
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
	}),
	getHeadElement = memoize(function () {
		return document.head || document.getElementsByTagName("head")[0];
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [],
	fixUrls = __webpack_require__(277);

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the bottom of <head>.
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var head = getHeadElement();
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			head.insertBefore(styleElement, head.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			head.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		head.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	options.attrs.type = "text/css";

	attachTagAttrs(styleElement, options.attrs);
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	attachTagAttrs(linkElement, options.attrs);
	insertStyleElement(options, linkElement);
	return linkElement;
}

function attachTagAttrs(element, attrs) {
	Object.keys(attrs).forEach(function (key) {
		element.setAttribute(key, attrs[key]);
	});
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement, options);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls){
		css = fixUrls(css);
	}

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ 277:
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	var fixedCss = css.replace(/url *\( *(.+?) *\)/g, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ 278:
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(147);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(276)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../css-loader/index.js!../../../sass-loader/lib/loader.js!./main.scss", function() {
			var newContent = require("!!../../../css-loader/index.js!../../../sass-loader/lib/loader.js!./main.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ 284:
/***/ (function(module, exports, __webpack_require__) {


var sprite = __webpack_require__(68);
var image = "<symbol viewBox=\"0 0 8 8\" id=\"icon-puzzle-piece\" > <path d=\"M3 0c-.28 0-.54.1-.72.28-.18.18-.28.44-.28.72 0 .28.18.48.28.72.03.06.03.16.03.28h-2.31v6h2.31c0-.12-.01-.22-.03-.28-.1-.24-.28-.44-.28-.72 0-.28.1-.54.28-.72.18-.18.44-.28.72-.28.28 0 .54.1.72.28.18.18.28.44.28.72 0 .28-.18.48-.28.72-.03.06-.03.16-.03.28h2.31v-2.31c.12 0 .22.01.28.03.24.1.44.28.72.28.28 0 .54-.1.72-.28.18-.18.28-.44.28-.72 0-.28-.1-.54-.28-.72-.18-.18-.44-.28-.72-.28-.28 0-.48.18-.72.28-.06.03-.16.03-.28.03v-2.31h-2.31c0-.12.01-.22.03-.28.1-.24.28-.44.28-.72 0-.28-.1-.54-.28-.72-.18-.18-.44-.28-.72-.28z\"/> </symbol>";
module.exports = sprite.add(image, "icon-puzzle-piece");

/***/ }),

/***/ 285:
/***/ (function(module, exports, __webpack_require__) {


var sprite = __webpack_require__(68);
var image = "<symbol viewBox=\"0 0 8 8\" id=\"icon-tag\" > <path d=\"M0 0v3l5 5 3-3-5-5h-3zm2 1c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1z\"/> </symbol>";
module.exports = sprite.add(image, "icon-tag");

/***/ }),

/***/ 286:
/***/ (function(module, exports, __webpack_require__) {


var sprite = __webpack_require__(68);
var image = "<symbol viewBox=\"0 0 8 8\" id=\"icon-text\" > <path d=\"M0 0v2h.5c0-.55.45-1 1-1h1.5v5.5c0 .28-.22.5-.5.5h-.5v1h4v-1h-.5c-.28 0-.5-.22-.5-.5v-5.5h1.5c.55 0 1 .45 1 1h.5v-2h-8z\"/> </symbol>";
module.exports = sprite.add(image, "icon-text");

/***/ }),

/***/ 287:
/***/ (function(module, exports, __webpack_require__) {

var Sniffr = __webpack_require__(275);

/**
 * List of SVG attributes to fix url target in them
 * @type {string[]}
 */
var fixAttributes = [
  'clipPath',
  'colorProfile',
  'src',
  'cursor',
  'fill',
  'filter',
  'marker',
  'markerStart',
  'markerMid',
  'markerEnd',
  'mask',
  'stroke'
];

/**
 * Query to find'em
 * @type {string}
 */
var fixAttributesQuery = '[' + fixAttributes.join('],[') + ']';
/**
 * @type {RegExp}
 */
var URI_FUNC_REGEX = /^url\((.*)\)$/;

/**
 * Convert array-like to array
 * @param {Object} arrayLike
 * @returns {Array.<*>}
 */
function arrayFrom(arrayLike) {
  return Array.prototype.slice.call(arrayLike, 0);
}

/**
 * Handles forbidden symbols which cannot be directly used inside attributes with url(...) content.
 * Adds leading slash for the brackets
 * @param {string} url
 * @return {string} encoded url
 */
function encodeUrlForEmbedding(url) {
  return url.replace(/\(|\)/g, "\\$&");
}

/**
 * Replaces prefix in `url()` functions
 * @param {Element} svg
 * @param {string} currentUrlPrefix
 * @param {string} newUrlPrefix
 */
function baseUrlWorkAround(svg, currentUrlPrefix, newUrlPrefix) {
  var nodes = svg.querySelectorAll(fixAttributesQuery);

  if (!nodes) {
    return;
  }

  arrayFrom(nodes).forEach(function (node) {
    if (!node.attributes) {
      return;
    }

    arrayFrom(node.attributes).forEach(function (attribute) {
      var attributeName = attribute.localName.toLowerCase();

      if (fixAttributes.indexOf(attributeName) !== -1) {
        var match = URI_FUNC_REGEX.exec(node.getAttribute(attributeName));

        // Do not touch urls with unexpected prefix
        if (match && match[1].indexOf(currentUrlPrefix) === 0) {
          var referenceUrl = encodeUrlForEmbedding(newUrlPrefix + match[1].split(currentUrlPrefix)[1]);
          node.setAttribute(attributeName, 'url(' + referenceUrl + ')');
        }
      }
    });
  });
}

/**
 * Because of Firefox bug #353575 gradients and patterns don't work if they are within a symbol.
 * To workaround this we move the gradient definition outside the symbol element
 * @see https://bugzilla.mozilla.org/show_bug.cgi?id=353575
 * @param {Element} svg
 */
var FirefoxSymbolBugWorkaround = function (svg) {
  var defs = svg.querySelector('defs');

  var moveToDefsElems = svg.querySelectorAll('symbol linearGradient, symbol radialGradient, symbol pattern');
  for (var i = 0, len = moveToDefsElems.length; i < len; i++) {
    defs.appendChild(moveToDefsElems[i]);
  }
};

/**
 * Fix for browser (IE, maybe other too) which are throwing 'WrongDocumentError'
 * if you insert an element which is not part of the document
 * @see http://stackoverflow.com/questions/7981100/how-do-i-dynamically-insert-an-svg-image-into-html#7986519
 * @param {Element} svg
 */
function importSvg(svg) {
  try {
    if (document.importNode) {
      return document.importNode(svg, true);
    }
  } catch(e) {}

  return svg;
}

/**
 * @type {string}
 */
var DEFAULT_URI_PREFIX = '#';

/**
 * @type {string}
 */
var xLinkHref = 'xlink:href';
/**
 * @type {string}
 */
var xLinkNS = 'http://www.w3.org/1999/xlink';
/**
 * @type {string}
 */
var svgOpening = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="' + xLinkNS + '"';
/**
 * @type {string}
 */
var svgClosing = '</svg>';
/**
 * @type {string}
 */
var contentPlaceHolder = '{content}';

/**
 * Representation of SVG sprite
 * @constructor
 */
function Sprite() {
  var baseElement = document.getElementsByTagName('base')[0];
  var currentUrl = window.location.href.split('#')[0];
  var baseUrl = baseElement && baseElement.href;
  this.urlPrefix = baseUrl && baseUrl !== currentUrl ? currentUrl + DEFAULT_URI_PREFIX : DEFAULT_URI_PREFIX;

  var sniffr = new Sniffr();
  sniffr.sniff();
  this.browser = sniffr.browser;
  this.content = [];

  if (this.browser.name !== 'ie' && baseUrl) {
    window.addEventListener('spriteLoaderLocationUpdated', function (e) {
      var currentPrefix = this.urlPrefix;
      var newUrlPrefix = e.detail.newUrl.split(DEFAULT_URI_PREFIX)[0] + DEFAULT_URI_PREFIX;
      baseUrlWorkAround(this.svg, currentPrefix, newUrlPrefix);
      this.urlPrefix = newUrlPrefix;

      if (this.browser.name === 'firefox' || this.browser.name === 'edge' || this.browser.name === 'chrome' && this.browser.version[0] >= 49) {
        var nodes = arrayFrom(document.querySelectorAll('use[*|href]'));
        nodes.forEach(function (node) {
          var href = node.getAttribute(xLinkHref);
          if (href && href.indexOf(currentPrefix) === 0) {
            node.setAttributeNS(xLinkNS, xLinkHref, newUrlPrefix + href.split(DEFAULT_URI_PREFIX)[1]);
          }
        });
      }
    }.bind(this));
  }
}

Sprite.styles = ['position:absolute', 'width:0', 'height:0'];

Sprite.spriteTemplate = function(){ return svgOpening + ' style="'+ Sprite.styles.join(';') +'"><defs>' + contentPlaceHolder + '</defs>' + svgClosing; }
Sprite.symbolTemplate = function() { return svgOpening + '>' + contentPlaceHolder + svgClosing; }

/**
 * @type {Array<String>}
 */
Sprite.prototype.content = null;

/**
 * @param {String} content
 * @param {String} id
 */
Sprite.prototype.add = function (content, id) {
  if (this.svg) {
    this.appendSymbol(content);
  }

  this.content.push(content);

  return DEFAULT_URI_PREFIX + id;
};

/**
 *
 * @param content
 * @param template
 * @returns {Element}
 */
Sprite.prototype.wrapSVG = function (content, template) {
  var svgString = template.replace(contentPlaceHolder, content);

  var svg = new DOMParser().parseFromString(svgString, 'image/svg+xml').documentElement;
  var importedSvg = importSvg(svg);

  if (this.browser.name !== 'ie' && this.urlPrefix) {
    baseUrlWorkAround(importedSvg, DEFAULT_URI_PREFIX, this.urlPrefix);
  }

  return importedSvg;
};

Sprite.prototype.appendSymbol = function (content) {
  var symbol = this.wrapSVG(content, Sprite.symbolTemplate()).childNodes[0];

  this.svg.querySelector('defs').appendChild(symbol);
  if (this.browser.name === 'firefox') {
    FirefoxSymbolBugWorkaround(this.svg);
  }
};

/**
 * @returns {String}
 */
Sprite.prototype.toString = function () {
  var wrapper = document.createElement('div');
  wrapper.appendChild(this.render());
  return wrapper.innerHTML;
};

/**
 * @param {HTMLElement} [target]
 * @param {Boolean} [prepend=true]
 * @returns {HTMLElement} Rendered sprite node
 */
Sprite.prototype.render = function (target, prepend) {
  target = target || null;
  prepend = typeof prepend === 'boolean' ? prepend : true;

  var svg = this.wrapSVG(this.content.join(''), Sprite.spriteTemplate());

  if (this.browser.name === 'firefox') {
    FirefoxSymbolBugWorkaround(svg);
  }

  if (target) {
    if (prepend && target.childNodes[0]) {
      target.insertBefore(svg, target.childNodes[0]);
    } else {
      target.appendChild(svg);
    }
  }

  this.svg = svg;

  return svg;
};

module.exports = Sprite;


/***/ }),

/***/ 292:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// require.ensure([], () => {
var App = __webpack_require__(113).default;

var app = new App({
	onElementRender: function onElementRender(markup, droplet, zone, is_output) {
		if (droplet.name === 'Letter button' && is_output) {
			markup.innerHTML = '<span>' + markup.innerHTML + '</span>';
		}

		return markup;
	}
});

app.load('templates/default.html', 'templates/pallet.json').catch(function (error) {
	console.error(error);
});
// }, 'app');

/***/ }),

/***/ 32:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * FormField data object
 * @typedef FormFieldData
 * @property {boolean} [required]
 * @property {string} [label]
 * @property {mixed} [options]
 * @property {string} [placeholder]
 * @property {mixed} [value]
 * @example
 * var field = FormField('fieldname', 'dropdown', {
 * 	'label': 'Please select a value',
 * 	'options': ['Value 1', 'Value 2', 'Value 3'],
 * 	'value': 'Value 2'
 * });
 */

/**
* This class exists almost entirely for data consistency.
* @class
* @param {string} name - Field name.
* @param {string} type - Input type.
* @param {FormFieldData} data - Field data.
*/
var FormField = function FormField(name, type) {
	var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	this._setNameAndType(name, type);
	this._validateAndSet(data);
};

FormField.prototype = {
	_setNameAndType: function _setNameAndType(name, type) {
		if (typeof name !== 'string') {
			throw new Error('Invalid field name "' + name + '"');
		} else {
			this.name = name;
		}

		if (typeof type !== 'string' || FormField.validTypes.indexOf(type) === -1) {
			throw new Error('Invalid field type "' + type + '"');
		} else {
			this.type = type;
		}
	},

	_validateAndSet: function _validateAndSet(data) {
		var _data = Object.deepAssign({}, data);

		if (FormField.validateDataAttribute(_data, this.name, 'Error with FormField data attribute')) {
			this.data = _data;

			// externalise remaining options
			this.required = data.required;
			this.options = data.options;
			this.placeholder = data.placeholder;
			this.label = data.label;

			this.value = typeof data.value !== 'undefined' ? data.value : '';
		}
	}
};

/**
 * Ensures a form field's data attributes are valid
 */
FormField.validateDataAttribute = function (data, item, error_prefix) {
	var error = error_prefix + ' ' + item + ' - ';

	// check "required" is a boolean, if defined
	if (typeof data.required !== 'undefined' && typeof data.required !== 'boolean') {
		throw new Error(error + '"required" attribute isn’t a boolean true or false');
	}

	// check "options" is valid
	if (typeof data.options !== 'undefined') {
		FormField._validateOptionsSetting(data.options, error);
	}

	// check "placeholder" is valid
	if (typeof data.placeholder !== 'undefined' && typeof data.placeholder !== 'string') {
		throw new Error(error + '"placeholder" attribute isn’t a string');
	}

	// check "value" is valid
	if (typeof data.value !== 'undefined') {
		FormField._validateValueSetting(data.value, data.options, error);
	}

	// check "label" is valid
	if (typeof data.label !== 'undefined' && typeof data.label !== 'string') {
		throw new Error(error + '"label" attribute isn’t a string');
	}

	// check "maxlength" is valid
	if (typeof data.maxlength !== 'undefined' && (typeof data.maxlength !== 'number' || data.maxlength < 1)) {
		throw new Error(error + '"maxlength" attribute isn’t a number or above zero');
	}

	return true;
};

FormField._validateOptionsSetting = function (options, error_prefix) {
	var key,
	    a,
	    error = error_prefix + '"options" is of an unrecognised type';

	if (Array.isArray(options)) {
		for (a = 0; a < options.length; a += 1) {
			if (typeof options[a] !== 'string') {
				throw new Error(error);
			}
		}
	} else if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && options !== null) {
		for (key in options) {
			if (typeof key !== 'string' || typeof options[key] !== 'string') {
				throw new Error(error + ' - object values must be a simple key/value set');
			}
		}
	} else if (options === null) {
		throw new Error(error + ' - options cannot be null');
	}

	return true;
};

FormField._validateValueSetting = function (value, options, error_prefix) {
	if (!Array.isArray(value) && typeof value !== 'string' && typeof value !== 'number') {
		throw new Error(error_prefix + '"value" is of an unrecognised type');
	}

	if (typeof options !== 'undefined') {
		// validate against options
		if (Array.isArray(options) && options.indexOf(value) === -1 || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && !Array.isArray(options) && !options[value]) {
			throw new Error(error_prefix + '"value" attribute contains an option that doesn’t exist');
		}
	}
};

FormField.validTypes = ['text', 'longtext', 'dropdown', 'checkbox', 'radio'];

exports.default = FormField;

/***/ }),

/***/ 40:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.GLYPHS = undefined;
exports.Icon = Icon;

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GLYPHS = exports.GLYPHS = {
	TEXT: __webpack_require__(286),
	PUZZLE_PIECE: __webpack_require__(284),
	TAG: __webpack_require__(285)
};

function Icon(props) {
	return _react2.default.createElement(
		'svg',
		{ className: 'icon', width: props.width, height: props.height },
		_react2.default.createElement('use', { xlinkHref: props.glyph })
	);
}

Icon.defaultProps = {
	width: 16,
	height: 16
};

Icon.propTypes = {
	width: _react.PropTypes.number,
	height: _react.PropTypes.number,
	glyph: _react.PropTypes.string
};

/***/ }),

/***/ 41:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var localStorage = window.localStorage,
    JSON = JSON || window.JSON;

/**
 * from https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API
 */
var checkStorage = function checkStorage(type) {
	try {
		var storage = window[type],
		    x = '__tag_storage_test__';
		storage.setItem(x, x);
		storage.removeItem(x);
		return true;
	} catch (e) {
		return false;
	}
};

var Communicator = function Communicator(id, origin) {
	var callbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	if (!checkStorage('localStorage')) {
		return false;
	}

	if (typeof id !== 'string') {
		throw new Error('Please choose a string-based ID for the guest.');
	}

	if (typeof origin !== 'string') {
		throw new Error('Please choose a string-based origin address.');
	}

	this._settings = {
		name: 'tag-comm-data'
	};

	this._guests = {};
	this._queue = {};
	this.id = id;

	this._origin = origin;
	this._callbacks = Object.assign({
		message: null
	}, callbacks);

	window.addEventListener('message', this._receiveMessage.bind(this), false);

	this._sendPing();
};

Communicator.prototype = {
	/**
  * Attempt to ping source window
  */
	_sendPing: function _sendPing(node) {
		var ping = this._createMessage(null, {
			ping: this.id
		});

		if (!node) {
			if (window.opener) {
				node = window.opener;
			} else if (window.top !== window) {
				node = window.top;
			}
		}

		if (node) {
			// console.log(this.id + ' >> ping!');
			this._post(node, ping);
		}
	},

	_sendPong: function _sendPong(node) {
		var pong = this._createMessage(null, {
			pong: this.id
		});

		// console.log('pong! << ' + this.id);
		this._post(node, pong);
	},

	/**
  * Registers a single guest for communication purposes.
  * @param {string} id - Guest ID. Used when sending messages.
  * @param {mixed} dest - Destination node.
  */
	registerGuestAddress: function registerGuestAddress(id, dest) {
		if (typeof dest === 'undefined') {
			throw new Error('Cannot register address for ' + id + '. ' + 'A guest address DOM node, window or frame must be defined.');
		}

		if (!('postMessage' in dest)) {
			throw new Error('Communicator cannot send messages to destination. Please choose an HTMLElement ' + 'that supports the postMessage method');
		}

		if (typeof id !== 'string') {
			throw new Error('Please choose a string-based ID for the guest.');
		}

		// register local address for guest
		this._setGuestData(id, {
			id: id,
			node: dest
		});

		// start timer
		if (this.timer) {
			window.clearInterval(this.timer);
		}
	},

	/**
  * Sets or replaces the guest data.
  * @param {string} id - Guest ID.
  * @param {object} data - Guest data.
  * @private
  */
	_setGuestData: function _setGuestData(id, data) {
		if (!this._guests[id]) {
			this._guests[id] = {
				live: false,
				node: null
			};
		}

		Object.assign(this._guests[id], data);
	},

	/**
  * Sends a message to the defined guest.
  * @param {string} to - Guest ID, as stored.
  * @param {mixed} message - Any JS compatible data to send as a message.
  */
	send: function send(to, message) {
		var guest = this._getGuestById(to);

		if (guest && guest.live) {
			// post message immediately
			this._post(to, this._createMessage(message));
		} else {
			// queue message for posting
			this._addToQueue(to, message);
		}
	},

	/**
  * Adds a message to the local 'outbox' for the guest (by ID).
  */
	_addToQueue: function _addToQueue(to, message) {
		if (!this._queue[to]) {
			this._queue[to] = [];
		}

		this._queue[to].push(message);
	},

	_sendQueue: function _sendQueue(to) {
		var a;

		if (this._queue[to] && this._guests[to]) {
			// send messages in the order they were queued
			for (a = 0; a < this._queue[to].length; a += 1) {
				this._post(this._guests[to].node, this._createMessage(this._queue[to][a]));
			}

			// clear queue for this recipient
			this._queue[to] = [];
		}
	},

	/**
  * Gets a communicator guest by its ID, or returns `null`.
  * @returns {mixed} Guest data, or `null`.
  * @private
  */
	_getGuestById: function _getGuestById(id) {
		return this._guests[id] || null;
	},

	/**
  * Get a guest by known node (i.e. that registered in `this._guests`)
  * @private
  */
	_getGuestByNode: function _getGuestByNode(node) {
		var id;

		// console.group('_getGuestByNode');
		// console.log('finding', node);

		for (id in this._guests) {
			// console.log(id, this._guests[id], (this._guests[id].node === node));
			if (this._guests.hasOwnProperty(id) && this._guests[id].node === node) {
				// console.log('node found!', id);
				return this._getGuestById(id);
			}
		}
		// console.groupEnd();

		return null;
	},

	/**
  * Actually posts the message to the destination.
  * @param {string} to - Guest ID.
  * @param {mixed} message - Any JS compatible data to send as a message.
  * @private
  */
	_post: function _post(to, message) {
		var guest, node;

		if (typeof to === 'string') {
			guest = this._getGuestById(to);

			if (!guest.node) {
				throw new Error('Cannot communicate with guest "' + to + '". Has its Node address been registered?');
			}

			node = guest.node;
		} else {
			node = to;
		}

		node.postMessage(message, this._origin);
	},

	/**
  * Invoked when a live message is received.
  * @private
  */
	_receiveMessage: function _receiveMessage(event) {
		var origin = event.origin || event.originalEvent.origin,
		    source = event.source || event.originalEvent.source,
		    message = event.data,
		    guest;

		// console.group('_receiveMessage');
		// console.log('to "' + this.id + '":', event.data);
		if (origin !== location.origin) return;

		if ((message.ping || message.pong) && this._getGuestByNode(source)) {
			// received a ping/pong from valid source
			guest = message.ping || message.pong;
			// console.log(this.id, 'setting guest "', guest, '" live');
			this._setGuestLive(guest);
			this._sendQueue(guest);

			if (message.ping) {
				// pong back a ping (don't pong a pong or we'll be here forever)
				this._sendPong(source);
			}
		}

		if (this._callbacks.message && message.originalMessage) {
			this._callbacks.message(message.originalMessage);
		}

		// console.groupEnd();
	},

	_setGuestLive: function _setGuestLive(id) {
		this._setGuestData(id, {
			live: true
		});
	},

	_createMessage: function _createMessage(message, data) {
		return Object.assign({}, data, {
			host: this.id,
			originalMessage: message
		});
	}
};

exports.default = Communicator;

/***/ }),

/***/ 42:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Droplet = __webpack_require__(23);

var _Droplet2 = _interopRequireDefault(_Droplet);

var _constants = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DropZone,
    drop_zone_id = 0;

/**
 * @class
 */
DropZone = function DropZone() {
	var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	var tag = arguments[1];

	this.tag = tag;
	this.id = 'drop_zone_' + ++drop_zone_id;
	this.attachmentId = data.attachmentId;
	this.maxAttachments = typeof data.maxAttachments !== 'undefined' ? data.maxAttachments : 1;
};

DropZone.prototype = {
	/**
  * Test if the DropZone instance will accept a new droplet. The test looks at the
  * maximum number of attachments and attachment eligibility based on attachmentId
  */
	willAccept: function willAccept(droplet, store) {
		var current_attachments = 0,
		    state;

		if (!(droplet instanceof _Droplet2.default)) {
			throw new Error(_constants.errorCodes.NOT_A_DROPLET);
		}

		if (store) {
			// store exists - get state (and current number of attachments)
			state = store.getState();

			if (state.zones[this.id] && state.zones[this.id].attachments) {
				current_attachments = state.zones[this.id].attachments.length;
			}
		}

		// test attachment count
		if (this.maxAttachments !== 0 && current_attachments === this.maxAttachments) {
			return false;
		}

		// test attachmentId eligibility
		if (this.attachmentId !== '*' && droplet.attachmentIds.indexOf(this.attachmentId) === -1) {
			return false;
		}

		return true;
	}
};

/**
 * Matches a drop zone within the supplied markup.
 * Can be used more than once on the same markup, and will internally increment through the data.
 */
DropZone.fetchZone = function (markup) {
	var match, zone;

	// keep looking for a valid drop zone - report on the bad ones
	while ((match = DropZone._re_zones.exec(markup)) !== null) {
		if (match !== null && (zone = DropZone.checkSyntax(match[0]))) {
			// return it
			return new DropZone({
				attachmentId: zone.attachmentId,
				maxAttachments: zone.maxAttachments
			}, match[0]);
		}
	}

	return null;
};

/**
 * Checks and reports on syntax errors within a supplied tag.
 */
DropZone.checkSyntax = function (tag) {
	var d;

	if ((d = tag.match(DropZone.syntax_re.re_structure)) !== null && d[1] !== null) {
		// check id portion
		if (!d[2] || !DropZone.syntax_re.re_id.test(d[2])) {
			return DropZone.snytaxFault(d[1], 'Invalid syntax. ID must either start with a letter and only contain' + ' letters, numbers, and the undescore (_) character, or be an asterisk (*) ' + 'to specify any attachment ID.', d[2]);
		}

		// check quantity portion
		if (d[4] && (!DropZone.syntax_re.re_qty.test(d[4]) || d[4] < 1 || d[4] > 100)) {
			return DropZone.snytaxFault(d[1], 'Invalid syntax. Quantity must be a valid number and between 1 and 100, ' + 'or the asterisk (*) character to specify unlimited up to the internal maximum.', d[4]);
		}
	} else {
		return DropZone.snytaxFault(tag, 'Invalid syntax.');
	}

	return {
		attachmentId: d[2],
		maxAttachments: d[4] === '*' ? 0 : parseFloat(d[4]) || 1
	};
};

DropZone.snytaxFault = function (str, message, char) {
	var error;

	if (char) {
		// escape % symbols
		str = str.replace('%', '%%');
		char = char.replace('%', '%%');

		// add colouring
		str = str.replace(char, '%c$&%c');

		error = 'Error with syntax in tag "' + str + '": ' + message;
		console.warn(error, 'color: red;', 'color: inherit;');
	} else {
		// basic error with no colouring
		error = 'Error with syntax in tag "' + str + '": ' + message;
		console.warn(error);
	}

	return false;
};

/**
 * Discriminating regex collection for testing drop zones with explicit syntax.
 */
DropZone.syntax_re = {
	re_structure: /^\{\{\s?(([^|\s]+)(\|([^|\s]*))?)\s?\}\}$/,
	re_id: /^[a-z*][a-z0-9_]*$/i,
	re_qty: /^[0-9*]+$/
};

/**
 * Inclusive regex for capturing individual zones with basic syntax
 */
DropZone._re_zones = /\{\{\s?(.+?)(\|(.*?))?\s?\}\}/gi;

exports.default = DropZone;

/***/ }),

/***/ 43:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _constants = __webpack_require__(9);

exports.default = {
	setUIState: function setUIState(ui_state) {
		return {
			type: _constants.actionTypes.UI_STATE,
			ui_state: ui_state
		};
	},

	setActiveDroplet: function setActiveDroplet(droplet_id) {
		return {
			type: _constants.actionTypes.SET_ACTIVE_DROPLET,
			droplet_id: droplet_id
		};
	},

	setDialogMode: function setDialogMode(mode) {
		var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		return {
			type: _constants.actionTypes.SET_DIALOG_MODE,
			mode: mode,
			state: state
		};
	},

	zoneAddAttachment: function zoneAddAttachment(id, droplet_id, attached, data) {
		return {
			type: _constants.actionTypes.ZONE_ADD_ATTACHMENT,
			id: id,
			droplet_id: droplet_id,
			attached: attached,
			data: data
		};
	},

	zoneEditAttachment: function zoneEditAttachment(id, attachment_index, data) {
		return {
			type: _constants.actionTypes.ZONE_EDIT_ATTACHMENT,
			id: id,
			attachment_index: attachment_index,
			data: data
		};
	},

	zoneDetachAttachment: function zoneDetachAttachment(id, attachment_index) {
		return {
			type: _constants.actionTypes.ZONE_DETACH_ATTACHMENT,
			id: id,
			attachment_index: attachment_index
		};
	}
};

/***/ }),

/***/ 68:
/***/ (function(module, exports, __webpack_require__) {

var Sprite = __webpack_require__(287);
var globalSprite = new Sprite();

if (document.body) {
  globalSprite.elem = globalSprite.render(document.body);
} else {
  document.addEventListener('DOMContentLoaded', function () {
    globalSprite.elem = globalSprite.render(document.body);
  }, false);
}

module.exports = globalSprite;


/***/ }),

/***/ 75:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.field = undefined;

var _react = __webpack_require__(3);

var _FormField = __webpack_require__(32);

var _FormField2 = _interopRequireDefault(_FormField);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var field = exports.field = {
	field: _react.PropTypes.instanceOf(_FormField2.default).isRequired,
	value: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number, _react.PropTypes.arrayOf(_react.PropTypes.string)]).isRequired,
	onChange: _react.PropTypes.func
};

/***/ }),

/***/ 76:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _ajax = __webpack_require__(77);

var _ajax2 = _interopRequireDefault(_ajax);

var _DropZone = __webpack_require__(42);

var _DropZone2 = _interopRequireDefault(_DropZone);

var _Droplet = __webpack_require__(23);

var _Droplet2 = _interopRequireDefault(_Droplet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Template = function Template(parent) {
	var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	this._parent = parent;
	this.settings = settings;
	this._drop_zones = {};
	this._template = [];
	this._max_zones = 100;
};

Template.prototype = {
	load: function load(url) {
		var _this = this;

		return _ajax2.default.get(url).then(function (response) {
			if (response.text) {
				_this._markup = response.text;
			}
		}).catch(function (error) {
			throw new Error(error);
		});
	},

	create: function create() {
		var markup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._markup;

		if (typeof markup === 'undefined') {
			throw new Error('Cannot call create() with no markup defined.');
		}

		// replace html with entities
		markup = Template.entities(markup);

		return this._createDropZones(markup);
	},

	_createDropZones: function _createDropZones(markup) {
		var zone,
		    counter = 0;

		// loop through markup finding drop zones
		while ((zone = _DropZone2.default.fetchZone(markup)) !== null) {
			this._drop_zones[zone.id] = zone;
			counter += 1;

			if (counter === this._max_zones) {
				throw new Error('Maximum number of zones in template reached (' + this._max_zones + ').');
			}
		}

		// loop through collected drop zones and replace tags in markup
		for (zone in this._drop_zones) {
			markup = markup.replace(this._drop_zones[zone].tag, '<span' + ' data-id="' + this._drop_zones[zone].id + '"' + ' data-attachment="' + this._drop_zones[zone].attachmentId + '">' + '</span>');
		}

		this._template = this._createTemplateArray(markup);

		return {
			drop_zones: this._drop_zones,
			template: this._template
		};
	},

	_createTemplateArray: function _createTemplateArray(markup) {
		var _this2 = this;

		var sandbox = document.createElement('div'),
		    data = [];
		sandbox.innerHTML = markup;

		sandbox.childNodes.forEach(function (node) {
			switch (node.nodeType) {
				case Node.TEXT_NODE:
					data.push({
						type: 'text',
						content: node.textContent
					});
					break;

				case Node.ELEMENT_NODE:
					data.push({
						type: 'dropzone',
						zone: _this2._drop_zones[node.dataset.id]
					});
					break;
			}
		});

		return data;
	},

	renderAsHTML: function renderAsHTML(zones) {
		var _this3 = this;

		var html = '';

		this._template.forEach(function (node) {
			if (node.type === 'text') {
				// plain text node
				html += node.content;
			} else if (node.type === 'dropzone' && zones[node.zone.id]) {
				// drop zone with attachments
				zones[node.zone.id].attachments.forEach(function (attachment) {
					var droplet = _this3._parent._UI.getDropletById(attachment.droplet_id),
					    data = Object.deepAssign({}, droplet.data, attachment.data);

					html += Template.renderDroplet(droplet, data, _this3._parent._UI.getDropZoneById(node.zone.id), _this3.settings.onElementRender);
				});
			}
		});

		return html;
	}
};

Template.renderDroplet = function (droplet, data, drop_zone) {
	var is_output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

	var output;

	if (!(droplet instanceof _Droplet2.default)) {
		throw new Error('droplet argument must be a Droplet instance');
	}

	switch (droplet.dropletType) {
		case 'element':
			output = Template.renderElementDroplet(data, droplet, drop_zone, is_output);
			break;

		case 'text':
			output = Template.renderTextDroplet(data, droplet, drop_zone, is_output);
			break;

		case 'attribute':
			output = Template.renderAttributeDroplet(data, droplet, drop_zone, is_output);
			break;
	}

	return output;
};

Template.renderElementDroplet = function (data, droplet, drop_zone, is_output) {
	// !TODO - make sure self-closing tags are correctly rendered
	var attrs = [],
	    markup = {},
	    attr;

	markup.open = '<' + data.tagName;

	if (data.attrs) {
		for (attr in data.attrs) {
			attrs.push(attr += '="' + Template.entities(data.attrs[attr]) + '"');
		}

		if (attrs.length) {
			markup.open += ' ' + attrs.join(' ');
		}
	}

	if (data.innerHTML || Template.containerTags.indexOf(data.tagName) !== -1) {
		markup.open += '>';
		markup.innerHTML = data.innerHTML || '';
		markup.close = '</' + data.tagName + '>';
	} else {
		markup.close = '/>';
	}

	markup = Template.onElementRender(markup, droplet, drop_zone, is_output);

	return markup.open + markup.innerHTML + markup.close;
};

Template.renderTextDroplet = function (data, droplet, drop_zone, is_output) {
	var value = Template.onElementRender(data.value, droplet, drop_zone, is_output);

	return Template.entities(value);
};

Template.renderAttributeDroplet = function (data, droplet, drop_zone, is_output) {
	var markup = {
		key: data.key,
		value: data.value
	};

	markup = Template.onElementRender(markup, droplet, drop_zone, is_output);

	return markup.key + '="' + Template.entities(markup.value) + '"';
};

Template.entities = function (str) {
	return str.replace(/[\u00A0-\u9999<>\&]/gim, function (i) {
		return '&#' + i.charCodeAt(0) + ';';
	});
};

Template.onElementRender = function (markup, droplet, zone, is_output) {
	return markup;
};

Template.containerTags = ['a'];

exports.default = Template;

/***/ }),

/***/ 77:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(70);

var _promise2 = _interopRequireDefault(_promise);

var _superagent = __webpack_require__(73);

var _superagent2 = _interopRequireDefault(_superagent);

var _superagentPromise = __webpack_require__(72);

var _superagentPromise2 = _interopRequireDefault(_superagentPromise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _superagentPromise2.default)(_superagent2.default, _promise2.default);

/***/ }),

/***/ 9:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var actionTypes = exports.actionTypes = {
	UI_STATE: 'ui-state',
	ZONE_ADD_ATTACHMENT: 'zone-add-attachment',
	ZONE_EDIT_ATTACHMENT: 'zone-edit-attachment',
	ZONE_DETACH_ATTACHMENT: 'zone-detach-attachment',
	SET_DIALOG_MODE: 'set-dialog-mode',
	SET_ACTIVE_DROPLET: 'set-active-droplet'
};

var dialogModes = exports.dialogModes = {
	NONE: 'none',
	EDIT_DROPLET: 'edit-droplet'
};

var uiStates = exports.uiStates = {
	INITIALISING: 'initialising',
	ACTIVE: 'active'
};

var messageCommands = exports.messageCommands = {
	RELOAD: 'reload'
};

var errorCodes = exports.errorCodes = {
	NOT_A_DROPLET: 'A valid Droplet instance must be passed to DropZone#willAccept.'
};

var setLabels = exports.setLabels = {
	value: 'Value',
	attrs: 'Attributes',
	tagName: 'Tag name',
	innerHTML: 'HTML content'
};

/***/ })

},[292]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL0luZGV4LmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvYXNzZXRzL2RlZmF1bHQtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9hc3NldHMvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2NvbXBvbmVudC11dGlscy5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lcnMvQ2FudmFzLmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvY29udGFpbmVycy9DYW52YXNDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lcnMvRGlhbG9nQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy9jb250YWluZXJzL1BhbGxldENvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvY29udGFpbmVycy9UZW1wbGF0ZUNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvZGlhbG9ncy9EaWFsb2cuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy9kaWFsb2dzL0RpYWxvZ0VkaXREcm9wbGV0LmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvZGlhbG9ncy9EaWFsb2dIZWFkaW5nLmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvQnV0dG9uLmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvRHJvcFpvbmUuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9Ecm9wWm9uZUF0dGFjaG1lbnQuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9Ecm9wbGV0LmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvRmllbGRzZXQuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9Gb3JtLmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvUGFsbGV0LmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvVGVtcGxhdGUuanN4Iiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9WaWV3LmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvZmllbGRzL0Ryb3BEb3duLmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvZmllbGRzL1RleHRGaWVsZC5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9saWIvRHJhZ0Ryb3AuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9saWIvUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvbGliL1VJLmpzeCIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2xpYi9wb2x5ZmlsbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9zdGF0ZS9yZWR1Y2Vycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL3N0eWxlcy9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvbGliL0Ryb3BsZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zbmlmZnIvc3JjL3NuaWZmci5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL3N0eWxlcy9tYWluLnNjc3M/Y2I1NyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvcHV6emxlLXBpZWNlLnN2ZyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvdGFnLnN2ZyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvdGV4dC5zdmciLCJ3ZWJwYWNrOi8vLy4vfi9zdmctc3ByaXRlLWxvYWRlci9saWIvd2ViL3Nwcml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdGFnLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvbGliL0Zvcm1GaWVsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvSWNvbi5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9uanAtdGFnL3NyYy9saWIvQ29tbXVuaWNhdG9yLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvbGliL0Ryb3Bab25lLmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvc3RhdGUvYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3N2Zy1zcHJpdGUtbG9hZGVyL2xpYi93ZWIvZ2xvYmFsLXNwcml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2Fzc2V0cy9jb21tb24tcHJvcC10eXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2xpYi9UZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L25qcC10YWcvc3JjL2xpYi9hamF4LmpzIiwid2VicGFjazovLy8uL34vbmpwLXRhZy9zcmMvYXNzZXRzL2NvbnN0YW50cy5qcyJdLCJuYW1lcyI6WyJBcHAiLCJzZXR0aW5ncyIsIk9iamVjdCIsImRlZXBBc3NpZ24iLCJkZWZhdWx0cyIsIl9pbml0Iiwib25FbGVtZW50UmVuZGVyIiwiYmluZCIsInByb3RvdHlwZSIsIl9yZWZzIiwidWkiLCJhcHAiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJtb3VudGVkIiwiY29tcG9uZW50cyIsIl9kYXRhIiwidGVtcGxhdGUiLCJwYWxsZXQiLCJfdGVtcGxhdGUiLCJsb2FkIiwidXJsIiwidGhlbiIsImRhdGEiLCJjcmVhdGUiLCJkcm9wX3pvbmVzIiwiX2xvYWRQYWxsZXQiLCJzdG9yZWRfc3RhdGUiLCJfc3RvcmUiLCJfVUkiLCJyZW5kZXIiLCJkaXNwYXRjaCIsInNldFVJU3RhdGUiLCJBQ1RJVkUiLCJjYXRjaCIsImVycm9yIiwiZ2V0IiwicmVzcG9uc2UiLCJpdGVtIiwiSlNPTiIsInBhcnNlIiwidGV4dCIsImUiLCJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJwdXNoIiwidWlfc3RhdGUiLCJJTklUSUFMSVNJTkciLCJhY3RpdmUiLCJhY3RpdmVfZHJvcGxldF9pZCIsInpvbmVzIiwiZGlhbG9nIiwibW9kZSIsIk5PTkUiLCJzdGF0ZSIsImNsYXNzZXMiLCJjYW52YXMiLCJjYW52YXNfYWN0aXZlIiwiZHJvcGxldF9hY3RpdmUiLCJpc19kcmFnZ2luZyIsIml0ZW1fZHJhZ2dpbmciLCJkcm9wem9uZSIsImRyb3B6b25lX3RhcmdldCIsImRyb3B6b25lX2lzX2FjdGl2ZSIsImRyb3B6b25lX2lzX3RhcmdldCIsImF0dGFjaGVkIiwidGV4dF9lbGVtZW50IiwiaGlkZGVuIiwiZHJvcGxldCIsIm5vZGUiLCJtYWluIiwidmlzaWJsZSIsImNvbnRhaW5lciIsImhlYWRpbmciLCJzZWxlY3RvcnMiLCJkcm9wX3pvbmUiLCJpbml0aWFsX2ZsZXhfYmFzaXMiLCJ2aWV3Iiwic3JjIiwiZHJvcFpvbmUiLCJsYWJlbCIsIm9wdGlvblZhbHVlU2V0IiwidmFsdWVzIiwibm9kZXMiLCJrZXkiLCJmb3JFYWNoIiwidmFsdWUiLCJpbmRleCIsIkNhbnZhcyIsInByb3BzIiwib25Nb3VudCIsImpvaW4iLCJyZWZDb2xsZWN0b3IiLCJvbkF0dGFjaG1lbnRDbGljayIsIm9uRHJvcFpvbmVDbGljayIsImNsYXNzX3VpIiwib25EcmFnSGFuZGxlUHJlc3MiLCJvbkRyb3BsZXRDbGljayIsImNsYXNzX3RlbXBsYXRlIiwib25EaWFsb2dDb21wbGV0ZSIsIm9uRGlhbG9nQ2FuY2VsIiwicHJvcFR5cGVzIiwib2JqZWN0IiwiaXNSZXF1aXJlZCIsImZ1bmMiLCJtYXBTdGF0ZVRvUHJvcHMiLCJDYW52YXNDb250YWluZXIiLCJtYXBEaXNwYXRjaFRvUHJvcHMiLCJzZXREaWFsb2dNb2RlIiwiRGlhbG9nQ29udGFpbmVyIiwiYWN0aXZlRHJvcGxldElkIiwiUGFsbGV0Q29udGFpbmVyIiwiVGVtcGxhdGVDb250YWluZXIiLCJEaWFsb2dDb21wb25lbnRzIiwiRURJVF9EUk9QTEVUIiwiRGlhbG9nIiwiQ29tcG9uZW50Iiwic3RyaW5nIiwiZGVmYXVsdFByb3BzIiwiaGVhZGluZ3NCeVR5cGUiLCJpY29uIiwiVEFHIiwiVEVYVCIsIlBVWlpMRV9QSUVDRSIsIkRpYWxvZ0VkaXREcm9wbGV0IiwiZHJvcGxldF9pZCIsImdldERyb3BsZXRCeUlkIiwiZGV0YWNoQXR0YWNobWVudCIsImhhc093blByb3BlcnR5IiwiYXR0YWNobWVudF9pbmRleCIsInpvbmVEZXRhY2hBdHRhY2htZW50Iiwiem9uZV9pZCIsImZpZWxkc2V0cyIsImF0dGFjaG1lbnQiLCJmaWVsZHNldCIsImZpZWxkIiwiYXR0cmlidXRlIiwiem9uZUdldEF0dGFjaG1lbnQiLCJlZGl0YWJsZSIsImxlZ2VuZCIsImZpZWxkcyIsImF0dHJzIiwidHlwZSIsImdldEZpZWxkc2V0cyIsImJ1dHRvbnMiLCJ0aXRsZSIsIm5vdGVzIiwiZHJvcGxldFR5cGUiLCJjbGFzc05hbWUiLCJvbkNsaWNrIiwiY29uY2F0IiwiRGlhbG9nSGVhZGluZyIsIm5vdGUiLCJpY29uR2x5cGgiLCJhcnJheU9mIiwiQnV0dG9uIiwib25DYW5jZWwiLCJvbmVPZiIsIkRyb3Bab25lQ29tcG9uZW50IiwibXlyZWZzIiwiYXR0YWNobWVudENsaWNrIiwiem9uZSIsImlkIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImF0dGFjaG1lbnRJbmRleCIsImNoaWxkcmVuIiwiYWN0aXZlQXR0YWNobWVudHMiLCJ0YXJnZXRfa2V5IiwidGFyZ2V0X2NsYXNzIiwibWF4QXR0YWNobWVudHMiLCJhdHRhY2htZW50SWQiLCJyZW5kZXJBY3RpdmVBdHRhY2htZW50cyIsImluc3RhbmNlT2YiLCJhcnJheSIsIkRyb3Bab25lQXR0YWNobWVudCIsInJlbmRlckRyb3BsZXQiLCJudW1iZXIiLCJkcm9wbGV0VHlwZVRvR2x5cGhzIiwiRHJvcGxldENvbXBvbmVudCIsIm5hbWUiLCJib29sIiwiRmllbGRDb21wb25lbnRzIiwiRmllbGRzZXQiLCJmb3JtVmFsdWVzIiwiZWxlbWVudENoYW5nZSIsIm91dHB1dCIsInRhcmdldCIsInNldFN0YXRlIiwib25GaWVsZFVwZGF0ZSIsInNldCIsIlByb3BUeXBlcyIsIkZvcm0iLCJmaWVsZFNldHMiLCJ2YWx1ZXNfc3RhdGUiLCJzZXRzIiwiYXNzaWduIiwib25TdWJtaXQiLCJidXR0b24iLCJnZXRCdXR0b25zIiwic2hhcGUiLCJQYWxsZXQiLCJpdGVtcyIsImdldEl0ZW1zIiwiYXBwbHkiLCJUZW1wbGF0ZSIsImRyb3B6b25lX2lkIiwiYXR0YWNobWVudHMiLCJjb21wb25lbnQiLCJjb250ZW50IiwiZ2V0Wm9uZUF0dGFjaG1lbnRzIiwiZ2V0VGVtcGxhdGUiLCJWaWV3IiwiRHJvcERvd24iLCJvbkNoYW5nZSIsIm9wdGlvbnMiLCJUZXh0RmllbGQiLCJwbGFjZWhvbGRlciIsIm1heGxlbmd0aCIsIndpbmRvdyIsImludGVyYWN0IiwiRHJhZ0Ryb3AiLCJjYWxsYmFja3MiLCJfY2FudmFzIiwiX2NhbGxiYWNrcyIsImRyYWciLCJkcm9wIiwiYWRkRHJhZ2FibGUiLCJlbGVtZW50IiwiZHJhZ2FibGUiLCJEcmFnYWJsZSIsInNldERyYWdhYmxlIiwib24iLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiLCJkcmFnRW5kIiwiX2NyZWF0ZUluc3RhbmNlIiwiYWRkRHJvcGFibGUiLCJkcm9wYWJsZSIsIkRyb3BhYmxlIiwic2V0RHJvcGFibGUiLCJyZWxhdGVkVGFyZ2V0IiwicmVzZXREcmFnUG9zaXRpb24iLCJnZXREcmFnSW5zdGFuY2UiLCJpbnN0YW5jZSIsInJlc2V0UG9zaXRpb24iLCJmaW5kIiwiX2VsZW1lbnQiLCJfeCIsIl95IiwiZHJhZ2dhYmxlIiwib25EcmFnTW92ZSIsImR4IiwiZHkiLCJzdHlsZSIsIndlYmtpdFRyYW5zZm9ybSIsInRyYW5zZm9ybSIsImNoYWluIiwiYXJncyIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsInByb3BuYW1lIiwiZHJvcGxldF9uYW1lIiwiZHJvcGxldF90eXBlIiwidGVzdCIsImZuIiwiYXNzZXJ0IiwibWVzc2FnZSIsInByb3BfaWQiLCJwcm9wIiwic3RyaW5nTm90RW1wdHkiLCJub3RFbXB0eSIsImEiLCJfY2hhaW4iLCJfYXNzZXJ0IiwiVUkiLCJwYXJlbnQiLCJyZWZzIiwic3RvcmUiLCJfcGFyZW50IiwiZHJhZ2Ryb3AiLCJkcm9wbGV0RWRpdCIsImNhbGxiYWNrIiwidnBfd2lkdGgiLCJkcmFnSGFuZGxlUG9zaXRpb24iLCJfY29tbXMiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImNvbnNvbGUiLCJsb2ciLCJxdWV1ZXMiLCJkcmFnZHJvcEJpbmRpbmdzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9oYW5kbGVXaW5kb3dSZXNpemUiLCJfcmVmQ29sbGVjdG9yIiwiX21vdW50RXZlbnQiLCJfY29tcGxldGVEaWFsb2dBY3Rpb24iLCJfY2FuY2VsRGlhbG9nQWN0aW9uIiwiX2hhbmRsZUF0dGFjaG1lbnRDbGljayIsIl9oYW5kbGVEcm9wbGV0Q2xpY2siLCJfaGFuZGxlRHJvcFpvbmVDbGljayIsIl9oYW5kbGVEcmFnSGFuZGxlRXZlbnQiLCJfc2hvd0RpYWxvZyIsImRpYWxvZ19kYXRhIiwiZ2V0U3RhdGUiLCJ6b25lQWRkQXR0YWNobWVudCIsInpvbmVFZGl0QXR0YWNobWVudCIsImNvbGxlY3Rpb24iLCJfZ2V0UmVmZXJlbmNlZEVsZW1lbnQiLCJfcXVldWVEcmFnRHJvcEJpbmRpbmciLCJfc2V0RHJhZ0Ryb3BCaW5kaW5ncyIsInJlZ2lzdGVyR3Vlc3RBZGRyZXNzIiwiY29udGVudFdpbmRvdyIsInZpZXdfZnJhbWUiLCJxdWV1ZSIsImRyb3BsZXRzIiwiX2hhbmRsZURyb3BsZXREcm9wIiwicmVmIiwiYWNjZXB0IiwiZ2V0RHJvcFpvbmVCeUlkIiwiYXR0YWNoRHJvcGxldFRvRHJvcFpvbmUiLCJzZXRBY3RpdmVEcm9wbGV0Iiwid2lkdGgiLCJfc2V0VGVtcGxhdGVWaWV3UmF0aW8iLCJkcmFnX2hhbmRsZV94Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRMZWZ0IiwiTWF0aCIsIm1heCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwiaW5uZXJXaWR0aCIsInJhdGlvIiwiZmxleEJhc2lzIiwiYWJzIiwiX2lzVmFsaWREcm9wIiwid2lsbEFjY2VwdCIsIl91cGRhdGVWaWV3Iiwic2VuZCIsImNtZCIsIlJFTE9BRCIsIm1hcmt1cCIsInJlbmRlckFzSFRNTCIsInZhckFyZ3MiLCJ0byIsImZyb20iLCJUeXBlRXJyb3IiLCJhY3Rpb24iLCJVSV9TVEFURSIsIlNFVF9BQ1RJVkVfRFJPUExFVCIsIlpPTkVfQUREX0FUVEFDSE1FTlQiLCJaT05FX0VESVRfQVRUQUNITUVOVCIsIlpPTkVfREVUQUNIX0FUVEFDSE1FTlQiLCJzcGxpY2UiLCJTRVRfRElBTE9HX01PREUiLCJEcm9wbGV0IiwiX29yaWdpbmFsU2V0dGluZ3MiLCJhdHRhY2htZW50SWRzIiwiaW5pdCIsIl92YWxpZGF0ZUFuZFNldCIsIl9zZXRFeHRyYUZpZWxkcyIsImNvbnRleHQiLCJfdmFsaWRhdGVFZGl0YWJsZVNldCIsImF0dHJrZXkiLCJwcm9wX2Vycm9yIiwiZWRpdGFibGVBdHRyaWJ1dGVzIiwiaW5kZXhPZiIsIl92YWxpZGF0ZUVkaXRhYmxlSXRlbSIsImVycm9yX3ByZWZpeCIsImVkaXRhYmxlRmllbGRUeXBlcyIsInZhbGlkYXRlRGF0YUF0dHJpYnV0ZSIsInRhZ05hbWUiLCJpbm5lckhUTUwiLCJyZWdpc3RlckdlbmVyYWxFdmVudCIsImluZm8iLCJvbkV2ZW50IiwiY29sbGVjdFJlZiIsInZhbGlkYXRlUHJvcEtleXMiLCJyZXF1aXJlIiwidW5kZWZpbmVkIiwiZXNjYXBlUmVnRXhwIiwic3RyIiwicmVwbGFjZSIsImRlZmF1bHQiLCJpc19vdXRwdXQiLCJGb3JtRmllbGQiLCJfc2V0TmFtZUFuZFR5cGUiLCJ2YWxpZFR5cGVzIiwicmVxdWlyZWQiLCJfdmFsaWRhdGVPcHRpb25zU2V0dGluZyIsIl92YWxpZGF0ZVZhbHVlU2V0dGluZyIsIkljb24iLCJHTFlQSFMiLCJoZWlnaHQiLCJnbHlwaCIsImxvY2FsU3RvcmFnZSIsImNoZWNrU3RvcmFnZSIsInN0b3JhZ2UiLCJ4Iiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJDb21tdW5pY2F0b3IiLCJfc2V0dGluZ3MiLCJfZ3Vlc3RzIiwiX3F1ZXVlIiwiX29yaWdpbiIsIl9yZWNlaXZlTWVzc2FnZSIsIl9zZW5kUGluZyIsInBpbmciLCJfY3JlYXRlTWVzc2FnZSIsIm9wZW5lciIsInRvcCIsIl9wb3N0IiwiX3NlbmRQb25nIiwicG9uZyIsImRlc3QiLCJfc2V0R3Vlc3REYXRhIiwidGltZXIiLCJjbGVhckludGVydmFsIiwibGl2ZSIsImd1ZXN0IiwiX2dldEd1ZXN0QnlJZCIsIl9hZGRUb1F1ZXVlIiwiX3NlbmRRdWV1ZSIsIl9nZXRHdWVzdEJ5Tm9kZSIsInBvc3RNZXNzYWdlIiwib3JpZ2luYWxFdmVudCIsInNvdXJjZSIsIl9zZXRHdWVzdExpdmUiLCJvcmlnaW5hbE1lc3NhZ2UiLCJob3N0IiwiRHJvcFpvbmUiLCJkcm9wX3pvbmVfaWQiLCJ0YWciLCJjdXJyZW50X2F0dGFjaG1lbnRzIiwiTk9UX0FfRFJPUExFVCIsImZldGNoWm9uZSIsIm1hdGNoIiwiX3JlX3pvbmVzIiwiZXhlYyIsImNoZWNrU3ludGF4IiwiZCIsInN5bnRheF9yZSIsInJlX3N0cnVjdHVyZSIsInJlX2lkIiwic255dGF4RmF1bHQiLCJyZV9xdHkiLCJwYXJzZUZsb2F0IiwiY2hhciIsIndhcm4iLCJvbmVPZlR5cGUiLCJfZHJvcF96b25lcyIsIl9tYXhfem9uZXMiLCJfbWFya3VwIiwiZW50aXRpZXMiLCJfY3JlYXRlRHJvcFpvbmVzIiwiY291bnRlciIsIl9jcmVhdGVUZW1wbGF0ZUFycmF5Iiwic2FuZGJveCIsImNyZWF0ZUVsZW1lbnQiLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJOb2RlIiwiVEVYVF9OT0RFIiwidGV4dENvbnRlbnQiLCJFTEVNRU5UX05PREUiLCJkYXRhc2V0IiwiaHRtbCIsInJlbmRlckVsZW1lbnREcm9wbGV0IiwicmVuZGVyVGV4dERyb3BsZXQiLCJyZW5kZXJBdHRyaWJ1dGVEcm9wbGV0IiwiYXR0ciIsIm9wZW4iLCJjb250YWluZXJUYWdzIiwiY2xvc2UiLCJpIiwiY2hhckNvZGVBdCIsImFjdGlvblR5cGVzIiwiZGlhbG9nTW9kZXMiLCJ1aVN0YXRlcyIsIm1lc3NhZ2VDb21tYW5kcyIsImVycm9yQ29kZXMiLCJzZXRMYWJlbHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBOztBQUNBOztBQUVBOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFFQTs7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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Ozs7O0FDOU5mOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O2tCQUVlLHlFOzs7Ozs7Ozs7Ozs7O0FDSlIsSUFBTWtSLG9DQUFjO0FBQzFCakksV0FBVSxVQURnQjtBQUUxQkUsc0JBQXFCLHFCQUZLO0FBRzFCQyx1QkFBc0Isc0JBSEk7QUFJMUJDLHlCQUF3Qix3QkFKRTtBQUsxQkUsa0JBQWlCLGlCQUxTO0FBTTFCTCxxQkFBb0I7QUFOTSxDQUFwQjs7QUFTQSxJQUFNaUksb0NBQWM7QUFDMUIzYSxPQUFNLE1BRG9CO0FBRTFCNkQsZUFBYztBQUZZLENBQXBCOztBQUtBLElBQU0rVyw4QkFBVztBQUN2QmxiLGVBQWMsY0FEUztBQUV2QmxCLFNBQVE7QUFGZSxDQUFqQjs7QUFLQSxJQUFNcWMsNENBQWtCO0FBQzlCNUksU0FBUTtBQURzQixDQUF4Qjs7QUFJQSxJQUFNNkksa0NBQWE7QUFDekI5QyxnQkFBZTtBQURVLENBQW5COztBQUlBLElBQU0rQyxnQ0FBWTtBQUN4QjlZLFFBQU8sT0FEaUI7QUFFeEJ1RCxRQUFPLFlBRmlCO0FBR3hCd08sVUFBUyxVQUhlO0FBSXhCQyxZQUFXO0FBSmEsQ0FBbEIsQyIsImZpbGUiOiJtYWluLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVN0b3JlIH0gZnJvbSAncmVkdXgnO1xuXG5pbXBvcnQgJy4vbGliL3BvbHlmaWxscyc7XG5pbXBvcnQgJy4vc3R5bGVzL21haW4uc2Nzcyc7XG5cbmltcG9ydCBVSSBmcm9tICcuL2xpYi9VSS5qc3gnO1xuXG5pbXBvcnQgRHJvcGxldCBmcm9tICcuL2xpYi9Ecm9wbGV0JztcbmltcG9ydCByZXF1ZXN0IGZyb20gJy4vbGliL2FqYXgnO1xuaW1wb3J0IFRlbXBsYXRlIGZyb20gJy4vbGliL1RlbXBsYXRlJztcblxuaW1wb3J0IGFjdGlvbnMgZnJvbSAnLi9zdGF0ZS9hY3Rpb25zJztcbmltcG9ydCByZWR1Y2VycyBmcm9tICcuL3N0YXRlL3JlZHVjZXJzJztcblxuaW1wb3J0IGFwcERlZmF1bHRzIGZyb20gJy4vYXNzZXRzL2RlZmF1bHRzJztcbmltcG9ydCB7IHVpU3RhdGVzIH0gZnJvbSAnLi9hc3NldHMvY29uc3RhbnRzJztcblxuLypcbiAqIE1haW4gYXBwbGljYXRpb24gd3JhcGVyLlxuICogQGNsYXNzXG4gKi9cbnZhciBBcHAgPSBmdW5jdGlvbihzZXR0aW5ncyA9IHt9KSB7XG5cdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuZGVlcEFzc2lnbih7fSwgQXBwLmRlZmF1bHRzLCBzZXR0aW5ncyk7XG5cdHRoaXMuX2luaXQoKTtcblxuXHQvLyBzZXQgVGVtcGxhdGUub25FbGVtZW50UmVuZGVyIHRvIHNldHRpbmdzLCBpZiBkZWZpbmVkXG5cdGlmIChzZXR0aW5ncy5vbkVsZW1lbnRSZW5kZXIpIHtcblx0XHRUZW1wbGF0ZS5vbkVsZW1lbnRSZW5kZXIgPSBzZXR0aW5ncy5vbkVsZW1lbnRSZW5kZXIuYmluZCh0aGlzKTtcblx0fVxufTtcblxuQXBwLnByb3RvdHlwZSA9IHtcblx0X2luaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3JlZnMgPSB7XG5cdFx0XHR1aToge1xuXHRcdFx0XHRhcHA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hcHAnKVxuXHRcdFx0fSxcblx0XHRcdG1vdW50ZWQ6IHt9LFxuXHRcdFx0Y29tcG9uZW50czoge31cblx0XHR9O1xuXG5cdFx0Ly8gYXBwIGRhdGEgc3RvcmUgKG5vdCBzdGF0ZWZ1bClcblx0XHR0aGlzLl9kYXRhID0ge1xuXHRcdFx0dGVtcGxhdGU6ICcnLFxuXHRcdFx0cGFsbGV0OiBbXVxuXHRcdH07XG5cblx0XHQvLyB0ZW1wbGF0ZXMgbW9kdWxlXG5cdFx0dGhpcy5fdGVtcGxhdGUgPSBuZXcgVGVtcGxhdGUodGhpcywgdGhpcy5zZXR0aW5ncyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIExvYWQgdGhlIHRlbXBsYXRlL3BhbGxldCBkYXRhIGFuZCBhY3RpdmF0ZSBUYWcuXG5cdCAqL1xuXHRsb2FkOiBmdW5jdGlvbih1cmwsIHBhbGxldCkge1xuXHRcdHJldHVybiB0aGlzLl90ZW1wbGF0ZS5sb2FkKHVybClcblx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0Ly8gbG9hZCB0aGUgSFRNTCB0ZW1wbGF0ZSBhbmQgY3JlYXRlIGl0XG5cdFx0XHRcdHZhciBkYXRhID0gdGhpcy5fdGVtcGxhdGUuY3JlYXRlKCk7XG5cblx0XHRcdFx0dGhpcy5fZGF0YS5kcm9wX3pvbmVzID0gZGF0YS5kcm9wX3pvbmVzO1xuXHRcdFx0XHR0aGlzLl9kYXRhLnRlbXBsYXRlID0gZGF0YS50ZW1wbGF0ZTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdC8vIGxvYWQgdGhlIEpTT04gYmFzZWQgcGFsbGV0IGRhdGFcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2xvYWRQYWxsZXQocGFsbGV0KTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdHZhciBzdG9yZWRfc3RhdGUgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBjcmVhdGUgc3RhdGUgc3RvcmVcblx0XHRcdFx0aWYgKHN0b3JlZF9zdGF0ZSkge1xuXHRcdFx0XHRcdC8vIGFwcCBzdGF0ZSBzdG9yZSAtIGZyb20gc2Vzc2lvblxuXHRcdFx0XHRcdC8vICFUT0RPXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gYXBwIHN0YXRlIHN0b3JlIC0gZGVmYXVsdFxuXHRcdFx0XHRcdHRoaXMuX3N0b3JlID0gY3JlYXRlU3RvcmUocmVkdWNlcnMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYWN0aXZhdGUgdGhlIFVJXG5cdFx0XHRcdHRoaXMuX1VJID0gbmV3IFVJKFxuXHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncyxcblx0XHRcdFx0XHR0aGlzLl9yZWZzLFxuXHRcdFx0XHRcdHRoaXMuX2RhdGEsXG5cdFx0XHRcdFx0dGhpcy5fc3RvcmUsXG5cdFx0XHRcdFx0dGhpcy5fdGVtcGxhdGVcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyByZW5kZXJcblx0XHRcdFx0dGhpcy5fVUkucmVuZGVyKCk7XG5cblx0XHRcdFx0dGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy5zZXRVSVN0YXRlKHVpU3RhdGVzLkFDVElWRSkpO1xuXHRcdFx0fSlcblx0XHRcdC5jYXRjaCgoZXJyb3IpID0+IHtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogTG9hZCB0aGUgcGFsbGV0IGRhdGFcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9sb2FkUGFsbGV0OiBmdW5jdGlvbih1cmwpIHtcblx0XHRyZXR1cm4gcmVxdWVzdC5nZXQodXJsKVxuXHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0XHRcdHZhciBwYWxsZXQsIGl0ZW07XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwYWxsZXQgPSBKU09OLnBhcnNlKHJlc3BvbnNlLnRleHQpO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0J1BhbGxldCBkYXRhIGF0IGZpbGUgXCInICsgdXJsICsgJ1wiXCIgY291bGQgbm90IGJlIHBhcnNlZC4nICtcblx0XHRcdFx0XHRcdCcgaXMgaXQgdmFsaWQgSlNPTj8nXG5cdFx0XHRcdFx0KSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShwYWxsZXQpICYmIHBhbGxldC5sZW5ndGgpIHtcblx0XHRcdFx0XHRmb3IgKGl0ZW0gaW4gcGFsbGV0KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLnBhbGxldC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRuZXcgRHJvcGxldChwYWxsZXRbaXRlbV0pXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHQnTG9va3MgbGlrZSB0aGUgcGFsbGV0IGF0IHBhdGggJyArIHVybCArXG5cdFx0XHRcdFx0XHQnIGlzbuKAmXQgYSB2YWxpZCBhcnJheSBpbiBKU09OIGZvcm1hdC4nXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5jYXRjaCgoZXJyb3IpID0+IHtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0fSxcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzZXR0aW5ncy5cbiAqL1xuQXBwLmRlZmF1bHRzID0gYXBwRGVmYXVsdHM7XG5cbmV4cG9ydCBkZWZhdWx0IEFwcDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL0luZGV4LmpzIiwiaW1wb3J0IHsgdWlTdGF0ZXMsIGRpYWxvZ01vZGVzIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuXG4vLyBkZWZhdWx0IHN0YXRlIGZvci4uLlxuZXhwb3J0IGRlZmF1bHQge1xuXHQvLyBnZW5lcmFsIGFwcGxpY2F0aW9uXG5cdGFwcDoge1xuXHRcdHVpX3N0YXRlOiB1aVN0YXRlcy5JTklUSUFMSVNJTkcsXG5cdFx0YWN0aXZlOiBmYWxzZSxcblx0XHRhY3RpdmVfZHJvcGxldF9pZDogJydcblx0fSxcblxuXHQvLyBhY3RpdmUgem9uZXMgYW5kIGN1cnJlbnQgYXR0YWNobWVudHNcblx0em9uZXM6IHt9LFxuXG5cdC8vIGRpYWxvZyBtb2RlIGFuZCBzdGF0ZVxuXHRkaWFsb2c6IHtcblx0XHRtb2RlOiBkaWFsb2dNb2Rlcy5OT05FLFxuXHRcdHN0YXRlOiB7fVxuXHR9XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvYXNzZXRzL2RlZmF1bHQtc3RhdGUuanMiLCJleHBvcnQgZGVmYXVsdCB7XG5cdGNsYXNzZXM6IHtcblx0XHRjYW52YXM6ICd0YWctY2FudmFzJyxcblx0XHRjYW52YXNfYWN0aXZlOiAnYWN0aXZlJyxcblx0XHRkcm9wbGV0X2FjdGl2ZTogJ2Ryb3BsZXQtYWN0aXZlJyxcblx0XHRpc19kcmFnZ2luZzogJ2RyYWdnaW5nJyxcblx0XHRpdGVtX2RyYWdnaW5nOiAnaXRlbS1kcmFnZ2luZycsXG5cdFx0ZHJvcHpvbmU6ICdkcm9wLXpvbmUnLFxuXHRcdGRyb3B6b25lX3RhcmdldDogJ3RhcmdldCcsXG5cdFx0ZHJvcHpvbmVfaXNfYWN0aXZlOiAnaXMtYWN0aXZlJyxcblx0XHRkcm9wem9uZV9pc190YXJnZXQ6ICdpcy10YXJnZXQnLFxuXHRcdGF0dGFjaGVkOiAnYXR0YWNoZWQnLFxuXHRcdHRleHRfZWxlbWVudDogJ3RleHQnLFxuXHRcdGhpZGRlbjogJ2hpZGRlbicsXG5cdFx0ZHJvcGxldDoge1xuXHRcdFx0bm9kZTogJ2Ryb3BsZXQnLFxuXHRcdFx0YWN0aXZlOiAnYWN0aXZlJyxcblx0XHR9LFxuXHRcdGRpYWxvZzoge1xuXHRcdFx0bWFpbjogJ2RpYWxvZycsXG5cdFx0XHR2aXNpYmxlOiAndmlzaWJsZScsXG5cdFx0XHRjb250YWluZXI6ICdkaWFsb2ctY29udGFpbmVyJyxcblx0XHRcdGhlYWRpbmc6ICdkaWFsb2ctaGVhZGluZydcblx0XHR9XG5cdH0sXG5cdHNlbGVjdG9yczoge1xuXHRcdGRyb3Bfem9uZTogJy5kcm9wLXpvbmUgLnRhcmdldCcsXG5cdFx0ZHJvcGxldDogJy5kcm9wbGV0J1xuXHR9LFxuXHR0ZW1wbGF0ZToge1xuXHRcdGluaXRpYWxfZmxleF9iYXNpczogNTBcblx0fSxcblx0dmlldzoge1xuXHRcdHNyYzogJ3ZpZXcuaHRtbCdcblx0fSxcblx0ZHJvcFpvbmU6IHtcblx0XHRsYWJlbDogJy4uLidcblx0fSxcblx0b25FbGVtZW50UmVuZGVyOiBudWxsXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvYXNzZXRzL2RlZmF1bHRzLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGNvbnN0IG9wdGlvblZhbHVlU2V0ID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdHZhciBub2RlcyA9IFtdLCBrZXk7XG5cblx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuXHRcdHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuXHRcdFx0dmFyIGtleSA9ICdpdGVtLScgKyBpbmRleDtcblx0XHRcdG5vZGVzLnB1c2goXG5cdFx0XHRcdDxvcHRpb24ga2V5PXtrZXl9IHZhbHVlPXt2YWx1ZX0+e3ZhbHVlfTwvb3B0aW9uPlxuXHRcdFx0KTtcblx0XHR9KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWVzID09PSAnb2JqZWN0Jykge1xuXHRcdGZvciAoa2V5IGluIHZhbHVlcykge1xuXHRcdFx0bm9kZXMucHVzaChcblx0XHRcdFx0PG9wdGlvbiBrZXk9e2tleX0gdmFsdWU9e2tleX0+e3ZhbHVlc1trZXldfTwvb3B0aW9uPlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbm9kZXM7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy9jb21wb25lbnQtdXRpbHMuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29sbGVjdFJlZiB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5cbmltcG9ydCBWaWV3IGZyb20gJy4uL3ZpZXdzL1ZpZXcuanN4JztcbmltcG9ydCBUZW1wbGF0ZSBmcm9tICcuL1RlbXBsYXRlQ29udGFpbmVyJztcbmltcG9ydCBEaWFsb2cgZnJvbSAnLi9EaWFsb2dDb250YWluZXInO1xuaW1wb3J0IFBhbGxldCBmcm9tICcuL1BhbGxldENvbnRhaW5lcic7XG5cbmNsYXNzIENhbnZhcyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0aWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uTW91bnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMucHJvcHMub25Nb3VudCgnY2FudmFzJyk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW1xuXHRcdFx0dGhpcy5wcm9wcy5zZXR0aW5ncy5jbGFzc2VzLmNhbnZhcyxcblx0XHRcdHRoaXMucHJvcHMuc3RhdGUudWlfc3RhdGVcblx0XHRdO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuc3RhdGUuYWN0aXZlX2Ryb3BsZXRfaWQgIT09ICcnKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2godGhpcy5wcm9wcy5zZXR0aW5ncy5jbGFzc2VzLmRyb3BsZXRfYWN0aXZlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuam9pbignICcpfVxuXHRcdFx0XHRyZWY9e2NvbGxlY3RSZWYodGhpcy5wcm9wcywgJ2NhbnZhcycpfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdDxoZWFkZXI+XG5cdFx0XHRcdFx0PGgxPiZsdDs8Yj5UYWc8L2I+Jmd0OzwvaDE+XG5cdFx0XHRcdDwvaGVhZGVyPlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwibWFpblwiPlxuXHRcdFx0XHRcdDxUZW1wbGF0ZVxuXHRcdFx0XHRcdFx0ZGF0YT17dGhpcy5wcm9wcy5kYXRhfVxuXHRcdFx0XHRcdFx0c2V0dGluZ3M9e3RoaXMucHJvcHMuc2V0dGluZ3N9XG5cdFx0XHRcdFx0XHRyZWZDb2xsZWN0b3I9e3RoaXMucHJvcHMucmVmQ29sbGVjdG9yfVxuXHRcdFx0XHRcdFx0b25Nb3VudD17dGhpcy5wcm9wcy5vbk1vdW50fVxuXHRcdFx0XHRcdFx0b25BdHRhY2htZW50Q2xpY2s9e3RoaXMucHJvcHMub25BdHRhY2htZW50Q2xpY2t9XG5cdFx0XHRcdFx0XHRvbkRyb3Bab25lQ2xpY2s9e3RoaXMucHJvcHMub25Ecm9wWm9uZUNsaWNrfVxuXHRcdFx0XHRcdFx0dGVtcGxhdGU9e3RoaXMucHJvcHMuZGF0YS50ZW1wbGF0ZX1cblx0XHRcdFx0XHRcdGNsYXNzX3VpPXt0aGlzLnByb3BzLmNsYXNzX3VpfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImRyYWctaGFuZGxlXCJcblx0XHRcdFx0XHRcdG9uTW91c2VEb3duPXt0aGlzLnByb3BzLm9uRHJhZ0hhbmRsZVByZXNzfVxuXHRcdFx0XHRcdFx0b25Nb3VzZVVwPXt0aGlzLnByb3BzLm9uRHJhZ0hhbmRsZVByZXNzfVxuXHRcdFx0XHRcdFx0b25Ub3VjaFN0YXJ0PXt0aGlzLnByb3BzLm9uRHJhZ0hhbmRsZVByZXNzfVxuXHRcdFx0XHRcdFx0b25Ub3VjaEVuZD17dGhpcy5wcm9wcy5vbkRyYWdIYW5kbGVQcmVzc31cblx0XHRcdFx0XHRcdHJlZj17Y29sbGVjdFJlZih0aGlzLnByb3BzLCAnZHJhZ19oYW5kbGUnKX0+PC9kaXY+XG5cdFx0XHRcdFx0PFZpZXdcblx0XHRcdFx0XHRcdHNldHRpbmdzPXt0aGlzLnByb3BzLnNldHRpbmdzfVxuXHRcdFx0XHRcdFx0b25Nb3VudD17dGhpcy5wcm9wcy5vbk1vdW50fVxuXHRcdFx0XHRcdFx0cmVmQ29sbGVjdG9yPXt0aGlzLnByb3BzLnJlZkNvbGxlY3Rvcn0vPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8UGFsbGV0XG5cdFx0XHRcdFx0ZGF0YT17dGhpcy5wcm9wcy5kYXRhfVxuXHRcdFx0XHRcdHNldHRpbmdzPXt0aGlzLnByb3BzLnNldHRpbmdzfVxuXHRcdFx0XHRcdG9uTW91bnQ9e3RoaXMucHJvcHMub25Nb3VudH1cblx0XHRcdFx0XHRvbkRyb3BsZXRDbGljaz17dGhpcy5wcm9wcy5vbkRyb3BsZXRDbGlja31cblx0XHRcdFx0XHRyZWZDb2xsZWN0b3I9e3RoaXMucHJvcHMucmVmQ29sbGVjdG9yfS8+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJvdmVybGF5XCI+PC9kaXY+XG5cdFx0XHRcdDxEaWFsb2dcblx0XHRcdFx0XHRkYXRhPXt0aGlzLnByb3BzLmRhdGF9XG5cdFx0XHRcdFx0c2V0dGluZ3M9e3RoaXMucHJvcHMuc2V0dGluZ3N9XG5cdFx0XHRcdFx0Y2xhc3NfdWk9e3RoaXMucHJvcHMuY2xhc3NfdWl9XG5cdFx0XHRcdFx0Y2xhc3NfdGVtcGxhdGU9e3RoaXMucHJvcHMuY2xhc3NfdGVtcGxhdGV9XG5cdFx0XHRcdFx0b25EaWFsb2dDb21wbGV0ZT17dGhpcy5wcm9wcy5vbkRpYWxvZ0NvbXBsZXRlfVxuXHRcdFx0XHRcdG9uRGlhbG9nQ2FuY2VsPXt0aGlzLnByb3BzLm9uRGlhbG9nQ2FuY2VsfS8+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cbkNhbnZhcy5wcm9wVHlwZXMgPSB7XG5cdC8vIGZyb20gQ2FudmFzQ29udGFpbmVyXG5cdHN0YXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cblx0Ly8gZnJvbSBVSSNyZW5kZXJcblx0ZGF0YTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRvbk1vdW50OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRvbkRpYWxvZ0NvbXBsZXRlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRvbkRpYWxvZ0NhbmNlbDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblx0b25BdHRhY2htZW50Q2xpY2s6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdG9uRHJvcGxldENsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRvbkRyb3Bab25lQ2xpY2s6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdG9uRHJhZ0hhbmRsZVByZXNzOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRyZWZDb2xsZWN0b3I6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdHNldHRpbmdzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cdGNsYXNzX3VpOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cdGNsYXNzX3RlbXBsYXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYW52YXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lcnMvQ2FudmFzLmpzeCIsImltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5cbmltcG9ydCBDYW52YXMgZnJvbSAnLi9DYW52YXMuanN4JztcblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlKSA9PiB7XG5cdHJldHVybiB7XG5cdFx0c3RhdGU6IHN0YXRlLmFwcFxuXHR9O1xufTtcblxuY29uc3QgQ2FudmFzQ29udGFpbmVyID0gY29ubmVjdChcbiAgbWFwU3RhdGVUb1Byb3BzXG4pKENhbnZhcyk7XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc0NvbnRhaW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvY29udGFpbmVycy9DYW52YXNDb250YWluZXIuanMiLCJpbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuXG5pbXBvcnQgRGlhbG9nIGZyb20gJy4uL2RpYWxvZ3MvRGlhbG9nLmpzeCc7XG5pbXBvcnQgeyBkaWFsb2dNb2RlcyB9IGZyb20gJy4uLy4uL2Fzc2V0cy9jb25zdGFudHMnO1xuaW1wb3J0IGFjdGlvbnMgZnJvbSAnLi4vLi4vc3RhdGUvYWN0aW9ucyc7XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IChzdGF0ZSkgPT4ge1xuXHRyZXR1cm4ge1xuXHRcdG1vZGU6IHN0YXRlLmRpYWxvZy5tb2RlLFxuXHRcdHN0YXRlOiBzdGF0ZS5kaWFsb2cuc3RhdGVcblx0fTtcbn07XG5cbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IChkaXNwYXRjaCkgPT4ge1xuXHRyZXR1cm4ge1xuXHRcdG9uRGlhbG9nQ2FuY2VsOiAoKSA9PiB7XG5cdFx0XHRkaXNwYXRjaChhY3Rpb25zLnNldERpYWxvZ01vZGUoZGlhbG9nTW9kZXMuTk9ORSkpO1xuXHRcdH0sXG5cdH07XG59O1xuXG5jb25zdCBEaWFsb2dDb250YWluZXIgPSBjb25uZWN0KFxuICBtYXBTdGF0ZVRvUHJvcHMsXG4gIG1hcERpc3BhdGNoVG9Qcm9wc1xuKShEaWFsb2cpO1xuXG5leHBvcnQgZGVmYXVsdCBEaWFsb2dDb250YWluZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lcnMvRGlhbG9nQ29udGFpbmVyLmpzIiwiaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcblxuaW1wb3J0IFBhbGxldCBmcm9tICcuLi92aWV3cy9QYWxsZXQuanN4JztcblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlKSA9PiB7XG5cdHJldHVybiB7XG5cdFx0YWN0aXZlRHJvcGxldElkOiBzdGF0ZS5hcHAuYWN0aXZlX2Ryb3BsZXRfaWRcblx0fTtcbn07XG5cbmNvbnN0IFBhbGxldENvbnRhaW5lciA9IGNvbm5lY3QoXG4gIG1hcFN0YXRlVG9Qcm9wc1xuKShQYWxsZXQpO1xuXG5leHBvcnQgZGVmYXVsdCBQYWxsZXRDb250YWluZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lcnMvUGFsbGV0Q29udGFpbmVyLmpzIiwiaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcblxuaW1wb3J0IFRlbXBsYXRlIGZyb20gJy4uL3ZpZXdzL1RlbXBsYXRlLmpzeCc7XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IChzdGF0ZSkgPT4ge1xuXHRyZXR1cm4ge1xuXHRcdHpvbmVzOiBzdGF0ZS56b25lc1xuXHR9O1xufTtcblxuY29uc3QgVGVtcGxhdGVDb250YWluZXIgPSBjb25uZWN0KFxuICBtYXBTdGF0ZVRvUHJvcHNcbikoVGVtcGxhdGUpO1xuXG5leHBvcnQgZGVmYXVsdCBUZW1wbGF0ZUNvbnRhaW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvY29udGFpbmVycy9UZW1wbGF0ZUNvbnRhaW5lci5qcyIsImltcG9ydCBSZWFjdCwgeyBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IGRpYWxvZ01vZGVzIH0gZnJvbSAnLi4vLi4vYXNzZXRzL2NvbnN0YW50cyc7XG5cbi8vIGltcG9ydCB0aGUgZGlhbG9ncyB1c2VkLCB0aGVuIHB1dCBpbnRvIGEgZ2xvYmFsIGZvciByZWZlcmVuY2luZ1xuaW1wb3J0IERpYWxvZ0VkaXREcm9wbGV0IGZyb20gJy4uL2RpYWxvZ3MvRGlhbG9nRWRpdERyb3BsZXQuanN4JztcblxudmFyIERpYWxvZ0NvbXBvbmVudHMgPSB7fTtcbkRpYWxvZ0NvbXBvbmVudHNbZGlhbG9nTW9kZXMuRURJVF9EUk9QTEVUXSA9IERpYWxvZ0VkaXREcm9wbGV0O1xuXG5mdW5jdGlvbiBEaWFsb2cocHJvcHMpIHtcblx0dmFyIENvbXBvbmVudCxcblx0XHRjbGFzc2VzID0gW3Byb3BzLnNldHRpbmdzLmNsYXNzZXMuZGlhbG9nLm1haW5dO1xuXG5cdGlmIChwcm9wcy5tb2RlICE9PSBkaWFsb2dNb2Rlcy5OT05FKSB7XG5cdFx0Y2xhc3Nlcy5wdXNoKHByb3BzLnNldHRpbmdzLmNsYXNzZXMuZGlhbG9nLnZpc2libGUpO1xuXHR9XG5cblx0Ly8gZ2V0IGFwcHJvcHJpYXRlIGNvbXBvbmVudCBmb3IgZGlhbG9nIG1vZGVcblx0Q29tcG9uZW50ID0gRGlhbG9nQ29tcG9uZW50c1twcm9wcy5tb2RlXTtcblxuXHRpZiAoQ29tcG9uZW50KSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLmpvaW4oJyAnKX0+XG5cdFx0XHRcdDxDb21wb25lbnRcblx0XHRcdFx0XHRzdGF0ZT17cHJvcHMuc3RhdGV9XG5cdFx0XHRcdFx0c2V0dGluZ3M9e3Byb3BzLnNldHRpbmdzfVxuXHRcdFx0XHRcdGNsYXNzX3RlbXBsYXRlPXtwcm9wcy5jbGFzc190ZW1wbGF0ZX1cblx0XHRcdFx0XHRvbkRpYWxvZ0NvbXBsZXRlPXtwcm9wcy5vbkRpYWxvZ0NvbXBsZXRlfVxuXHRcdFx0XHRcdG9uRGlhbG9nQ2FuY2VsPXtwcm9wcy5vbkRpYWxvZ0NhbmNlbH1cblx0XHRcdFx0XHRjbGFzc191aT17cHJvcHMuY2xhc3NfdWl9Lz5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLmpvaW4oJyAnKX0+PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5EaWFsb2cucHJvcFR5cGVzID0ge1xuXHQvLyBmcm9tIERpYWxvZ0NvbnRhaW5lclxuXHRtb2RlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRzdGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcblxuXHQvLyBmcm9tIENhbnZhc1xuXHRzZXR0aW5nczogUHJvcFR5cGVzLm9iamVjdCxcblx0b25EaWFsb2dDb21wbGV0ZTogUHJvcFR5cGVzLmZ1bmMsXG5cdG9uRGlhbG9nQ2FuY2VsOiBQcm9wVHlwZXMuZnVuYyxcblx0Y2xhc3NfdWk6IFByb3BUeXBlcy5vYmplY3QsXG5cdGNsYXNzX3RlbXBsYXRlOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuXG5EaWFsb2cuZGVmYXVsdFByb3BzID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IERpYWxvZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvZGlhbG9ncy9EaWFsb2cuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRm9ybUZpZWxkIGZyb20gJy4uLy4uL2xpYi9Gb3JtRmllbGQnO1xuaW1wb3J0IHsgc2V0TGFiZWxzIH0gZnJvbSAnLi4vLi4vYXNzZXRzL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7IEdMWVBIUyB9IGZyb20gJy4uL3ZpZXdzL0ljb24uanN4JztcbmltcG9ydCBEaWFsb2dIZWFkaW5nIGZyb20gJy4vRGlhbG9nSGVhZGluZy5qc3gnO1xuaW1wb3J0IEZvcm0gZnJvbSAnLi4vdmlld3MvRm9ybS5qc3gnO1xuXG5jb25zdCBoZWFkaW5nc0J5VHlwZSA9IHtcblx0J2VsZW1lbnQnOiB7XG5cdFx0dGV4dDogJ0VsZW1lbnQnLFxuXHRcdGljb246IEdMWVBIUy5UQUdcblx0fSxcblx0J3RleHQnOiB7XG5cdFx0dGV4dDogJ1RleHQgaXRlbScsXG5cdFx0aWNvbjogR0xZUEhTLlRFWFRcblx0fSxcblx0J2F0dHJpYnV0ZSc6IHtcblx0XHR0ZXh0OiAnQXR0cmlidXRlJyxcblx0XHRpY29uOiBHTFlQSFMuUFVaWkxFX1BJRUNFXG5cdH1cbn07XG5cbmNsYXNzIERpYWxvZ0VkaXREcm9wbGV0IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5zdGF0ZSAmJiB0aGlzLnByb3BzLnN0YXRlLmRyb3BsZXRfaWQpIHtcblx0XHRcdHRoaXMuZHJvcGxldCA9IHRoaXMucHJvcHMuY2xhc3NfdWkuZ2V0RHJvcGxldEJ5SWQodGhpcy5wcm9wcy5zdGF0ZS5kcm9wbGV0X2lkKTtcblx0XHR9XG5cblx0XHR0aGlzLm9uRGlhbG9nQ29tcGxldGUgPSB0aGlzLm9uRGlhbG9nQ29tcGxldGUuYmluZCh0aGlzKTtcblx0XHR0aGlzLmRldGFjaEF0dGFjaG1lbnQgPSB0aGlzLmRldGFjaEF0dGFjaG1lbnQuYmluZCh0aGlzKTtcblx0fVxuXG5cdG9uRGlhbG9nQ29tcGxldGUodmFsdWVzKSB7XG5cdFx0dmFyIGRhdGEgPSB7fSxcblx0XHRcdGtleTtcblxuXHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbkRpYWxvZ0NvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBtYXNzYWdlIGRhdGEgYmFjayBpbnRvIGZvcm1hdCByZXBsaWNhdGluZyBEcm9wbGV0LmRhdGEgZm9ybWF0XG5cdFx0XHRmb3IgKGtleSBpbiB2YWx1ZXMpIHtcblx0XHRcdFx0aWYgKHZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gJ2F0dHJzJykge1xuXHRcdFx0XHRcdFx0ZGF0YVtrZXldID0gdmFsdWVzW2tleV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRhdGFba2V5XSA9IHZhbHVlc1trZXldW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGRhdGEgPSBPYmplY3QuZGVlcEFzc2lnbih7fSwgdGhpcy5kcm9wbGV0LmRhdGEsIGRhdGEpO1xuXG5cdFx0XHQvLyBzZW5kIGRhdGEgdG8gY2FsbGJhY2tcblx0XHRcdHRoaXMucHJvcHMub25EaWFsb2dDb21wbGV0ZShkYXRhKTtcblx0XHR9XG5cdH1cblxuXHRkZXRhY2hBdHRhY2htZW50KCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnN0YXRlLmF0dGFjaG1lbnRfaW5kZXggIT09IG51bGwpIHtcblx0XHRcdHRoaXMucHJvcHMuY2xhc3NfdWkuem9uZURldGFjaEF0dGFjaG1lbnQoXG5cdFx0XHRcdHRoaXMucHJvcHMuc3RhdGUuem9uZV9pZCxcblx0XHRcdFx0dGhpcy5wcm9wcy5zdGF0ZS5hdHRhY2htZW50X2luZGV4XG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2F0dGFjaG1lbnRfaW5kZXggaXMgbnVsbCBvciBub3QgZGVmaW5lZC4gQ2Fubm90IGRldGFjaCcpO1xuXHRcdH1cblxuXHRcdHRoaXMucHJvcHMub25EaWFsb2dDYW5jZWwoKTtcblx0fVxuXG5cdGdldEZpZWxkc2V0cygpIHtcblx0XHR2YXIgZmllbGRzZXRzID0gW10sXG5cdFx0XHRhdHRhY2htZW50ID0gbnVsbCxcblx0XHRcdGZpZWxkc2V0LCBmaWVsZCwgYXR0cmlidXRlLCBpdGVtO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuc3RhdGUuYXR0YWNobWVudF9pbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0YXR0YWNobWVudCA9IHRoaXMucHJvcHMuY2xhc3NfdWkuem9uZUdldEF0dGFjaG1lbnQoXG5cdFx0XHRcdHRoaXMucHJvcHMuc3RhdGUuem9uZV9pZCxcblx0XHRcdFx0dGhpcy5wcm9wcy5zdGF0ZS5hdHRhY2htZW50X2luZGV4XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGZvciAoYXR0cmlidXRlIGluIHRoaXMuZHJvcGxldC5lZGl0YWJsZSkge1xuXHRcdFx0ZmllbGRzZXQgPSB7XG5cdFx0XHRcdGtleTogYXR0cmlidXRlLFxuXHRcdFx0XHRsZWdlbmQ6IHNldExhYmVsc1thdHRyaWJ1dGVdLFxuXHRcdFx0XHRmaWVsZHM6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBhZGQgaW5kaWR1YWwgZmllbGRzLCBkZXBlbmRpbmcgb24gZWRpdGFibGUgYXR0cmlidXRlIHR5cGVcblx0XHRcdGlmIChhdHRyaWJ1dGUgPT09ICdhdHRycycpIHtcblx0XHRcdFx0Ly8gdGhlICdhdHRycycgYXR0cmlidXRlLCB3aGljaCBjb250YWlucyBrZXkvdmFsdWUgcGFpcnNcblx0XHRcdFx0Zm9yIChpdGVtIGluIHRoaXMuZHJvcGxldC5lZGl0YWJsZVthdHRyaWJ1dGVdKSB7XG5cdFx0XHRcdFx0ZmllbGQgPSBPYmplY3QuZGVlcEFzc2lnbih7fSwgdGhpcy5kcm9wbGV0LmVkaXRhYmxlW2F0dHJpYnV0ZV1baXRlbV0pO1xuXG5cdFx0XHRcdFx0Ly8gcHJlc2V0IHZhbHVlIGZyb20gYXR0YWNobWVudFxuXHRcdFx0XHRcdGlmIChhdHRhY2htZW50ICE9PSBudWxsICYmXG5cdFx0XHRcdFx0XHRhdHRhY2htZW50LmRhdGEuYXR0cnMgJiZcblx0XHRcdFx0XHRcdGF0dGFjaG1lbnQuZGF0YS5hdHRyc1tpdGVtXSkge1xuXHRcdFx0XHRcdFx0ZmllbGQudmFsdWUgPSBhdHRhY2htZW50LmRhdGEuYXR0cnNbaXRlbV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZmllbGRzZXQuZmllbGRzLnB1c2gobmV3IEZvcm1GaWVsZChcblx0XHRcdFx0XHRcdGl0ZW0sXG5cdFx0XHRcdFx0XHR0aGlzLmRyb3BsZXQuZWRpdGFibGVbYXR0cmlidXRlXVtpdGVtXS50eXBlLFxuXHRcdFx0XHRcdFx0ZmllbGRcblx0XHRcdFx0XHQpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc3RyaW5nIGJhc2VkIGF0dHJpYnV0ZXNcblx0XHRcdFx0ZmllbGQgPSBPYmplY3QuZGVlcEFzc2lnbih7fSwgdGhpcy5kcm9wbGV0LmVkaXRhYmxlW2F0dHJpYnV0ZV0pO1xuXG5cdFx0XHRcdC8vIHByZXNldCB2YWx1ZSBmcm9tIGF0dGFjaG1lbnRcblx0XHRcdFx0aWYgKGF0dGFjaG1lbnQgIT09IG51bGwgJiYgYXR0YWNobWVudC5kYXRhW2F0dHJpYnV0ZV0pIHtcblx0XHRcdFx0XHRmaWVsZC52YWx1ZSA9IGF0dGFjaG1lbnQuZGF0YVthdHRyaWJ1dGVdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmllbGRzZXQuZmllbGRzLnB1c2gobmV3IEZvcm1GaWVsZChcblx0XHRcdFx0XHRhdHRyaWJ1dGUsXG5cdFx0XHRcdFx0dGhpcy5kcm9wbGV0LmVkaXRhYmxlW2F0dHJpYnV0ZV0udHlwZSxcblx0XHRcdFx0XHRmaWVsZFxuXHRcdFx0XHQpKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGZpZWxkc2V0IHRvIGZvcm1cblx0XHRcdGZpZWxkc2V0cy5wdXNoKGZpZWxkc2V0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmllbGRzZXRzO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHZhciBmaWVsZHNldHMgPSB0aGlzLmdldEZpZWxkc2V0cygpLFxuXHRcdFx0YnV0dG9ucyA9IFtdLFxuXHRcdFx0Y2xhc3NlcyA9IFt0aGlzLnByb3BzLnNldHRpbmdzLmNsYXNzZXMuZGlhbG9nLmNvbnRhaW5lcl0sXG5cdFx0XHR0aXRsZSwgbm90ZXM7XG5cblx0XHRjbGFzc2VzLnB1c2goJ2Ryb3BsZXQtJyArIHRoaXMuZHJvcGxldC5kcm9wbGV0VHlwZSk7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5zdGF0ZS5hdHRhY2htZW50X2luZGV4ICE9PSBudWxsKSB7XG5cdFx0XHQvLyBlZGl0aW5nXG5cdFx0XHR0aXRsZSA9ICdFZGl0ICcgKyBoZWFkaW5nc0J5VHlwZVt0aGlzLmRyb3BsZXQuZHJvcGxldFR5cGVdLnRleHQ7XG5cblx0XHRcdGlmIChmaWVsZHNldHMubGVuZ3RoKSB7XG5cdFx0XHRcdG5vdGVzID0gW1xuXHRcdFx0XHRcdCdZb3UgY2FuIGVkaXQgdGhlIERyb3BsZXQgdXNpbmcgdGhlIGZpZWxkcyBiZWxvdy4gJyArXG5cdFx0XHRcdFx0XHQnQ2hhbmdlIHRoZSBiaXRzIHlvdSB3YW50IHRvIGN1c3RvbWlzZSBhbmQgdXNlIOKAnEFkZCBEcm9wbGV04oCdIHdoZW4geW914oCZcmUgZG9uZS4nXG5cdFx0XHRcdF07XG5cblx0XHRcdFx0YnV0dG9ucy5wdXNoKHtcblx0XHRcdFx0XHR0eXBlOiAnc3VibWl0Jyxcblx0XHRcdFx0XHRsYWJlbDogJ0VkaXQgRHJvcGxldCdcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub3RlcyA9IFtcblx0XHRcdFx0XHQnVGhlcmUgaXMgbm90aGluZyB0byBlZGl0IG9uIHRoaXMgRHJvcGxldCwgYnV0IHlvdSBjYW4gcmVtb3ZlIGl0ICcgK1xuXHRcdFx0XHRcdFx0J1dpdGggdGhlIOKAnFJlbW92ZSBEcm9wbGV04oCdIGJ1dHRvbi4nXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cblx0XHRcdGJ1dHRvbnMucHVzaCh7XG5cdFx0XHRcdHR5cGU6ICdnZW5lcmFsJyxcblx0XHRcdFx0bGFiZWw6ICdSZW1vdmUgRHJvcGxldCcsXG5cdFx0XHRcdGNsYXNzTmFtZTogJ2RhbmdlciBwdWxsLWxlZnQnLFxuXHRcdFx0XHRvbkNsaWNrOiB0aGlzLmRldGFjaEF0dGFjaG1lbnRcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBhZGRpbmdcblx0XHRcdHRpdGxlID0gJ0FkZCAnICsgaGVhZGluZ3NCeVR5cGVbdGhpcy5kcm9wbGV0LmRyb3BsZXRUeXBlXS50ZXh0O1xuXHRcdFx0bm90ZXMgPSBbXG5cdFx0XHRcdCdZb3XigJl2ZSBmb3VuZCB0aGUgcmlnaHQgZHJvcCBwbGFjZSB0byBwdXQgdGhpcyBEcm9wbGV0ISAnLFxuXHRcdFx0XHQnRWRpdCBhbnl0aGluZyB5b3Ugd291bGQgbGlrZSB0byBjaGFuZ2UgYW5kIHRoZW4gdXNlIOKAnEVkaXQgRHJvcGxldOKAnS4nXG5cdFx0XHRdO1xuXHRcdFx0YnV0dG9ucyA9IGJ1dHRvbnMuY29uY2F0KHtcblx0XHRcdFx0dHlwZTogJ3N1Ym1pdCcsXG5cdFx0XHRcdGxhYmVsOiAnQWRkIERyb3BsZXQnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRidXR0b25zLnB1c2goe1xuXHRcdFx0dHlwZTogJ2NhbmNlbCcsXG5cdFx0XHRvbkNsaWNrOiB0aGlzLnByb3BzLm9uRGlhbG9nQ2FuY2VsLFxuXHRcdFx0bGFiZWw6ICdDYW5jZWwnXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuam9pbignICcpfT5cblx0XHRcdFx0PERpYWxvZ0hlYWRpbmdcblx0XHRcdFx0XHR0aXRsZT17dGl0bGV9XG5cdFx0XHRcdFx0bm90ZXM9e25vdGVzfVxuXHRcdFx0XHRcdGljb25HbHlwaD17aGVhZGluZ3NCeVR5cGVbdGhpcy5kcm9wbGV0LmRyb3BsZXRUeXBlXS5pY29ufVxuXHRcdFx0XHRcdGNsYXNzTmFtZT17dGhpcy5wcm9wcy5zZXR0aW5ncy5jbGFzc2VzLmRpYWxvZy5oZWFkaW5nfS8+XG5cblx0XHRcdFx0PEZvcm1cblx0XHRcdFx0XHRmaWVsZFNldHM9e2ZpZWxkc2V0c31cblx0XHRcdFx0XHRidXR0b25zPXtidXR0b25zfVxuXHRcdFx0XHRcdG9uU3VibWl0PXt0aGlzLm9uRGlhbG9nQ29tcGxldGV9XG5cdFx0XHRcdFx0b25DYW5jZWw9e3RoaXMucHJvcHMub25EaWFsb2dDYW5jZWx9Lz5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuRGlhbG9nRWRpdERyb3BsZXQucHJvcFR5cGVzID0ge1xuXHRzdGF0ZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRzZXR0aW5nczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRvbkRpYWxvZ0NhbmNlbDogUHJvcFR5cGVzLmZ1bmMsXG5cdG9uRGlhbG9nQ29tcGxldGU6IFByb3BUeXBlcy5mdW5jLFxuXHRjbGFzc191aTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5EaWFsb2dFZGl0RHJvcGxldC5kZWZhdWx0UHJvcHMgPSB7XG5cdG9uRGlhbG9nQ2FuY2VsOiBudWxsLFxuXHRvbkRpYWxvZ0NvbXBsZXRlOiBudWxsLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRGlhbG9nRWRpdERyb3BsZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL2RpYWxvZ3MvRGlhbG9nRWRpdERyb3BsZXQuanN4IiwiaW1wb3J0IFJlYWN0LCB7IFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR0xZUEhTLCBJY29uIH0gZnJvbSAnLi4vdmlld3MvSWNvbi5qc3gnO1xuXG52YXIgRGlhbG9nSGVhZGluZyA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdHZhciBub3RlcyA9IFtdLFxuXHRcdGljb247XG5cblx0cHJvcHMubm90ZXMuZm9yRWFjaCgobm90ZSwgaW5kZXgpID0+IChub3Rlcy5wdXNoKFxuXHRcdDxwIGtleT17J25vdGUtJyArIGluZGV4fT57bm90ZX08L3A+XG5cdCkpKTtcblxuXHRpZiAocHJvcHMuaWNvbkdseXBoKSB7XG5cdFx0aWNvbiA9IDxJY29uIGdseXBoPXtwcm9wcy5pY29uR2x5cGh9Lz47XG5cdH1cblxuXHRyZXR1cm4gKFxuXHRcdDxkaXYgY2xhc3NOYW1lPXtwcm9wcy5jbGFzc05hbWV9PlxuXHRcdFx0PGgyPlxuXHRcdFx0XHR7aWNvbn1cblx0XHRcdFx0PHNwYW4+e3Byb3BzLnRpdGxlfTwvc3Bhbj5cblx0XHRcdDwvaDI+XG5cdFx0XHR7bm90ZXN9XG5cdFx0PC9kaXY+XG5cdCk7XG59O1xuXG5EaWFsb2dIZWFkaW5nLnByb3BUeXBlcyA9IHtcblx0aWNvbkdseXBoOiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcblx0dGl0bGU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcblx0bm90ZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEaWFsb2dIZWFkaW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy9kaWFsb2dzL0RpYWxvZ0hlYWRpbmcuanN4IiwiaW1wb3J0IFJlYWN0LCB7IFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcblxudmFyIEJ1dHRvbiA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdHZhciB0eXBlID0gKHByb3BzLnR5cGUgPT09ICdzdWJtaXQnKSA/ICdzdWJtaXQnIDogJ2J1dHRvbicsXG5cdFx0Y2xhc3NlcyA9IFtwcm9wcy5jbGFzc05hbWVdLFxuXHRcdG9uQ2xpY2sgPSBwcm9wcy5vbkNsaWNrO1xuXG5cdGlmIChwcm9wcy50eXBlID09PSAnY2FuY2VsJykge1xuXHRcdGNsYXNzZXMucHVzaCgnY2FuY2VsJyk7XG5cdFx0b25DbGljayA9IHByb3BzLm9uQ2FuY2VsO1xuXHR9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdzdWJtaXQnKSB7XG5cdFx0Y2xhc3Nlcy5wdXNoKCdwcmltYXJ5Jyk7XG5cdH1cblxuXHRyZXR1cm4gKFxuXHRcdDxidXR0b25cblx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5qb2luKCcgJyl9XG5cdFx0XHRvbkNsaWNrPXtvbkNsaWNrfVxuXHRcdFx0dHlwZT17dHlwZX0+XG5cdFx0XHR7cHJvcHMubGFiZWx9XG5cdFx0PC9idXR0b24+XG5cdCk7XG59O1xuXG5CdXR0b24ucHJvcFR5cGVzID0ge1xuXHR0eXBlOiBQcm9wVHlwZXMub25lT2YoWydzdWJtaXQnLCAnY2FuY2VsJywgJ2dlbmVyYWwnXSkuaXNSZXF1aXJlZCxcblx0bGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcblx0Y2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcblx0b25DYW5jZWw6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL0J1dHRvbi5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IGNvbGxlY3RSZWYgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IERyb3Bab25lIGZyb20gJy4uLy4uL2xpYi9Ecm9wWm9uZSc7XG5pbXBvcnQgRHJvcFpvbmVBdHRhY2htZW50IGZyb20gJy4vRHJvcFpvbmVBdHRhY2htZW50LmpzeCc7XG5cbmNsYXNzIERyb3Bab25lQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLm15cmVmcyA9IHt9O1xuXHRcdHRoaXMuYXR0YWNobWVudENsaWNrID0gdGhpcy5hdHRhY2htZW50Q2xpY2suYmluZCh0aGlzKTtcblx0XHR0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbk1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLnByb3BzLm9uTW91bnQoJ2Ryb3B6b25lJywgdGhpcy5wcm9wcy56b25lLmlkKTtcblx0XHR9XG5cdH1cblxuXHRvbkNsaWNrKGV2ZW50KSB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQsIHRoaXMucHJvcHMuem9uZSk7XG5cdH1cblxuXHRhdHRhY2htZW50Q2xpY2soZXZlbnQsIGRyb3BsZXQsIGF0dGFjaG1lbnRJbmRleCkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbkF0dGFjaG1lbnRDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhpcy5wcm9wcy5vbkF0dGFjaG1lbnRDbGljayhkcm9wbGV0LCB0aGlzLnByb3BzLnpvbmUsIGF0dGFjaG1lbnRJbmRleCk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyQWN0aXZlQXR0YWNobWVudHMoKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gW107XG5cblx0XHR0aGlzLnByb3BzLmFjdGl2ZUF0dGFjaG1lbnRzLmZvckVhY2goKGF0dGFjaG1lbnQsIGluZGV4KSA9PiB7XG5cdFx0XHRjaGlsZHJlbi5wdXNoKFxuXHRcdFx0XHQ8RHJvcFpvbmVBdHRhY2htZW50XG5cdFx0XHRcdFx0a2V5PXthdHRhY2htZW50LmRyb3BsZXRfaWQgKyAnLWF0dGFjaG1lbnQtJyArIGluZGV4fVxuXHRcdFx0XHRcdGF0dGFjaG1lbnRJbmRleD17aW5kZXh9XG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5hdHRhY2htZW50Q2xpY2t9XG5cdFx0XHRcdFx0ZHJvcGxldD17dGhpcy5wcm9wcy5jbGFzc191aS5nZXREcm9wbGV0QnlJZChhdHRhY2htZW50LmRyb3BsZXRfaWQpfVxuXHRcdFx0XHRcdHpvbmU9e3RoaXMucHJvcHMuem9uZX1cblx0XHRcdFx0XHRkYXRhPXthdHRhY2htZW50LmRhdGF9Lz5cblx0XHRcdCk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY2hpbGRyZW47XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0dmFyIGtleSA9IHRoaXMucHJvcHMuem9uZS5pZCArICctem9uZScsXG5cdFx0XHR0YXJnZXRfa2V5ID0gdGhpcy5wcm9wcy56b25lLmlkICsgJy10YXJnZXQnLFxuXHRcdFx0dGFyZ2V0X2NsYXNzO1xuXG5cdFx0dGFyZ2V0X2NsYXNzID0gKHRoaXMucHJvcHMuYWN0aXZlQXR0YWNobWVudHMubGVuZ3RoIDwgdGhpcy5wcm9wcy56b25lLm1heEF0dGFjaG1lbnRzKSA/XG5cdFx0XHR0aGlzLnByb3BzLnNldHRpbmdzLmNsYXNzZXMuZHJvcHpvbmVfdGFyZ2V0IDpcblx0XHRcdHRoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5kcm9wem9uZV90YXJnZXQgKyAnICcgKyB0aGlzLnByb3BzLnNldHRpbmdzLmNsYXNzZXMuaGlkZGVuO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxzcGFuXG5cdFx0XHRcdGtleT17a2V5fVxuXHRcdFx0XHRjbGFzc05hbWU9e3RoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5kcm9wem9uZX1cblx0XHRcdFx0cmVmPXtjb2xsZWN0UmVmKHRoaXMucHJvcHMsIFsnZHJvcHpvbmUnXSwgdGhpcy5wcm9wcy56b25lLmlkKX1cblx0XHRcdFx0ZGF0YS1pZD17dGhpcy5wcm9wcy56b25lLmlkfVxuXHRcdFx0XHRkYXRhLWF0dGFjaG1lbnQ9e3RoaXMucHJvcHMuem9uZS5hdHRhY2htZW50SWR9PlxuXHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImF0dGFjaG1lbnRzXCI+XG5cdFx0XHRcdFx0e3RoaXMucmVuZGVyQWN0aXZlQXR0YWNobWVudHMoKX1cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJ0YXJnZXQtb3V0ZXJcIj5cblx0XHRcdFx0XHQ8c3BhbiBrZXk9e3RhcmdldF9rZXl9XG5cdFx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLm9uQ2xpY2t9XG5cdFx0XHRcdFx0XHRyZWY9e2NvbGxlY3RSZWYodGhpcy5wcm9wcywgWydkcm9wem9uZV90YXJnZXQnXSwgdGhpcy5wcm9wcy56b25lLmlkKX1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT17dGFyZ2V0X2NsYXNzfT5cblx0XHRcdFx0XHRcdFx0PGI+e3RoaXMucHJvcHMuc2V0dGluZ3MuZHJvcFpvbmUubGFiZWx9PC9iPlxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0KTtcblx0fVxufVxuXG5Ecm9wWm9uZUNvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG5cdHpvbmU6IFByb3BUeXBlcy5pbnN0YW5jZU9mKERyb3Bab25lKS5pc1JlcXVpcmVkLFxuXHRzZXR0aW5nczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRhY3RpdmVBdHRhY2htZW50czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG5cdG9uTW91bnQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdG9uQXR0YWNobWVudENsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRyZWZDb2xsZWN0b3I6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdGNsYXNzX3VpOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERyb3Bab25lQ29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9Ecm9wWm9uZS5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBUZW1wbGF0ZSBmcm9tICcuLi8uLi9saWIvVGVtcGxhdGUnO1xuaW1wb3J0IERyb3BsZXQgZnJvbSAnLi4vLi4vbGliL0Ryb3BsZXQnO1xuaW1wb3J0IERyb3Bab25lIGZyb20gJy4uLy4uL2xpYi9Ecm9wWm9uZSc7XG5cbmNsYXNzIERyb3Bab25lQXR0YWNobWVudCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0dGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG5cdH1cblxuXHRvbkNsaWNrKGV2ZW50KSB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdHRoaXMucHJvcHMub25DbGljayhcblx0XHRcdGV2ZW50LFxuXHRcdFx0dGhpcy5wcm9wcy5kcm9wbGV0LFxuXHRcdFx0dGhpcy5wcm9wcy5hdHRhY2htZW50SW5kZXhcblx0XHQpO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHZhciBjbGFzc05hbWUgPSAnZHJvcHpvbmUtYXR0YWNobWVudCcsXG5cdFx0XHRkYXRhO1xuXG5cdFx0Ly8gbWVyZ2UgZWRpdGVkIGRhdGEgd2l0aCBkcm9wbGV0IGRhdGFcblx0XHRkYXRhID0gT2JqZWN0LmRlZXBBc3NpZ24oe30sIHRoaXMucHJvcHMuZHJvcGxldC5kYXRhLCB0aGlzLnByb3BzLmRhdGEpO1xuXG5cdFx0Ly8gc2V0IGNsYXNzbmFtZVxuXHRcdGNsYXNzTmFtZSArPSAnICcgKyB0aGlzLnByb3BzLmRyb3BsZXQuZHJvcGxldFR5cGU7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PHNwYW5cblx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc05hbWV9XG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMub25DbGlja30+XG5cdFx0XHRcdHtUZW1wbGF0ZS5yZW5kZXJEcm9wbGV0KHRoaXMucHJvcHMuZHJvcGxldCwgZGF0YSwgdGhpcy5wcm9wcy56b25lLCBmYWxzZSl9XG5cdFx0XHQ8L3NwYW4+XG5cdFx0KTtcblx0fVxufVxuXG5Ecm9wWm9uZUF0dGFjaG1lbnQucHJvcFR5cGVzID0ge1xuXHRkcm9wbGV0OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEcm9wbGV0KS5pc1JlcXVpcmVkLFxuXHR6b25lOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEcm9wWm9uZSkuaXNSZXF1aXJlZCxcblx0YXR0YWNobWVudEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG5cdG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdGRhdGE6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERyb3Bab25lQXR0YWNobWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvRHJvcFpvbmVBdHRhY2htZW50LmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgY29sbGVjdFJlZiB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgRHJvcGxldCBmcm9tICcuLi8uLi9saWIvRHJvcGxldCc7XG5pbXBvcnQgeyBHTFlQSFMsIEljb24gfSBmcm9tICcuL0ljb24uanN4JztcblxuY29uc3QgZHJvcGxldFR5cGVUb0dseXBocyA9IHtcblx0J3RleHQnOiBHTFlQSFMuVEVYVCxcblx0J2VsZW1lbnQnOiBHTFlQSFMuVEFHLFxuXHQnYXR0cmlidXRlJzogR0xZUEhTLlBVWlpMRV9QSUVDRVxufTtcblxuY2xhc3MgRHJvcGxldENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0dGhpcy5teXJlZnMgPSB7fTtcblx0XHR0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbk1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLnByb3BzLm9uTW91bnQoJ2Ryb3BsZXQnLCB0aGlzLnByb3BzLmRyb3BsZXQuaWQpO1xuXHRcdH1cblx0fVxuXG5cdG9uQ2xpY2soZXZlbnQpIHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHRoaXMucHJvcHMub25DbGljayhldmVudCwgdGhpcy5wcm9wcy5kcm9wbGV0KTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtcblx0XHRcdHRoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5kcm9wbGV0Lm5vZGUsXG5cdFx0XHQndHlwZS0nICsgdGhpcy5wcm9wcy5kcm9wbGV0LmRyb3BsZXRUeXBlXG5cdFx0XTtcblxuXHRcdGlmICh0aGlzLnByb3BzLmFjdGl2ZSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKHRoaXMucHJvcHMuc2V0dGluZ3MuY2xhc3Nlcy5kcm9wbGV0LmFjdGl2ZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxhIGhyZWY9XCIjXCJcblx0XHRcdFx0aWQ9e3RoaXMucHJvcHMuZHJvcGxldC5pZH1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLmpvaW4oJyAnKX1cblx0XHRcdFx0b25DbGljaz17dGhpcy5vbkNsaWNrfVxuXHRcdFx0XHRyZWY9e2NvbGxlY3RSZWYodGhpcy5wcm9wcywgWydkcm9wbGV0J10sIHRoaXMucHJvcHMuZHJvcGxldC5pZCl9PlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJsYWJlbFwiPlxuXHRcdFx0XHRcdDxJY29uIGdseXBoPXtkcm9wbGV0VHlwZVRvR2x5cGhzW3RoaXMucHJvcHMuZHJvcGxldC5kcm9wbGV0VHlwZV19Lz5cblx0XHRcdFx0XHR7dGhpcy5wcm9wcy5kcm9wbGV0Lm5hbWV9XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvYT5cblx0XHQpO1xuXHR9XG59XG5cbkRyb3BsZXRDb21wb25lbnQucHJvcFR5cGVzID0ge1xuXHRhY3RpdmU6IFByb3BUeXBlcy5ib29sLFxuXHRzZXR0aW5nczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRkcm9wbGV0OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihEcm9wbGV0KS5pc1JlcXVpcmVkLFxuXHRvbk1vdW50OiBQcm9wVHlwZXMuZnVuYyxcblx0b25DbGljazogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERyb3BsZXRDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL0Ryb3BsZXQuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRm9ybUZpZWxkIGZyb20gJy4uLy4uL2xpYi9Gb3JtRmllbGQnO1xuaW1wb3J0IFRleHRGaWVsZCBmcm9tICcuL2ZpZWxkcy9UZXh0RmllbGQuanN4JztcbmltcG9ydCBEcm9wRG93biBmcm9tICcuL2ZpZWxkcy9Ecm9wRG93bi5qc3gnO1xuXG5jb25zdCBGaWVsZENvbXBvbmVudHMgPSB7XG5cdCd0ZXh0JzogVGV4dEZpZWxkLFxuXHQnZHJvcGRvd24nOiBEcm9wRG93blxufTtcblxuY2xhc3MgRmllbGRzZXQgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHZhciBmb3JtVmFsdWVzID0ge307XG5cblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHQvLyBzZXQgZGVmYXVsdCBzdGF0ZSBmb3IgZmllbGRzIGJhc2VkIG9uIG9yaWdpbmFsIHZhbHVlc1xuXHRcdHRoaXMucHJvcHMuZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PlxuXHRcdFx0KGZvcm1WYWx1ZXNbZmllbGQubmFtZV0gPSBmaWVsZC52YWx1ZSB8fCAnJylcblx0XHQpO1xuXG5cdFx0Ly8gc2V0IGRlZmF1bHQgZm9ybSB2YWx1ZSBzdGF0ZVxuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRmb3JtVmFsdWVzXG5cdFx0fTtcblxuXHRcdC8vIGJpbmQgZnVuY3Rpb25zIGZvciBldmVudHNcblx0XHR0aGlzLmVsZW1lbnRDaGFuZ2UgPSB0aGlzLmVsZW1lbnRDaGFuZ2UuYmluZCh0aGlzKTtcblx0fVxuXG5cdGZpZWxkcygpIHtcblx0XHR2YXIgQ29tcG9uZW50LFxuXHRcdFx0b3V0cHV0ID0gW107XG5cblx0XHR0aGlzLnByb3BzLmZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuXHRcdFx0dmFyIGtleSA9ICdmaWVsZC0nICsgZmllbGQubmFtZTtcblxuXHRcdFx0Q29tcG9uZW50ID0gRmllbGRDb21wb25lbnRzW2ZpZWxkLnR5cGVdO1xuXG5cdFx0XHRzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcblx0XHRcdGNhc2UgJ3RleHQnOlxuXHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHQ8Q29tcG9uZW50IGtleT17a2V5fVxuXHRcdFx0XHRcdFx0ZmllbGQ9e2ZpZWxkfVxuXHRcdFx0XHRcdFx0b25DaGFuZ2U9e3RoaXMuZWxlbWVudENoYW5nZX1cblx0XHRcdFx0XHRcdHZhbHVlPXt0aGlzLnN0YXRlLmZvcm1WYWx1ZXNbZmllbGQubmFtZV19Lz5cblx0XHRcdFx0KTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ2Ryb3Bkb3duJzpcblx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0PENvbXBvbmVudCBrZXk9e2tleX1cblx0XHRcdFx0XHRcdGZpZWxkPXtmaWVsZH1cblx0XHRcdFx0XHRcdG9uQ2hhbmdlPXt0aGlzLmVsZW1lbnRDaGFuZ2V9XG5cdFx0XHRcdFx0XHR2YWx1ZT17dGhpcy5zdGF0ZS5mb3JtVmFsdWVzW2ZpZWxkLm5hbWVdfS8+XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0ZWxlbWVudENoYW5nZShldmVudCkge1xuXHRcdHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQsXG5cdFx0XHRmb3JtVmFsdWVzID0gT2JqZWN0LmRlZXBBc3NpZ24oe30sIHRoaXMuc3RhdGUuZm9ybVZhbHVlcyk7XG5cblx0XHRmb3JtVmFsdWVzW3RhcmdldC5uYW1lXSA9IHRhcmdldC52YWx1ZTtcblxuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0Zm9ybVZhbHVlczogZm9ybVZhbHVlc1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5wcm9wcy5vbkZpZWxkVXBkYXRlKHRoaXMucHJvcHMuc2V0LCB0YXJnZXQubmFtZSwgdGFyZ2V0LnZhbHVlLCBmb3JtVmFsdWVzKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGZpZWxkc2V0PlxuXHRcdFx0XHQ8bGVnZW5kPnt0aGlzLnByb3BzLmxlZ2VuZH08L2xlZ2VuZD5cblx0XHRcdFx0e3RoaXMuZmllbGRzKCl9XG5cdFx0XHQ8L2ZpZWxkc2V0PlxuXHRcdCk7XG5cdH1cbn1cblxuRmllbGRzZXQucHJvcFR5cGVzID0ge1xuXHRzZXQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcblx0b25GaWVsZFVwZGF0ZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblx0bGVnZW5kOiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRmaWVsZHM6IFByb3BUeXBlcy5hcnJheU9mKFJlYWN0LlByb3BUeXBlcy5pbnN0YW5jZU9mKEZvcm1GaWVsZCkpXG59O1xuXG5GaWVsZHNldC5kZWZhdWx0UHJvcHMgPSB7XG5cdG9uRmllbGRVcGRhdGU6ICgpID0+IHt9LFxuXHRmaWVsZHM6IHt9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGaWVsZHNldDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvRmllbGRzZXQuanN4IiwiLyoqXG4gKiBAdHlwZWRlZiBGb3JtT25TdWJtaXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBmb3JtVmFsdWVzIC0gdGhlIGN1cnJlbnQgdmFsdWVzIG9mIHRoZSBmb3JtIGVsZW1lbnRzLCBhcyBhbiBvYmplY3QuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBGb3JtRmllbGRTZXRzXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFuIGFycmF5IG9mIGZpZWxkc2V0cyDigJQgZWFjaCBpdGVtIG9mIHdoaWNoIGNvbnRhaW5zIGFuIG9iamVjdCBkZWZpbmluZyBhXG4gKiBzaW5nbGUgZmllbGRzZXQuIFNlZSB7QGxpbmsgRm9ybUZpZWxkc2V0fS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmllbGRzZXRzID0gW1xuICogXHR7QGxpbmsgRm9ybUZpZWxkU2V0fS4uLlxuICogXTtcbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCBkZWZpbmluZyBhIHNpbmdsZSBmaWVsZHNldC5cbiAqIEB0eXBlZGVmIEZvcm1GaWVsZFNldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleSAtIFVuaXF1ZSBrZXkgdmFsdWUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGVnZW5kIC0gTGVnZW5kIGxhYmVsLlxuICogQHByb3BlcnR5IHtvYmplY3R9IGZpZWxkcyAtIEZpZWxkcyB3aXRoaW4gdGhlIGZpZWxkc2V0LiBUaGUga2V5cyBvZiB3aGljaFxuICogc2hvdWxkIHJlcHJlc2VudCB0aGUgbmFtZSBvZiB0aGUgZmllbGQsIHdpdGggdGhlIHZhbHVlcyBiZWluZyBvbmUgb2ZcbiAqIHtAbGluayBGb3JtRmllbGR9IGVhY2guXG4gKiBAZXhhbXBsZVxuICogdmFyIGZpZWxkc2V0ID0gW1xuICogXHR7QGxpbmsgRm9ybUZpZWxkfS4uLlxuICogXVxuICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBGaWVsZHNldCBmcm9tICcuL0ZpZWxkc2V0LmpzeCc7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4vQnV0dG9uLmpzeCc7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUYWtlcyBhIGZvcm0gc3BlY2lmaWNhdGlvbiBhbmQgcHJvZHVjZXMgYW4gSFRNTCBmb3JtLlxuICogU2VlIHtAbGluayBGb3JtLnByb3BUeXBlc30gZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAqL1xuY2xhc3MgRm9ybSBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0dmFyIGZvcm1WYWx1ZXMgPSB7fTtcblxuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdC8vIHNldCBkZWZhdWx0IHN0YXRlIGZvciBmaWVsZHMgYmFzZWQgb24gb3JpZ2luYWwgdmFsdWVzXG5cdFx0dGhpcy5wcm9wcy5maWVsZFNldHMuZm9yRWFjaCgoc2V0KSA9PiB7XG5cdFx0XHRmb3JtVmFsdWVzW3NldC5rZXldID0ge307XG5cblx0XHRcdHNldC5maWVsZHMuZm9yRWFjaCgoZmllbGQpID0+XG5cdFx0XHRcdChmb3JtVmFsdWVzW3NldC5rZXldW2ZpZWxkLm5hbWVdID0gZmllbGQudmFsdWUpXG5cdFx0XHQpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gc2V0IGRlZmF1bHQgZm9ybSB2YWx1ZSBzdGF0ZVxuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRmb3JtVmFsdWVzXG5cdFx0fTtcblxuXHRcdC8vIGJpbmQgZnVuY3Rpb25zIGZvciBldmVudHNcblx0XHR0aGlzLmVsZW1lbnRDaGFuZ2UgPSB0aGlzLmVsZW1lbnRDaGFuZ2UuYmluZCh0aGlzKTtcblx0fVxuXG5cdHZhbHVlU2V0KHZhbHVlcywgbm9kZSkge1xuXHRcdHZhciBub2RlcyA9IFtdLCBrZXk7XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG5cdFx0XHR2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKFxuXHRcdFx0XHRcdDxub2RlIHZhbHVlPXt2YWx1ZX0+e3ZhbHVlfTwvbm9kZT5cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAoa2V5IGluIHZhbHVlcykge1xuXHRcdFx0XHRub2Rlcy5wdXNoKFxuXHRcdFx0XHRcdDxub2RlIHZhbHVlPXtrZXl9Pnt2YWx1ZXNba2V5XX08L25vZGU+XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vZGVzO1xuXHR9XG5cblx0ZmllbGRTZXRzKCkge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblxuXHRcdHRoaXMucHJvcHMuZmllbGRTZXRzLmZvckVhY2goKHNldCkgPT4ge1xuXHRcdFx0Y29uc3Qga2V5ID0gJ2ZpZWxkc2V0LScgKyBzZXQua2V5O1xuXG5cdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0PEZpZWxkc2V0XG5cdFx0XHRcdFx0a2V5PXtrZXl9XG5cdFx0XHRcdFx0c2V0PXtzZXQua2V5fVxuXHRcdFx0XHRcdGZpZWxkcz17c2V0LmZpZWxkc31cblx0XHRcdFx0XHRsZWdlbmQ9e3NldC5sZWdlbmR9XG5cdFx0XHRcdFx0b25GaWVsZFVwZGF0ZT17dGhpcy5lbGVtZW50Q2hhbmdlfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHQpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGVsZW1lbnRDaGFuZ2Uoc2V0LCBuYW1lLCB2YWx1ZSwgdmFsdWVzX3N0YXRlKSB7XG5cdFx0dmFyIHNldHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLmZvcm1WYWx1ZXMpO1xuXG5cdFx0c2V0c1tzZXRdID0gdmFsdWVzX3N0YXRlO1xuXG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRmb3JtVmFsdWVzOiBzZXRzXG5cdFx0fSk7XG5cdH1cblxuXHRvblN1Ym1pdChldmVudCkge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0dGhpcy5wcm9wcy5vblN1Ym1pdCh0aGlzLnN0YXRlLmZvcm1WYWx1ZXMpO1xuXHR9XG5cblx0Z2V0QnV0dG9ucygpIHtcblx0XHR2YXIgYnV0dG9ucyA9IFtdO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuYnV0dG9ucyAmJiB0aGlzLnByb3BzLmJ1dHRvbnMubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLnByb3BzLmJ1dHRvbnMuZm9yRWFjaCgoYnV0dG9uLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRidXR0b25zLnB1c2goXG5cdFx0XHRcdFx0PEJ1dHRvblxuXHRcdFx0XHRcdFx0a2V5PXsnYnV0dG9uLScgKyBpbmRleH1cblx0XHRcdFx0XHRcdHR5cGU9e2J1dHRvbi50eXBlfVxuXHRcdFx0XHRcdFx0bGFiZWw9e2J1dHRvbi5sYWJlbH1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT17YnV0dG9uLmNsYXNzTmFtZX1cblx0XHRcdFx0XHRcdG9uQ2FuY2VsPXt0aGlzLnByb3BzLm9uQ2FuY2VsfVxuXHRcdFx0XHRcdFx0b25DbGljaz17YnV0dG9uLm9uQ2xpY2t9Lz5cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBidXR0b25zO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8Zm9ybSBhY3Rpb249XCJcIiBvblN1Ym1pdD17dGhpcy5vblN1Ym1pdC5iaW5kKHRoaXMpfT5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmaWVsZHNcIj5cblx0XHRcdFx0XHR7dGhpcy5maWVsZFNldHMoKX1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxmaWVsZHNldCBjbGFzc05hbWU9XCJidXR0b25zXCI+XG5cdFx0XHRcdFx0e3RoaXMuZ2V0QnV0dG9ucygpfVxuXHRcdFx0XHQ8L2ZpZWxkc2V0PlxuXHRcdFx0PC9mb3JtPlxuXHRcdCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBvbkNhbmNlbCAtIGludm9rZWQgd2hlbiB0aGUgZm9ybSBpcyBjYW5jZWxsZWRcbiAqIEBwcm9wZXJ0eSB7Rm9ybU9uU3VibWl0fSBvblN1Ym1pdCAtIGludm9rZWQgd2hlbiB0aGUgZm9ybSBpcyBzdWJtaXR0ZWRcbiAqIEBwcm9wZXJ0eSB7Rm9ybUZpZWxkU2V0c30gZmllbGRTZXRzIC0gZmllbGRzZXRzIGZvciBkaXNwbGF5XG4gKi9cbkZvcm0ucHJvcFR5cGVzID0ge1xuXHRvbkNhbmNlbDogUHJvcFR5cGVzLmZ1bmMsXG5cdG9uU3VibWl0OiBQcm9wVHlwZXMuZnVuYyxcblx0ZmllbGRTZXRzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuXHRcdGtleTogUHJvcFR5cGVzLnN0cmluZyxcblx0XHRsZWdlbmQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cdFx0ZmllbGRzOiBQcm9wVHlwZXMuYXJyYXlcblx0fSkpLFxuXHRidXR0b25zOiBQcm9wVHlwZXMuYXJyYXlcbn07XG5cbkZvcm0uZGVmYXVsdFByb3BzID0ge1xuXHRvbkNhbmNlbDogKCkgPT4ge30sXG5cdG9uU3VibWl0OiAoKSA9PiB7fSxcblx0ZmllbGRTZXRzOiB7fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRm9ybTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvRm9ybS5qc3giLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRHJvcGxldCBmcm9tICcuL0Ryb3BsZXQuanN4JztcblxuY2xhc3MgUGFsbGV0IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cdH1cblxuXHRnZXRJdGVtcygpIHtcblx0XHR2YXIgaXRlbXMgPSBbXTtcblxuXHRcdGlmICh0aGlzLnByb3BzLmRhdGEucGFsbGV0KSB7XG5cdFx0XHR0aGlzLnByb3BzLmRhdGEucGFsbGV0LmZvckVhY2goKGRyb3BsZXQpID0+IHtcblx0XHRcdFx0aXRlbXMucHVzaChcblx0XHRcdFx0XHQ8RHJvcGxldCBkcm9wbGV0PXtkcm9wbGV0fVxuXHRcdFx0XHRcdFx0YWN0aXZlPXt0aGlzLnByb3BzLmFjdGl2ZURyb3BsZXRJZCA9PT0gZHJvcGxldC5pZH1cblx0XHRcdFx0XHRcdHNldHRpbmdzPXt0aGlzLnByb3BzLnNldHRpbmdzfVxuXHRcdFx0XHRcdFx0b25Nb3VudD17dGhpcy5wcm9wcy5vbk1vdW50fVxuXHRcdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy5vbkRyb3BsZXRDbGlja31cblx0XHRcdFx0XHRcdHJlZkNvbGxlY3Rvcj17dGhpcy5wcm9wcy5yZWZDb2xsZWN0b3J9XG5cdFx0XHRcdFx0XHRrZXk9e2Ryb3BsZXQuaWR9Lz5cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtcztcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PHNlY3Rpb24gY2xhc3NOYW1lPVwicGFsbGV0XCI+XG5cdFx0XHRcdHt0aGlzLmdldEl0ZW1zLmFwcGx5KHRoaXMpfVxuXHRcdFx0PC9zZWN0aW9uPlxuXHRcdCk7XG5cdH1cbn1cblxuUGFsbGV0LnByb3BUeXBlcyA9IHtcblx0Ly8gZnJvbSBQYWxsZXRDb250YWluZXJcblx0YWN0aXZlRHJvcGxldElkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cblx0Ly8gZnJvbSBDYW52YXNcblx0ZGF0YTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRzZXR0aW5nczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHRvbk1vdW50OiBQcm9wVHlwZXMuZnVuYyxcblx0b25Ecm9wbGV0Q2xpY2s6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdHJlZkNvbGxlY3RvcjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cblBhbGxldC5kZWZhdWx0UHJvcHMgPSB7XG5cdGRhdGE6IHtcblx0XHRwYWxsZXQ6IFtdXG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFBhbGxldDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvUGFsbGV0LmpzeCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgY29sbGVjdFJlZiB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgRHJvcFpvbmUgZnJvbSAnLi9Ecm9wWm9uZS5qc3gnO1xuXG5jbGFzcyBUZW1wbGF0ZSBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0aWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uTW91bnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMucHJvcHMub25Nb3VudCgndGVtcGxhdGUnKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXNlcyBzdGF0ZSAoZnJvbSBwcm9wcy56b25lcykgdG8gYXNjZXJ0YWluIHRoZSBhdHRhY2htZW50c1xuXHQgKi9cblx0Z2V0Wm9uZUF0dGFjaG1lbnRzKGRyb3B6b25lX2lkKSB7XG5cdFx0dmFyIHpvbmUsXG5cdFx0XHRhdHRhY2htZW50cyA9IFtdO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuem9uZXMgJiYgKHpvbmUgPSB0aGlzLnByb3BzLnpvbmVzW2Ryb3B6b25lX2lkXSkpIHtcblx0XHRcdGF0dGFjaG1lbnRzID0gem9uZS5hdHRhY2htZW50cztcblx0XHR9XG5cblx0XHRyZXR1cm4gYXR0YWNobWVudHM7XG5cdH1cblxuXHRnZXRUZW1wbGF0ZSgpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSBbXTtcblxuXHRcdHRoaXMucHJvcHMudGVtcGxhdGUuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcblx0XHRcdHZhciBrZXk7XG5cblx0XHRcdHN3aXRjaCAobm9kZS50eXBlKSB7XG5cdFx0XHRjYXNlICd0ZXh0Jzpcblx0XHRcdFx0a2V5ID0gJ2ZyYWdtZW50LScgKyBpbmRleDtcblxuXHRcdFx0XHRjaGlsZHJlbi5wdXNoKFxuXHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRrZXk9e2tleX1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT17dGhpcy5wcm9wcy5zZXR0aW5ncy5jbGFzc2VzLmNvbXBvbmVudH0+e25vZGUuY29udGVudH08L3NwYW4+XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdkcm9wem9uZSc6XG5cdFx0XHRcdGNoaWxkcmVuLnB1c2goXG5cdFx0XHRcdFx0PERyb3Bab25lXG5cdFx0XHRcdFx0XHRrZXk9e25vZGUuem9uZS5pZH1cblx0XHRcdFx0XHRcdHpvbmU9e25vZGUuem9uZX1cblx0XHRcdFx0XHRcdHNldHRpbmdzPXt0aGlzLnByb3BzLnNldHRpbmdzfVxuXHRcdFx0XHRcdFx0YWN0aXZlQXR0YWNobWVudHM9e3RoaXMuZ2V0Wm9uZUF0dGFjaG1lbnRzKG5vZGUuem9uZS5pZCl9XG5cdFx0XHRcdFx0XHRyZWZDb2xsZWN0b3I9e3RoaXMucHJvcHMucmVmQ29sbGVjdG9yfVxuXHRcdFx0XHRcdFx0b25Nb3VudD17dGhpcy5wcm9wcy5vbk1vdW50fVxuXHRcdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy5vbkRyb3Bab25lQ2xpY2t9XG5cdFx0XHRcdFx0XHRvbkF0dGFjaG1lbnRDbGljaz17dGhpcy5wcm9wcy5vbkF0dGFjaG1lbnRDbGlja31cblx0XHRcdFx0XHRcdGNsYXNzX3VpPXt0aGlzLnByb3BzLmNsYXNzX3VpfS8+XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNoaWxkcmVuO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8c2VjdGlvbiBjbGFzc05hbWU9XCJ0ZW1wbGF0ZVwiXG5cdFx0XHRcdHJlZj17Y29sbGVjdFJlZih0aGlzLnByb3BzLCAndGVtcGxhdGUnKX0+XG5cdFx0XHRcdDxwcmU+XG5cdFx0XHRcdFx0PGNvZGUgY2xhc3NOYW1lPVwiaHRtbFwiXG5cdFx0XHRcdFx0XHRyZWY9e2NvbGxlY3RSZWYodGhpcy5wcm9wcywgJ3RlbXBsYXRlX2lubmVyJyl9PlxuXHRcdFx0XHRcdFx0e3RoaXMuZ2V0VGVtcGxhdGUoKX1cblx0XHRcdFx0XHQ8L2NvZGU+XG5cdFx0XHRcdDwvcHJlPlxuXHRcdFx0PC9zZWN0aW9uPlxuXHRcdCk7XG5cdH1cbn1cblxuVGVtcGxhdGUucHJvcFR5cGVzID0ge1xuXHQvLyBmcm9tIFRlbXBsYXRlQ29udGFpbmVyXG5cdHpvbmVzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cblx0Ly8gZnJvbSBDYW52YXNcblx0c2V0dGluZ3M6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblx0dGVtcGxhdGU6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuXHRvbk1vdW50OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRvbkF0dGFjaG1lbnRDbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblx0b25Ecm9wWm9uZUNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXHRyZWZDb2xsZWN0b3I6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cdGNsYXNzX3VpOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblRlbXBsYXRlLmRlZmF1bHRQcm9wcyA9IHtcblx0dGVtcGxhdGU6ICcnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZW1wbGF0ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvVGVtcGxhdGUuanN4IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29sbGVjdFJlZiB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5cbmNsYXNzIFZpZXcgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbk1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLnByb3BzLm9uTW91bnQoJ3ZpZXdfZnJhbWUnKTtcblx0XHR9XG5cdH1cblxuXHRzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XG5cdFx0Ly8gbm8uIHJlbG9hZHMvdXBkYXRlcyBhcmUgaGFuZGxlZCBieSB0aGUgdmlldyBjbGFzc1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PHNlY3Rpb24gY2xhc3NOYW1lPVwidmlld1wiXG5cdFx0XHRcdHJlZj17Y29sbGVjdFJlZih0aGlzLnByb3BzLCAndmlldycpfT5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJkcmFnLW1hc2tcIj48L2Rpdj5cblx0XHRcdFx0PGlmcmFtZSByZWY9e2NvbGxlY3RSZWYodGhpcy5wcm9wcywgJ3ZpZXdfZnJhbWUnKX1cblx0XHRcdFx0XHRzcmM9e3RoaXMucHJvcHMuc2V0dGluZ3Mudmlldy5zcmN9PjwvaWZyYW1lPlxuXHRcdFx0PC9zZWN0aW9uPlxuXHRcdCk7XG5cdH1cbn1cblxuVmlldy5wcm9wVHlwZXMgPSB7XG5cdHNldHRpbmdzOiBQcm9wVHlwZXMub2JqZWN0LFxuXHRvbk1vdW50OiBQcm9wVHlwZXMuZnVuYyxcblx0cmVmQ29sbGVjdG9yOiBQcm9wVHlwZXMuZnVuYyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL1ZpZXcuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgZmllbGQgfSBmcm9tICcuLi8uLi8uLi9hc3NldHMvY29tbW9uLXByb3AtdHlwZXMnO1xuaW1wb3J0IHsgb3B0aW9uVmFsdWVTZXQgfSBmcm9tICcuLi8uLi9jb21wb25lbnQtdXRpbHMuanN4JztcblxuZnVuY3Rpb24gRHJvcERvd24ocHJvcHMpIHtcblx0dmFyIGxhYmVsID0gcHJvcHMuZmllbGQubGFiZWwgfHwgcHJvcHMuZmllbGQubmFtZTtcblxuXHRyZXR1cm4gKFxuXHRcdDxkaXYgY2xhc3NOYW1lPVwiZmllbGRcIj5cblx0XHRcdDxsYWJlbD57bGFiZWx9PC9sYWJlbD5cblx0XHRcdDxzZWxlY3Rcblx0XHRcdFx0dHlwZT1cInRleHRcIlxuXHRcdFx0XHRuYW1lPXtwcm9wcy5maWVsZC5uYW1lfVxuXHRcdFx0XHRvbkNoYW5nZT17cHJvcHMub25DaGFuZ2V9XG5cdFx0XHRcdHZhbHVlPXtwcm9wcy52YWx1ZX0+XG5cdFx0XHRcdHtvcHRpb25WYWx1ZVNldChwcm9wcy5maWVsZC5vcHRpb25zKX1cblx0XHRcdDwvc2VsZWN0PlxuXHRcdDwvZGl2PlxuXHQpO1xufVxuXG5Ecm9wRG93bi5wcm9wVHlwZXMgPSBmaWVsZDtcblxuZXhwb3J0IGRlZmF1bHQgRHJvcERvd247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9jb21wb25lbnRzL3ZpZXdzL2ZpZWxkcy9Ecm9wRG93bi5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBmaWVsZCB9IGZyb20gJy4uLy4uLy4uL2Fzc2V0cy9jb21tb24tcHJvcC10eXBlcyc7XG5cbmZ1bmN0aW9uIFRleHRGaWVsZChwcm9wcykge1xuXHR2YXIgbGFiZWwgPSBwcm9wcy5maWVsZC5sYWJlbCB8fCBwcm9wcy5maWVsZC5uYW1lO1xuXG5cdHJldHVybiAoXG5cdFx0PGRpdiBjbGFzc05hbWU9XCJmaWVsZFwiPlxuXHRcdFx0PGxhYmVsPntsYWJlbH08L2xhYmVsPlxuXHRcdFx0PGlucHV0XG5cdFx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdFx0bmFtZT17cHJvcHMuZmllbGQubmFtZX1cblx0XHRcdFx0cGxhY2Vob2xkZXI9e3Byb3BzLmZpZWxkLnBsYWNlaG9sZGVyfVxuXHRcdFx0XHRvbkNoYW5nZT17cHJvcHMub25DaGFuZ2V9XG5cdFx0XHRcdG1heExlbmd0aD17cHJvcHMuZmllbGQuZGF0YS5tYXhsZW5ndGh9XG5cdFx0XHRcdHZhbHVlPXtwcm9wcy52YWx1ZX0vPlxuXHRcdDwvZGl2PlxuXHQpO1xufVxuXG5UZXh0RmllbGQucHJvcFR5cGVzID0gZmllbGQ7XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRGaWVsZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2NvbXBvbmVudHMvdmlld3MvZmllbGRzL1RleHRGaWVsZC5qc3giLCJpbXBvcnQgaW50ZXJhY3QgZnJvbSAnaW50ZXJhY3QuanMnO1xuXG53aW5kb3cuaW50ZXJhY3QgPSBpbnRlcmFjdDtcblxuLyoqXG4gKiBIYW5kbGVzIGRyYWdnYWJsZS9kcm9wcGFibGUgaXRlbXMuXG4gKiBAY2xhc3NcbiAqL1xudmFyIERyYWdEcm9wID0gZnVuY3Rpb24oY2FudmFzLCBzZXR0aW5ncywgY2FsbGJhY2tzID0ge30pIHtcblx0dGhpcy5fY2FudmFzID0gY2FudmFzO1xuXHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cdHRoaXMuX2NhbGxiYWNrcyA9IGNhbGxiYWNrcztcblxuXHR0aGlzLnVpID0ge1xuXHRcdGRyYWc6IFtdLFxuXHRcdGRyb3A6IFtdXG5cdH07XG59O1xuXG5EcmFnRHJvcC5wcm90b3R5cGUgPSB7XG5cdGFkZERyYWdhYmxlOiBmdW5jdGlvbihlbGVtZW50LCBzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcblx0XHR2YXIgZHJhZ2FibGUgPSBuZXcgRHJhZ2FibGUoZWxlbWVudCk7XG5cblx0XHQvLyBkdXBsaWNhdGUgc2V0dGluZ3Ncblx0XHRzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKTtcblxuXHRcdC8vIG1ha2UgdGhlIGVsZW1lbnQgZHJhZ2dhYmxlXG5cdFx0ZHJhZ2FibGUuc2V0RHJhZ2FibGUoc2V0dGluZ3MpXG5cdFx0XHQub24oJ2RyYWdzdGFydCcsICgpID0+IHtcblx0XHRcdFx0dGhpcy5fY2FudmFzLmNsYXNzTGlzdC5hZGQodGhpcy5zZXR0aW5ncy5jbGFzc2VzLmlzX2RyYWdnaW5nKTtcblx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuc2V0dGluZ3MuY2xhc3Nlcy5pdGVtX2RyYWdnaW5nKTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ2RyYWdlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX2NhbnZhcy5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuc2V0dGluZ3MuY2xhc3Nlcy5pc19kcmFnZ2luZyk7XG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnNldHRpbmdzLmNsYXNzZXMuaXRlbV9kcmFnZ2luZyk7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLl9jYWxsYmFja3MuZHJhZ0VuZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrcy5kcmFnRW5kKGVsZW1lbnQsIGRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMudWkuZHJhZy5wdXNoKHRoaXMuX2NyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGRyYWdhYmxlKSk7XG5cdH0sXG5cblx0YWRkRHJvcGFibGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuXHRcdHZhciBkcm9wYWJsZSA9IG5ldyBEcm9wYWJsZShlbGVtZW50KTtcblxuXHRcdGRyb3BhYmxlLnNldERyb3BhYmxlKHNldHRpbmdzKVxuXHRcdFx0Lm9uKCdkcm9wYWN0aXZhdGUnLCAoZXZlbnQpID0+IHtcblx0XHRcdFx0Ly8gYWRkIGFjdGl2ZSBkcm9wem9uZSBmZWVkYmFja1xuXHRcdFx0XHRldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZCh0aGlzLnNldHRpbmdzLmNsYXNzZXMuZHJvcHpvbmVfaXNfYWN0aXZlKTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ2RyYWdlbnRlcicsIChldmVudCkgPT4ge1xuXHRcdFx0XHQvLyBmZWVkYmFjayB0aGUgcG9zc2liaWxpdHkgb2YgYSBkcm9wXG5cdFx0XHRcdGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuYWRkKHRoaXMuc2V0dGluZ3MuY2xhc3Nlcy5kcm9wem9uZV9pc190YXJnZXQpO1xuXHRcdFx0XHQvLyBldmVudC5yZWxhdGVkVGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2Nhbi1kcm9wJyk7XG5cdFx0XHRcdC8vIGV2ZW50LnJlbGF0ZWRUYXJnZXQudGV4dENvbnRlbnQgPSAnRHJhZ2dlZCBpbic7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdkcmFnbGVhdmUnLCAoZXZlbnQpID0+IHtcblx0XHRcdFx0Ly8gcmVtb3ZlIHRoZSBkcm9wIGZlZWRiYWNrIHN0eWxlXG5cdFx0XHRcdGV2ZW50LnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuc2V0dGluZ3MuY2xhc3Nlcy5kcm9wem9uZV9pc190YXJnZXQpO1xuXHRcdFx0XHQvLyBldmVudC5yZWxhdGVkVGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2Nhbi1kcm9wJyk7XG5cdFx0XHRcdC8vIGV2ZW50LnJlbGF0ZWRUYXJnZXQudGV4dENvbnRlbnQgPSAnRHJhZ2dlZCBvdXQnO1xuXHRcdFx0fSlcblx0XHRcdC5vbignZHJvcCcsIChldmVudCkgPT4ge1xuXHRcdFx0XHRpZiAodHlwZW9mIHRoaXMuX2NhbGxiYWNrcy5kcm9wID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2tzLmRyb3AoZXZlbnQucmVsYXRlZFRhcmdldCwgZXZlbnQudGFyZ2V0LCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5vbignZHJvcGRlYWN0aXZhdGUnLCAoZXZlbnQpID0+IHtcblx0XHRcdFx0Ly8gcmVtb3ZlIGFjdGl2ZSBkcm9wem9uZSBmZWVkYmFja1xuXHRcdFx0XHRldmVudC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnNldHRpbmdzLmNsYXNzZXMuZHJvcHpvbmVfaXNfYWN0aXZlKTtcblx0XHRcdFx0ZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5zZXR0aW5ncy5jbGFzc2VzLmRyb3B6b25lX2lzX3RhcmdldCk7XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMudWkuZHJvcC5wdXNoKHRoaXMuX2NyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGRyb3BhYmxlKSk7XG5cdH0sXG5cblx0cmVzZXREcmFnUG9zaXRpb246IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoKGVsZW1lbnQgPSB0aGlzLmdldERyYWdJbnN0YW5jZShlbGVtZW50KSkpIHtcblx0XHRcdGVsZW1lbnQuaW5zdGFuY2UucmVzZXRQb3NpdGlvbigpO1xuXHRcdH1cblx0fSxcblxuXHRnZXREcmFnSW5zdGFuY2U6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gdGhpcy51aS5kcmFnLmZpbmQoKGl0ZW0pID0+IHtcblx0XHRcdHJldHVybiBpdGVtLmVsZW1lbnQgPT09IGVsZW1lbnQ7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NyZWF0ZUluc3RhbmNlOiBmdW5jdGlvbihlbGVtZW50LCBpbnN0YW5jZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRlbGVtZW50LFxuXHRcdFx0aW5zdGFuY2Vcblx0XHR9O1xuXHR9XG59O1xuXG4vKlxuICogR2VuZXJpY2FsbHkgaGFuZGxlcyB0aGUgZHJhZ2dpbmcgYW5kIGRyb3BwaW5nIG9mIGluZGl2aWR1YWwgRE9NIG5vZGVzLlxuICogVXNlcyBpbnRlcmFjdC5qcyAoaHR0cDovL2ludGVyYWN0anMuaW8pXG4gKi9cbnZhciBEcmFnYWJsZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cblx0dGhpcy5feCA9IDA7XG5cdHRoaXMuX3kgPSAwO1xufTtcblxuRHJhZ2FibGUucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogU2V0IHVwIGEgZHJhZ2dhYmxlIGl0ZW0uXG5cdCAqL1xuXHRzZXREcmFnYWJsZTogZnVuY3Rpb24oc2V0dGluZ3MpIHtcblx0XHRyZXR1cm4gaW50ZXJhY3QodGhpcy5fZWxlbWVudClcblx0XHRcdC5kcmFnZ2FibGUoc2V0dGluZ3MpXG5cdFx0XHQub24oJ2RyYWdtb3ZlJywgc2V0dGluZ3Mub25EcmFnTW92ZSB8fCAoKGV2ZW50KSA9PiB7XG5cdFx0XHRcdHRoaXMuX3ggKz0gZXZlbnQuZHg7XG5cdFx0XHRcdHRoaXMuX3kgKz0gZXZlbnQuZHk7XG5cblx0XHRcdFx0dGhpcy5fZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPVxuXHRcdFx0XHR0aGlzLl9lbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9XG5cdFx0XHRcdFx0J3RyYW5zbGF0ZSgnICsgdGhpcy5feCArICdweCwgJyArIHRoaXMuX3kgKyAncHgpJztcblx0XHRcdH0pKTtcblx0fSxcblxuXHRyZXNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl94ID0gMDtcblx0XHR0aGlzLl95ID0gMDtcblxuXHRcdHRoaXMuX2VsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID1cblx0XHR0aGlzLl9lbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9XG5cdFx0XHQndHJhbnNsYXRlKDAsIDApJztcblx0fSxcbn07XG5cblxuLypcbiAqIEdlbmVyaWNhbGx5IGhhbmRsZXMgZHJvcCB6b25lcyBpbiB0aGUgRE9NLlxuICogVXNlcyBpbnRlcmFjdC5qcyAoaHR0cDovL2ludGVyYWN0anMuaW8pXG4gKi9cbnZhciBEcm9wYWJsZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG59O1xuXG5Ecm9wYWJsZS5wcm90b3R5cGUgPSB7XG5cdC8qKlxuXHQgKiBTZXQgdXAgYSBkcmFnZ2FibGUgaXRlbS5cblx0ICovXG5cdHNldERyb3BhYmxlOiBmdW5jdGlvbihzZXR0aW5ncykge1xuXHRcdHJldHVybiBpbnRlcmFjdCh0aGlzLl9lbGVtZW50KVxuXHRcdFx0LmRyb3B6b25lKHNldHRpbmdzKTtcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRHJhZ0Ryb3A7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9saWIvRHJhZ0Ryb3AuanMiLCIvKipcbiAqIFRha2VzIG11bHRpcGxlIGZ1bmN0aW9ucyBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGludm9rZXMgdGhlbSBjb25zZWN1dGl2ZWx5XG4gKiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50IHNpZ25hdHVyZTogKHByb3ApIGB2YWx1ZWAsIGBwcm9wbmFtZWAsIGBkcm9wbGV0X25hbWVgLCBgZHJvcGxldF90eXBlYC5cbiAqL1xuZnVuY3Rpb24gY2hhaW4oKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odmFsdWUsIHByb3BuYW1lLCBkcm9wbGV0X25hbWUsIGRyb3BsZXRfdHlwZSkge1xuXHRcdHZhciB0ZXN0ID0gdHJ1ZTtcblxuXHRcdC8vIHJ1biBlYWNoIGZ1bmN0aW9uIGluIHRoZSBjaGFpblxuXHRcdGFyZ3MuZm9yRWFjaCgoZm4pID0+IHtcblx0XHRcdGlmICghZm4uYXBwbHkodGhpcywgW3ZhbHVlLCBwcm9wbmFtZSwgZHJvcGxldF9uYW1lLCBkcm9wbGV0X3R5cGVdKSkge1xuXHRcdFx0XHR0ZXN0ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGVzdDtcblx0fTtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoZSBgdGVzdGAgdmFsdWUgaXMgdHJ1dGh5LiBJbiB0aGUgY2FzZSB0aGF0IGl0IGZhaWxzLCBhbiBFcnJvciBpcyB0aHJvd24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRlc3QgLSBUZXN0IGV4cHJlc3Npb24gcmVzdWx0XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgYmVpbmcgdGVzdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlLCBpbiBjYXNlIG9mIGZhaWx1cmUuIFdpbGwgYmUgYXBwZW5kZWQgdG8gYSBnZW5lcmFsXG4gKiBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtkcm9wbGV0X25hbWVdIC0gVGhlIG5hbWUgb2YgdGhlIERyb3BsZXQgYmVpbmcgdGVzdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RvcGxldF90eXBlXSAtIFRoZSBkcm9wbGV0VHlwZSBhdHRyaWJ1dGUgb2YgdGhlIERyb3BsZXQgYmVpbmcgdGVzdGVkXG4gKi9cbmZ1bmN0aW9uIGFzc2VydCh0ZXN0LCBwcm9wbmFtZSwgbWVzc2FnZSwgZHJvcGxldF9uYW1lLCBkcm9wbGV0X3R5cGUpIHtcblx0dmFyIGVycm9yLCBwcm9wX2lkO1xuXG5cdGlmICghdGVzdCkge1xuXHRcdGlmIChkcm9wbGV0X25hbWUpIHtcblx0XHRcdHByb3BfaWQgPSAnXCInICsgZHJvcGxldF9uYW1lICsgJ1wiJyArIChkcm9wbGV0X3R5cGUgPyAnICgnICsgZHJvcGxldF90eXBlICsgJyknIDogJycpO1xuXHRcdH1cblxuXHRcdGVycm9yID0gICdFcnJvciBpbiBEcm9wbGV0JyArXG5cdFx0XHQocHJvcF9pZCA/ICcgJyArIHByb3BfaWQgKyAnICcgOiAnICcpICtcblx0XHRcdCdwcm9wIFwiJyArIHByb3BuYW1lICsgJ1wiLiAnICsgbWVzc2FnZTtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGlzUmVxdWlyZWQodmFsdWUsIHByb3AsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlKSB7XG5cdHJldHVybiBhc3NlcnQoXG5cdFx0KHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpLCBwcm9wLCAnVmFsdWUgaXMgcmVxdWlyZWQuJywgZHJvcGxldF9uYW1lLCBkcm9wbGV0X3R5cGVcblx0KTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nTm90RW1wdHkodmFsdWUsIHByb3AsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlKSB7XG5cdHJldHVybiBhc3NlcnQoXG5cdFx0KHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09ICcnKSwgcHJvcCwgJ1ZhbHVlIGNhbm5vdCBiZSBlbXB0eS4nLCBkcm9wbGV0X25hbWUsIGRyb3BsZXRfdHlwZVxuXHQpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmcodmFsdWUsIHByb3AsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlKSB7XG5cdHJldHVybiBhc3NlcnQoXG5cdFx0KHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyksXG5cdFx0cHJvcCxcblx0XHQnVmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nLFxuXHRcdGRyb3BsZXRfbmFtZSxcblx0XHRkcm9wbGV0X3R5cGVcblx0KTtcbn1cblxuc3RyaW5nLmlzUmVxdWlyZWQgPSBjaGFpbihzdHJpbmcsIGlzUmVxdWlyZWQpO1xuc3RyaW5nLm5vdEVtcHR5ID0gY2hhaW4oc3RyaW5nLCBzdHJpbmdOb3RFbXB0eSk7XG5zdHJpbmcubm90RW1wdHkuaXNSZXF1aXJlZCA9IGNoYWluKHN0cmluZywgc3RyaW5nTm90RW1wdHksIGlzUmVxdWlyZWQpO1xuXG5mdW5jdGlvbiBvYmplY3QodmFsdWUsIHByb3AsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlKSB7XG5cdHJldHVybiBhc3NlcnQoXG5cdFx0KHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyksXG5cdFx0cHJvcCxcblx0XHQnVmFsdWUgbXVzdCBiZSBhbiBvYmplY3QuJyxcblx0XHRkcm9wbGV0X25hbWUsXG5cdFx0ZHJvcGxldF90eXBlXG5cdCk7XG59XG5cbm9iamVjdC5pc1JlcXVpcmVkID0gY2hhaW4ob2JqZWN0LCBpc1JlcXVpcmVkKTtcblxuZnVuY3Rpb24gYXJyYXkodmFsdWUsIHByb3AsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlKSB7XG5cdHJldHVybiBhc3NlcnQoXG5cdFx0QXJyYXkuaXNBcnJheSh2YWx1ZSksIHByb3AsICdWYWx1ZSBtdXN0IGJlIGFuIGFycmF5LicsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlXG5cdCk7XG59XG5cbmFycmF5LmlzUmVxdWlyZWQgPSBjaGFpbihhcnJheSwgaXNSZXF1aXJlZCk7XG5cbmZ1bmN0aW9uIGFycmF5T2YoKSB7fVxuXG5hcnJheU9mLnN0cmluZyA9IGNoYWluKFxuXHQvLyB0ZXN0IGZvciBhbiBhcnJheVxuXHRhcnJheSxcblx0Ly8gdGVzdCBhcnJheSB2YWx1ZXMgYXJlIGFsbCBzdHJpbmdzXG5cdCh2YWx1ZSwgcHJvcCwgZHJvcGxldF9uYW1lLCBkcm9wbGV0X3R5cGUpID0+IHtcblx0XHR2YXIgdGVzdCA9IHRydWUsXG5cdFx0XHRhO1xuXG5cdFx0Zm9yIChhID0gMDsgYSA8IHZhbHVlLmxlbmd0aDsgYSArPSAxKSB7XG5cdFx0XHR0ZXN0ID0gKHRlc3QgPyAodHlwZW9mIHZhbHVlW2FdID09PSAnc3RyaW5nJykgOiB0ZXN0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXNzZXJ0KFxuXHRcdFx0dGVzdCxcblx0XHRcdHByb3AsXG5cdFx0XHQnVmFsdWUgbXVzdCBiZSBhbiBhcnJheSBjb250YWluaW5nIG9ubHkgc3RyaW5ncycsXG5cdFx0XHRkcm9wbGV0X25hbWUsXG5cdFx0XHRkcm9wbGV0X3R5cGVcblx0XHQpO1xuXHR9XG4pO1xuXG5hcnJheU9mLnN0cmluZy5pc1JlcXVpcmVkID0gY2hhaW4oYXJyYXlPZi5zdHJpbmcsIGlzUmVxdWlyZWQpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdF9jaGFpbjogY2hhaW4sXG5cdF9hc3NlcnQ6IGFzc2VydCxcblx0c3RyaW5nLFxuXHRvYmplY3QsXG5cdGFycmF5LFxuXHRhcnJheU9mLFxuXHRpc1JlcXVpcmVkLFxuXHRzdHJpbmdOb3RFbXB0eVxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2xpYi9Qcm9wVHlwZXMuanMiLCJpbXBvcnQgRHJhZ0Ryb3AgZnJvbSAnLi9EcmFnRHJvcC5qcyc7XG5pbXBvcnQgQ29tbXVuaWNhdG9yIGZyb20gJy4vQ29tbXVuaWNhdG9yJztcblxuaW1wb3J0IENhbnZhc0NvbnRhaW5lciBmcm9tICcuLi9jb21wb25lbnRzL2NvbnRhaW5lcnMvQ2FudmFzQ29udGFpbmVyJztcblxuaW1wb3J0IGFjdGlvbnMgZnJvbSAnLi4vc3RhdGUvYWN0aW9ucyc7XG5cbmltcG9ydCB7IGRpYWxvZ01vZGVzLCB1aVN0YXRlcywgbWVzc2FnZUNvbW1hbmRzIH0gZnJvbSAnLi4vYXNzZXRzL2NvbnN0YW50cyc7XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyByZW5kZXIgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gJ3JlYWN0LXJlZHV4JztcblxudmFyIFVJID0gZnVuY3Rpb24ocGFyZW50LCBzZXR0aW5ncywgcmVmcywgZGF0YSwgc3RvcmUsIHRlbXBsYXRlKSB7XG5cdC8qKlxuXHQgKiBTZXR0aW5ncyBhcyBkZWZpbmVkIHdoZW4gaW5zdGFudGlhdGluZy4gSW5oZXJpdHMgZnJvbSB7QGxpbmsgQXBwLmRlZmF1bHRzfVxuXHQgKi9cblx0dGhpcy5fcGFyZW50ID0gcGFyZW50O1xuXHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cdHRoaXMuX3JlZnMgPSByZWZzO1xuXHR0aGlzLl9kYXRhID0gZGF0YTtcblx0dGhpcy5fc3RvcmUgPSBzdG9yZTtcblx0dGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuXHQvLyBVSSBjbGFzcyBzcGVjaWZpYyBkYXRhIGVudHJpZXNcblx0dGhpcy5fZGF0YS5VSSA9IHtcblx0XHRkcmFnZHJvcDoge30sXG5cdFx0ZHJvcGxldEVkaXQ6IHtcblx0XHRcdGRyb3BsZXQ6IG51bGwsXG5cdFx0XHRjYWxsYmFjazogbnVsbFxuXHRcdH0sXG5cdFx0dnBfd2lkdGg6IDAsXG5cdFx0ZHJhZ0hhbmRsZVBvc2l0aW9uOiAwXG5cdH07XG5cblx0dGhpcy5fY29tbXMgPSBuZXcgQ29tbXVuaWNhdG9yKCdhcHAnLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luLCB7XG5cdFx0bWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKCdtZXNzYWdlIHRvIFwiYXBwXCIhJywgbWVzc2FnZSk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBnZW5lcmFsIHF1ZXVlc1xuXHR0aGlzLnF1ZXVlcyA9IHtcblx0XHRkcmFnZHJvcEJpbmRpbmdzOiBbXVxuXHR9O1xuXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9oYW5kbGVXaW5kb3dSZXNpemUuYmluZCh0aGlzKSk7XG59O1xuXG5VSS5wcm90b3R5cGUgPSB7XG5cdC8qKlxuXHQgKiBTZW5kcyByZW5kZXIoKSBjYWxsIHRvIHRoZSBSZWFjdCBjYW52YXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2NhbnZhcyA9IHJlbmRlcihcblx0XHRcdDxQcm92aWRlciBzdG9yZT17dGhpcy5fc3RvcmV9PlxuXHRcdFx0XHQ8Q2FudmFzQ29udGFpbmVyXG5cdFx0XHRcdFx0ZGF0YT17dGhpcy5fZGF0YX1cblx0XHRcdFx0XHRzZXR0aW5ncz17dGhpcy5zZXR0aW5nc31cblx0XHRcdFx0XHRyZWZDb2xsZWN0b3I9e3RoaXMuX3JlZkNvbGxlY3Rvci5iaW5kKHRoaXMpfVxuXHRcdFx0XHRcdG9uTW91bnQ9e3RoaXMuX21vdW50RXZlbnQuYmluZCh0aGlzKX1cblx0XHRcdFx0XHRvbkRpYWxvZ0NvbXBsZXRlPXt0aGlzLl9jb21wbGV0ZURpYWxvZ0FjdGlvbi5iaW5kKHRoaXMpfVxuXHRcdFx0XHRcdG9uRGlhbG9nQ2FuY2VsPXt0aGlzLl9jYW5jZWxEaWFsb2dBY3Rpb24uYmluZCh0aGlzKX1cblx0XHRcdFx0XHRvbkF0dGFjaG1lbnRDbGljaz17dGhpcy5faGFuZGxlQXR0YWNobWVudENsaWNrLmJpbmQodGhpcyl9XG5cdFx0XHRcdFx0b25Ecm9wbGV0Q2xpY2s9e3RoaXMuX2hhbmRsZURyb3BsZXRDbGljay5iaW5kKHRoaXMpfVxuXHRcdFx0XHRcdG9uRHJvcFpvbmVDbGljaz17dGhpcy5faGFuZGxlRHJvcFpvbmVDbGljay5iaW5kKHRoaXMpfVxuXHRcdFx0XHRcdG9uRHJhZ0hhbmRsZVByZXNzPXt0aGlzLl9oYW5kbGVEcmFnSGFuZGxlRXZlbnQuYmluZCh0aGlzKX1cblx0XHRcdFx0XHRjbGFzc191aT17dGhpc31cblx0XHRcdFx0XHRjbGFzc190ZW1wbGF0ZT17dGhpcy5fdGVtcGxhdGV9Lz5cblx0XHRcdDwvUHJvdmlkZXI+LFxuXHRcdFx0dGhpcy5fcmVmcy51aS5hcHBcblx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEaXNwbGF5cyBhbiBlZGl0b3Igd2luZG93IGZvciBhIERyb3BsZXQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIC0gT25lIG9mIHRoZSBkcm9wbGV0TW9kZXMgbW9kZXMuXG5cdCAqIEBwYXJhbSB7bWl4ZWR9IGRhdGEgLSBSZWxldmFudCBkYXRhIHRvIHN0b3JlIGZvciB0aGUgZGlhbG9nIHRvIHVzZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zaG93RGlhbG9nOiBmdW5jdGlvbihtb2RlLCBkYXRhKSB7XG5cdFx0dGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy5zZXREaWFsb2dNb2RlKG1vZGUsIGRhdGEpKTtcblx0fSxcblxuXHRfY29tcGxldGVEaWFsb2dBY3Rpb246IGZ1bmN0aW9uKGRpYWxvZ19kYXRhKSB7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKTtcblxuXHRcdC8vIHJlc2V0IGRpYWxvZyBzdGF0ZSB0byBub3RoaW5nXG5cdFx0dGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy5zZXREaWFsb2dNb2RlKGRpYWxvZ01vZGVzLk5PTkUpKTtcblxuXHRcdHN3aXRjaCAoc3RhdGUuZGlhbG9nLm1vZGUpIHtcblx0XHRjYXNlIGRpYWxvZ01vZGVzLkVESVRfRFJPUExFVDpcblx0XHRcdC8vIGRyb3BsZXQgYmVpbmcgZWRpdGVkIHByaW9yIHRvIG9yIGR1cmluZyBhdHRhdGNobWVudFxuXHRcdFx0aWYgKHN0YXRlLmRpYWxvZy5zdGF0ZS5hdHRhY2htZW50X2luZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIG5vIGF0dGFjaG1lbnQgaW5kZXggLSB0aGlzIGlzIGEgbmV3IGRyb3Bcblx0XHRcdFx0dGhpcy56b25lQWRkQXR0YWNobWVudChcblx0XHRcdFx0XHRzdGF0ZS5kaWFsb2cuc3RhdGUuem9uZV9pZCxcblx0XHRcdFx0XHRzdGF0ZS5kaWFsb2cuc3RhdGUuZHJvcGxldF9pZCxcblx0XHRcdFx0XHRkaWFsb2dfZGF0YVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNle1xuXHRcdFx0XHR0aGlzLnpvbmVFZGl0QXR0YWNobWVudChcblx0XHRcdFx0XHRzdGF0ZS5kaWFsb2cuc3RhdGUuem9uZV9pZCxcblx0XHRcdFx0XHRzdGF0ZS5kaWFsb2cuc3RhdGUuYXR0YWNobWVudF9pbmRleCxcblx0XHRcdFx0XHRkaWFsb2dfZGF0YVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfY2FuY2VsRGlhbG9nQWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHQvLyBub29wXG5cdH0sXG5cblx0LyoqXG5cdCAqIEVsZW1lbnQgcmVmZXJlbmNlIGNvbGxlY3Rvci4gQ29sbGVjdHMgRE9NIGVsZW1lbnRzIGZyb20gUmVhY3QgY29tcG9uZW50cy5cblx0ICogQmluZCBhbiBlbGVtZW50IHJlZmVyZW5jZSB1c2luZyB0aGUgcmVmIGF0dHJpYnV0ZSBhbmQgY29sbGVjdFJlZiBmcm9tIHV0aWxzLmpzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVmQ29sbGVjdG9yOiBmdW5jdGlvbihjb2xsZWN0aW9uLCBlbGVtZW50LCBrZXkpIHtcblx0XHRpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuXHRcdFx0aWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5fcmVmcy5jb21wb25lbnRzW2NvbGxlY3Rpb25dID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHRoaXMuX3JlZnMuY29tcG9uZW50c1tjb2xsZWN0aW9uXSA9IHt9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fcmVmcy5jb21wb25lbnRzW2NvbGxlY3Rpb25dW2tleV0gPSBlbGVtZW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fcmVmcy5jb21wb25lbnRzW2NvbGxlY3Rpb25dID0gZWxlbWVudDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhcHR1cmVzIG1vdW50IGV2ZW50cyBmcm9tIFJlYWN0IGNvbXBvbmVudHMgYnkgY29sbGVjdGlvbi9rZXkgaWRlbnRpZmllcnMuXG5cdCAqIElkZW50aWZpZXJzIGFyZSB0aGUgc2FtZSBhcyB0aGUgb25lcyBzdG9yZWQgd2l0aCBBcHAjX3JlZkNvbGxlY3RvclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X21vdW50RXZlbnQ6IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGtleSkge1xuXHRcdGlmICh0aGlzLl9nZXRSZWZlcmVuY2VkRWxlbWVudChjb2xsZWN0aW9uLCBrZXkpKSB7XG5cdFx0XHQvLyB2YWxpZCBjb21wb25lbnQgbW91bnRlZFxuXHRcdFx0c3dpdGNoIChjb2xsZWN0aW9uKSB7XG5cdFx0XHRjYXNlICdjYW52YXMnOlxuXHRcdFx0XHQvLyBhZGQgZHJhZyBiaW5kaW5nIGZvciB0aGUgZHJhZyBoYW5kbGVcblx0XHRcdFx0dGhpcy5fcXVldWVEcmFnRHJvcEJpbmRpbmcoJ2RyYWcnLCAnZHJhZ19oYW5kbGUnLCBudWxsLCB7XG5cdFx0XHRcdFx0b25EcmFnTW92ZTogdGhpcy5faGFuZGxlRHJhZ0hhbmRsZUV2ZW50LmJpbmQodGhpcylcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gcHJvY2VzcyBhbGwgZHJhZy9kcm9wIGJpbmRpbmdzXG5cdFx0XHRcdHRoaXMuX3NldERyYWdEcm9wQmluZGluZ3MoKTtcblx0XHRcdFx0dGhpcy5fcmVmcy5tb3VudGVkLmNhbnZhcyA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICd0ZW1wbGF0ZSc6XG5cdFx0XHRcdC8vIHRoaXMuX3F1ZXVlRHJhZ0Ryb3BCaW5kaW5nKCdkcm9wJywgY29sbGVjdGlvbiwga2V5KTtcblx0XHRcdFx0dGhpcy5fcmVmcy5tb3VudGVkLnRlbXBsYXRlID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ2Ryb3BsZXQnOlxuXHRcdFx0XHR0aGlzLl9xdWV1ZURyYWdEcm9wQmluZGluZygnZHJhZycsIGNvbGxlY3Rpb24sIGtleSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdkcm9wem9uZSc6XG5cdFx0XHRcdHRoaXMuX3F1ZXVlRHJhZ0Ryb3BCaW5kaW5nKCdkcm9wJywgJ2Ryb3B6b25lX3RhcmdldCcsIGtleSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICd2aWV3X2ZyYW1lJzpcblx0XHRcdFx0dGhpcy5fY29tbXMucmVnaXN0ZXJHdWVzdEFkZHJlc3MoXG5cdFx0XHRcdFx0J3ZpZXcnLFxuXHRcdFx0XHRcdHRoaXMuX3JlZnMuY29tcG9uZW50c1tjb2xsZWN0aW9uXS5jb250ZW50V2luZG93XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0dGhpcy5fcmVmcy5tb3VudGVkLnZpZXdfZnJhbWUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHRoaXMuX3JlZnMubW91bnRlZC5jYW52YXMgJiZcblx0XHRcdFx0dGhpcy5fcmVmcy5tb3VudGVkLnRlbXBsYXRlICYmXG5cdFx0XHRcdHRoaXMuX3JlZnMubW91bnRlZC52aWV3X2ZyYW1lXG5cdFx0XHRcdCkge1xuXHRcdFx0XHQvLyBhbGwgcmVxdWlyZWQgcmVmcyBtb3VudGVkIC0gc2V0IGFjdGl2ZVxuXHRcdFx0XHR0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnNldFVJU3RhdGUodWlTdGF0ZXMuQUNUSVZFKSk7XG5cblx0XHRcdFx0Ly8gcnVuIGluaXRpYWwgc2l6ZSBjYWxjdWxhdGlvbnNcblx0XHRcdFx0dGhpcy5faGFuZGxlV2luZG93UmVzaXplKCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J0NvbXBvbmVudCBtb3VudCBldmVudCBjYWxsZWQgYnV0IHJlZiB3YXMgbm90IGNvbGxlY3RlZC4gJyArXG5cdFx0XHRcdCdjb21wb25lbnQ6ICcgKyBjb2xsZWN0aW9uICsgKGtleSA/ICcvJyArIGtleSA6ICcnKVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFF1ZXVlcyBhIGRyYWcvZHJvcCBET00gYmluZGluZyB0aWxsIHRoZSBtb3VudCBldmVudCBmb3IgdGhlIENhbnZhcyBjb21wb25lbnQuXG5cdCAqIFRoaXMgaXMgZG9uZSBiZWNhdXNlIHRoZSBjYW52YXMgaXMgcmVsaWVkIHVwb24gYXMgdGhlIGNvbnRhaW5lciBmb3IgZHJhZ2dpbmcuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcXVldWVEcmFnRHJvcEJpbmRpbmc6IGZ1bmN0aW9uKHR5cGUsIGNvbGxlY3Rpb24sIGtleSwgc2V0dGluZ3MpIHtcblx0XHRpZiAodGhpcy5fcmVmcy5jb21wb25lbnRzLmNhbnZhcykge1xuXHRcdFx0Ly8gY2FudmFzIGFscmVhZHkgZXhpc3RzIC0gaW1tZWRpYXRlbHkgYmluZFxuXHRcdFx0dGhpcy5fc2V0RHJhZ0Ryb3BCaW5kaW5ncyhbeyB0eXBlLCBjb2xsZWN0aW9uLCBrZXksIHNldHRpbmdzIH1dKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcHVzaCB0byBxdWV1ZVxuXHRcdFx0dGhpcy5xdWV1ZXMuZHJhZ2Ryb3BCaW5kaW5ncy5wdXNoKHsgdHlwZSwgY29sbGVjdGlvbiwga2V5LCBzZXR0aW5ncyB9KTtcblx0XHR9XG5cdH0sXG5cblx0X3NldERyYWdEcm9wQmluZGluZ3M6IGZ1bmN0aW9uKHF1ZXVlID0gdGhpcy5xdWV1ZXMuZHJhZ2Ryb3BCaW5kaW5ncykge1xuXHRcdC8vIGJpbmQgZHJhZ0Ryb3AgaGFuZGxlcnMgdG8gdGhlIGVsZW1lbnRzIGluIHRoZSBxdWV1ZVxuXHRcdHRoaXMuX2RhdGEuVUkuZHJhZ2Ryb3AuZHJvcGxldHMgPSBuZXcgRHJhZ0Ryb3AoXG5cdFx0XHR0aGlzLl9yZWZzLmNvbXBvbmVudHMuY2FudmFzLFxuXHRcdFx0dGhpcy5zZXR0aW5ncywge1xuXHRcdFx0XHRkcm9wOiB0aGlzLl9oYW5kbGVEcm9wbGV0RHJvcC5iaW5kKHRoaXMpLFxuXHRcdFx0XHRkcmFnRW5kOiAoZWxlbWVudCkgPT4ge1xuXHRcdFx0XHRcdHRoaXMuX2RhdGEuVUkuZHJhZ2Ryb3AuZHJvcGxldHMucmVzZXREcmFnUG9zaXRpb24oZWxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0cXVldWUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdFx0dmFyIHJlZiA9IHRoaXMuX2dldFJlZmVyZW5jZWRFbGVtZW50KGl0ZW0uY29sbGVjdGlvbiwgaXRlbS5rZXkpLFxuXHRcdFx0XHRkYXRhO1xuXG5cdFx0XHRpZiAoaXRlbS5jb2xsZWN0aW9uID09PSAnZHJvcHpvbmVfdGFyZ2V0Jykge1xuXHRcdFx0XHRkYXRhID0ge1xuXHRcdFx0XHRcdHpvbmVfaWQ6IGl0ZW0ua2V5XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBhIERyYWdEcm9wIGluc3RhbmNlIGFuZCBhc3NpZ24gdG8gdGhlIHBhbGxldCBpdGVtIGRhdGFcblx0XHRcdGlmIChpdGVtLnR5cGUgPT09ICdkcmFnJykge1xuXHRcdFx0XHR0aGlzLl9kYXRhLlVJLmRyYWdkcm9wLmRyb3BsZXRzLmFkZERyYWdhYmxlKHJlZiwgaXRlbS5zZXR0aW5ncywgZGF0YSk7XG5cdFx0XHR9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gJ2Ryb3AnKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuVUkuZHJhZ2Ryb3AuZHJvcGxldHMuYWRkRHJvcGFibGUocmVmLCBPYmplY3QuZGVlcEFzc2lnbih7fSwge1xuXHRcdFx0XHRcdGFjY2VwdDogdGhpcy5zZXR0aW5ncy5zZWxlY3RvcnMuZHJvcGxldFxuXHRcdFx0XHR9LCBpdGVtLnNldHRpbmdzKSwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgZHJvcHMgb2YgZHJvcGxldHMgaW50byBkcm9wIHpvbmVzLiBXaWxsIGF0dGFjaCB0byB0aGUgem9uZVxuXHQgKiBpZiB0aGUgZHJvcCBpcyB2YWxpZC5cblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGJlaW5nIGRyYWdnZWQuXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIFRoZSB0YXJnZXQgYmVpbmcgZHJvcHBlZCBvbnRvLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGRhdGEgb2JqZWN0LCBhcyBzZXQgd2l0aCBhZGREcmFnYWJsZS9hZGREcm9wYWJsZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9oYW5kbGVEcm9wbGV0RHJvcDogZnVuY3Rpb24oZWxlbWVudCwgdGFyZ2V0LCBkYXRhKSB7XG5cdFx0dmFyIGRyb3Bfem9uZSA9IHRoaXMuZ2V0RHJvcFpvbmVCeUlkKGRhdGEuem9uZV9pZCksXG5cdFx0XHRkcm9wbGV0ID0gdGhpcy5nZXREcm9wbGV0QnlJZChlbGVtZW50LmlkKTtcblxuXHRcdHJldHVybiB0aGlzLmF0dGFjaERyb3BsZXRUb0Ryb3Bab25lKGRyb3BsZXQsIGRyb3Bfem9uZSk7XG5cdH0sXG5cblx0X2hhbmRsZUF0dGFjaG1lbnRDbGljazogZnVuY3Rpb24oZHJvcGxldCwgZHJvcF96b25lLCBhdHRhY2htZW50X2luZGV4KSB7XG5cdFx0dGhpcy5fc2hvd0RpYWxvZyhkaWFsb2dNb2Rlcy5FRElUX0RST1BMRVQsIHtcblx0XHRcdGRyb3BsZXRfaWQ6IGRyb3BsZXQuaWQsXG5cdFx0XHR6b25lX2lkOiBkcm9wX3pvbmUuaWQsXG5cdFx0XHRhdHRhY2htZW50X2luZGV4XG5cdFx0fSk7XG5cdH0sXG5cblx0X2hhbmRsZURyb3BsZXRDbGljazogZnVuY3Rpb24oZXZlbnQsIGRyb3BsZXQpIHtcblx0XHR2YXIgc3RhdGUgPSB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpO1xuXG5cdFx0aWYgKHN0YXRlLmFwcC5hY3RpdmVfZHJvcGxldF9pZCAhPT0gZHJvcGxldC5pZCkge1xuXHRcdFx0dGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy5zZXRBY3RpdmVEcm9wbGV0KGRyb3BsZXQuaWQpKTtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZURyb3Bab25lQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50LCBkcm9wX3pvbmUpIHtcblx0XHR2YXIgc3RhdGUgPSB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLFxuXHRcdFx0ZHJvcGxldDtcblxuXHRcdGlmIChzdGF0ZS5hcHAuYWN0aXZlX2Ryb3BsZXRfaWQgIT09IDAgJiZcblx0XHRcdChkcm9wbGV0ID0gdGhpcy5nZXREcm9wbGV0QnlJZChzdGF0ZS5hcHAuYWN0aXZlX2Ryb3BsZXRfaWQpKSkge1xuXHRcdFx0dGhpcy5hdHRhY2hEcm9wbGV0VG9Ecm9wWm9uZShkcm9wbGV0LCBkcm9wX3pvbmUpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlcyBldmVudHMgZnJvbSB0aGUgZHJhZyBoYW5kbGUgKGJldHdlZW4gdGVtcGxhdGUgYW5kIHZpZXcgY29udGFpbmVycylcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9oYW5kbGVEcmFnSGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHdpZHRoO1xuXG5cdFx0c3dpdGNoIChldmVudC50eXBlKSB7XG5cdFx0Y2FzZSAnZHJhZ21vdmUnOlxuXHRcdFx0Ly8gaW5jcmVtZW10IGRyYWdIYW5kbGVQb3NpdGlvbiBiYXNlZCBvbiB4IGRlbHRhIGZyb20gaW50ZXJhY3QgaW5zdGFuY2Vcblx0XHRcdHRoaXMuX2RhdGEuVUkuZHJhZ0hhbmRsZVBvc2l0aW9uICs9IGV2ZW50LmR4O1xuXG5cdFx0XHQvLyBmaWd1cmUgb3V0IGhhbmRsZSBwb3NpdGlvbiBpbiAlIG9mIHRoZSBzY3JlZW4gYW5kIGNvbnZlcnQgaXQgdG8gcGVyY2VudCxcblx0XHRcdC8vIHRoZW4gc2VuZCBzdHJhaWdodCB0byBfc2V0VGVtcGxhdGVWaWV3UmF0aW8gZnVuY3Rpb25cblx0XHRcdHRoaXMuX3NldFRlbXBsYXRlVmlld1JhdGlvKFxuXHRcdFx0XHQoKHRoaXMuX2RhdGEuVUkuZHJhZ19oYW5kbGVfeCArIHRoaXMuX2RhdGEuVUkuZHJhZ0hhbmRsZVBvc2l0aW9uKSAvXG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5VSS52cF93aWR0aCkgKiAxMDBcblx0XHRcdCk7XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0Y2FzZSAndG91Y2hlbmQnOlxuXHRcdFx0aWYgKHRoaXMuX2RhdGEuVUkuZHJhZ0hhbmRsZVBvc2l0aW9uIDwgNSAmJiB0aGlzLl9kYXRhLlVJLmRyYWdIYW5kbGVQb3NpdGlvbiA+IC01KSB7XG5cdFx0XHRcdC8vIGxpdHRsZSBtb3ZlbWVudCAtIGFzc3VtZSBhIGNsaWNrL3RhcCBvY2N1cmVkXG5cdFx0XHRcdHdpZHRoID0gKHRoaXMuX2dldFJlZmVyZW5jZWRFbGVtZW50KCdkcmFnX2hhbmRsZScpKS5vZmZzZXRXaWR0aDtcblxuXHRcdFx0XHRpZiAodGhpcy5fZGF0YS5VSS5kcmFnX2hhbmRsZV94IDwgd2lkdGgpIHtcblx0XHRcdFx0XHQvLyBzZXQgdG8gNTAvNTBcblx0XHRcdFx0XHR0aGlzLl9zZXRUZW1wbGF0ZVZpZXdSYXRpbyg1MCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gc2V0IHRvIDAvMTAwXG5cdFx0XHRcdFx0dGhpcy5fc2V0VGVtcGxhdGVWaWV3UmF0aW8oMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gdXBkYXRlIG1ldHJpY3Mgd2hlbmV2ZXIgd2UncmUgc3RvcHBpbmdcblx0XHRcdHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZSgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVXaW5kb3dSZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2RhdGEuVUkuZHJhZ19oYW5kbGVfeCA9ICh0aGlzLl9nZXRSZWZlcmVuY2VkRWxlbWVudCgnZHJhZ19oYW5kbGUnKSkub2Zmc2V0TGVmdDtcblx0XHR0aGlzLl9kYXRhLlVJLnZwX3dpZHRoID1cblx0XHRcdE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG5cblx0XHQvLyByZXNldCBkcmFnSGFuZGxlUG9zaXRpb24gYmVjYXVzZSB0aGUgbWV0cmljcyBoYXZlIGNoYW5nZWRcblx0XHR0aGlzLl9kYXRhLlVJLmRyYWdIYW5kbGVQb3NpdGlvbiA9IDA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyAtICUgcmF0aW8gZm9yIHRoZSB0ZW1wbGF0ZVxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogU2V0cyB0aGUgdGVtcGxhdGUvdmlldyByYXRpbyBieSBnaXZpbmcgdGhlIHRlbXBsYXRlIGNvbnRhaW5lciBhICUgd2lkdGggYW5kXG5cdCAqIGFkanVzdGluZyB0aGUgdmlldyBjb250YWluZXIgYWNjb3JkaW5nbHkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfc2V0VGVtcGxhdGVWaWV3UmF0aW86IGZ1bmN0aW9uKHJhdGlvKSB7XG5cdFx0dGhpcy5fcmVmcy5jb21wb25lbnRzLnRlbXBsYXRlLnN0eWxlLmZsZXhCYXNpcyA9IHJhdGlvICsgJyUnO1xuXHRcdHRoaXMuX3JlZnMuY29tcG9uZW50cy52aWV3LnN0eWxlLmZsZXhCYXNpcyA9IE1hdGguYWJzKHJhdGlvIC0gMTAwKSArICclJztcblx0fSxcblxuXHRfaXNWYWxpZERyb3A6IGZ1bmN0aW9uKGRyb3BsZXQsIGRyb3Bfem9uZSkge1xuXHRcdHJldHVybiBkcm9wX3pvbmUud2lsbEFjY2VwdChkcm9wbGV0LCB0aGlzLl9zdG9yZSk7XG5cdH0sXG5cblx0YXR0YWNoRHJvcGxldFRvRHJvcFpvbmU6IGZ1bmN0aW9uKGRyb3BsZXQsIGRyb3Bfem9uZSkge1xuXHRcdC8vIGNsZWFyIGFjdGl2ZSBkcm9wbGV0XG5cdFx0dGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy5zZXRBY3RpdmVEcm9wbGV0KCcnKSk7XG5cblx0XHQvLyBjaGVjayBpZiB2YWxpZCBkcm9wXG5cdFx0aWYgKHRoaXMuX2lzVmFsaWREcm9wKGRyb3BsZXQsIGRyb3Bfem9uZSkpIHtcblx0XHRcdGlmIChkcm9wbGV0LmVkaXRhYmxlKSB7XG5cdFx0XHRcdC8vIHNob3cgZWRpdCBkaWFsb2cgYmVmb3JlIGFkZGluZyB0aGUgYXR0YWNobWVudFxuXHRcdFx0XHR0aGlzLl9zaG93RGlhbG9nKGRpYWxvZ01vZGVzLkVESVRfRFJPUExFVCwge1xuXHRcdFx0XHRcdGRyb3BsZXRfaWQ6IGRyb3BsZXQuaWQsXG5cdFx0XHRcdFx0em9uZV9pZDogZHJvcF96b25lLmlkLFxuXHRcdFx0XHRcdGF0dGFjaG1lbnRfaW5kZXg6IG51bGxcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBhZGQgYXR0YWNobWVudCB3aXRob3V0IGRpYWxvZ1xuXHRcdFx0XHR0aGlzLnpvbmVBZGRBdHRhY2htZW50KFxuXHRcdFx0XHRcdGRyb3Bfem9uZS5pZCxcblx0XHRcdFx0XHRkcm9wbGV0LmlkLFxuXHRcdFx0XHRcdGRyb3BsZXQuZGF0YVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHR6b25lQWRkQXR0YWNobWVudDogZnVuY3Rpb24oem9uZV9pZCwgZHJvcGxldF9pZCwgZGF0YSkge1xuXHRcdHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMuem9uZUFkZEF0dGFjaG1lbnQoXG5cdFx0XHR6b25lX2lkLFxuXHRcdFx0ZHJvcGxldF9pZCxcblx0XHRcdHRydWUsXG5cdFx0XHRkYXRhXG5cdFx0KSk7XG5cblx0XHR0aGlzLl91cGRhdGVWaWV3KCk7XG5cdH0sXG5cblx0em9uZUVkaXRBdHRhY2htZW50OiBmdW5jdGlvbih6b25lX2lkLCBhdHRhY2htZW50X2luZGV4LCBkYXRhKSB7XG5cdFx0dGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy56b25lRWRpdEF0dGFjaG1lbnQoXG5cdFx0XHR6b25lX2lkLFxuXHRcdFx0YXR0YWNobWVudF9pbmRleCxcblx0XHRcdGRhdGFcblx0XHQpKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVZpZXcoKTtcblx0fSxcblxuXHR6b25lRGV0YWNoQXR0YWNobWVudDogZnVuY3Rpb24oem9uZV9pZCwgYXR0YWNobWVudF9pbmRleCkge1xuXHRcdHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMuem9uZURldGFjaEF0dGFjaG1lbnQoXG5cdFx0XHR6b25lX2lkLFxuXHRcdFx0YXR0YWNobWVudF9pbmRleFxuXHRcdCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZSBhIHpvbmUncyBhdHRhY2htZW50IChieSBpbmRleClcblx0ICovXG5cdHpvbmVHZXRBdHRhY2htZW50OiBmdW5jdGlvbih6b25lX2lkLCBhdHRhY2htZW50X2luZGV4KSB7XG5cdFx0dmFyIHpvbmUsXG5cdFx0XHRzdGF0ZSA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCk7XG5cblx0XHRpZiAoc3RhdGUuem9uZXMgJiZcblx0XHRcdCh6b25lID0gc3RhdGUuem9uZXNbem9uZV9pZF0pICYmXG5cdFx0XHR6b25lLmF0dGFjaG1lbnRzICYmXG5cdFx0XHR6b25lLmF0dGFjaG1lbnRzLmxlbmd0aCA+IGF0dGFjaG1lbnRfaW5kZXhcblx0XHQpIHtcblx0XHRcdHJldHVybiB6b25lLmF0dGFjaG1lbnRzW2F0dGFjaG1lbnRfaW5kZXhdO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdF91cGRhdGVWaWV3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3RhdGUgPSB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpO1xuXG5cdFx0dGhpcy5fY29tbXMuc2VuZCgndmlldycsIHtcblx0XHRcdGNtZDogbWVzc2FnZUNvbW1hbmRzLlJFTE9BRCxcblx0XHRcdGRhdGE6IHtcblx0XHRcdFx0bWFya3VwOiB0aGlzLl90ZW1wbGF0ZS5yZW5kZXJBc0hUTUwoXG5cdFx0XHRcdFx0c3RhdGUuem9uZXNcblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBPYnRhaW5zIGFuIGVsZW1lbnQgc3RvcmVkIGluIHRoZSBpbnRlcm5hbCByZWZzIGNvbGxlY3Rpb25cblx0ICovXG5cdF9nZXRSZWZlcmVuY2VkRWxlbWVudDogZnVuY3Rpb24oY29sbGVjdGlvbiwga2V5KSB7XG5cdFx0dmFyIHJlZjtcblxuXHRcdGlmIChcblx0XHRcdCgodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwgIWtleSkgJiYgKHJlZiA9IHRoaXMuX3JlZnMuY29tcG9uZW50c1tjb2xsZWN0aW9uXSkpIHx8XG5cdFx0XHQocmVmID0gdGhpcy5fcmVmcy5jb21wb25lbnRzW2NvbGxlY3Rpb25dW2tleV0pXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gcmVmO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZWQgZWxlbWVudCBhdCAnICsgY29sbGVjdGlvbiArICcoJyArIGtleSArXG5cdFx0XHRcdCcpIGNvdWxkIG5vdCBiZSBmb3VuZC4nKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RHJvcGxldEJ5SWQ6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGEucGFsbGV0LmZpbmQoKGVsZW1lbnQpID0+IHtcblx0XHRcdHJldHVybiBlbGVtZW50LmlkID09PSBpZDtcblx0XHR9KTtcblx0fSxcblxuXHRnZXREcm9wWm9uZUJ5SWQ6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGEuZHJvcF96b25lc1tpZF0gfHwgbnVsbDtcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgVUk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9saWIvVUkuanN4IiwiLy8gSlMgUG9seWZpbGxzIC0gZG9lc24ndCBleHBvcnQgYW55dGhpbmcsIGp1c3QgbW9kaWZpZXMgZXhpc3RpbmcgT2JqZWN0IHNwZWNzXG5PYmplY3QuZGVlcEFzc2lnbiA9IGZ1bmN0aW9uKHRhcmdldCwgdmFyQXJncykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHRvLCBmcm9tLCBpbmRleCwga2V5O1xuXG5cdGlmICh0YXJnZXQgPT0gbnVsbCkgeyAvLyBUeXBlRXJyb3IgaWYgdW5kZWZpbmVkIG9yIG51bGxcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcblx0fVxuXG5cdHRvID0gKHR5cGVvZiB2YXJBcmdzICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdChBcnJheS5pc0FycmF5KHZhckFyZ3MpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpKSA/XG5cdFx0QXJyYXkodGFyZ2V0KSA6IC8vIGFycmF5cyB0byByZXRhaW4gdGhlaXIgaWRlbnRpdHlcblx0XHRPYmplY3QodGFyZ2V0KTsgLy8gb3RoZXJ3aXNlIHVzZSBhbiBvYmplY3RcblxuXHRmb3IgKGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0ZnJvbSA9IGFyZ3VtZW50c1tpbmRleF07XG5cblx0XHRpZiAoZnJvbSAhPSBudWxsIHx8IHR5cGVvZiBmcm9tID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0Zm9yIChrZXkgaW4gZnJvbSkge1xuXHRcdFx0XHRpZiAoZnJvbS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBmcm9tW2tleV0gPT09ICdvYmplY3QnICYmIGZyb21ba2V5XSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHR0b1trZXldID0gT2JqZWN0LmRlZXBBc3NpZ24oXG5cdFx0XHRcdFx0XHRcdChBcnJheS5pc0FycmF5KGZyb21ba2V5XSkgPyBbXSA6IHt9KSxcblx0XHRcdFx0XHRcdFx0dG9ba2V5XSxcblx0XHRcdFx0XHRcdFx0ZnJvbVtrZXldXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9saWIvcG9seWZpbGxzLmpzIiwiaW1wb3J0IGRlZmF1bHRfc3RhdGUgZnJvbSAnLi4vYXNzZXRzL2RlZmF1bHQtc3RhdGUnO1xuaW1wb3J0IHsgYWN0aW9uVHlwZXMsIHVpU3RhdGVzIH0gZnJvbSAnLi4vYXNzZXRzL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gJ3JlZHV4JztcblxuLyoqXG4gKiBTZXRzIGFwcGxpY2F0aW9uIHN0YXRlIHZhbHVlc1xuICovXG5mdW5jdGlvbiBhcHAoc3RhdGUgPSBkZWZhdWx0X3N0YXRlLmFwcCwgYWN0aW9uKSB7XG5cdHZhciBhY3RpdmU7XG5cblx0c3dpdGNoIChhY3Rpb24udHlwZSkge1xuXHQvLyBzZXQgdWkgc3RhdGVcblx0Y2FzZSBhY3Rpb25UeXBlcy5VSV9TVEFURTpcblx0XHQvLyBzZXQgJ2FjdGl2ZScgZmxhZyBiYXNlZCBvbiB0aGUgdWlfc3RhdGUgdmFsdWVcblx0XHRzd2l0Y2ggKGFjdGlvbi51aV9zdGF0ZSkge1xuXHRcdGNhc2UgdWlTdGF0ZXMuQUNUSVZFOlxuXHRcdFx0YWN0aXZlID0gdHJ1ZTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGFjdGl2ZSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuXHRcdFx0dWlfc3RhdGU6IGFjdGlvbi51aV9zdGF0ZSxcblx0XHRcdGFjdGl2ZVxuXHRcdH0pO1xuXG5cdGNhc2UgYWN0aW9uVHlwZXMuU0VUX0FDVElWRV9EUk9QTEVUOlxuXHRcdC8vIHNldCB0aGUgYWN0aXZlIGRyb3BsZXQgKGkuZS4gdGhlIG9uZSB0aGF0IHdpbGwgYmUgXCJkcm9wcGVkXCIgd2hlbiBhXG5cdFx0Ly8gZHJvcCB6b25lIGlzIG5leHQgY2xpY2tlZFxuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuXHRcdFx0YWN0aXZlX2Ryb3BsZXRfaWQ6IGFjdGlvbi5kcm9wbGV0X2lkXG5cdFx0fSk7XG5cblx0ZGVmYXVsdDpcblx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn1cblxuLyoqXG4gKiBTZXRzIGRyb3Agem9uZSBzdGF0ZSB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gem9uZXMoc3RhdGUgPSBkZWZhdWx0X3N0YXRlLnpvbmVzLCBhY3Rpb24pIHtcblx0dmFyIHpvbmVzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuXG5cdHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcblx0Y2FzZSBhY3Rpb25UeXBlcy5aT05FX0FERF9BVFRBQ0hNRU5UOlxuXHRcdGlmICghem9uZXNbYWN0aW9uLmlkXSkge1xuXHRcdFx0em9uZXNbYWN0aW9uLmlkXSA9IHtcblx0XHRcdFx0YXR0YWNobWVudHM6IFtdXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIGF0dGFjaCB0aGUgZHJvcGxldFxuXHRcdHpvbmVzW2FjdGlvbi5pZF0uYXR0YWNobWVudHMucHVzaCh7XG5cdFx0XHRkcm9wbGV0X2lkOiBhY3Rpb24uZHJvcGxldF9pZCxcblx0XHRcdGRhdGE6IGFjdGlvbi5kYXRhXG5cdFx0fSk7XG5cblx0XHRicmVhaztcblxuXHRjYXNlIGFjdGlvblR5cGVzLlpPTkVfRURJVF9BVFRBQ0hNRU5UOlxuXHRcdGlmICh6b25lc1thY3Rpb24uaWRdLmF0dGFjaG1lbnRzW2FjdGlvbi5hdHRhY2htZW50X2luZGV4XSkge1xuXHRcdFx0em9uZXNbYWN0aW9uLmlkXS5hdHRhY2htZW50c1thY3Rpb24uYXR0YWNobWVudF9pbmRleF0uZGF0YSA9IGFjdGlvbi5kYXRhO1xuXHRcdH1cblxuXHRcdGJyZWFrO1xuXG5cdGNhc2UgYWN0aW9uVHlwZXMuWk9ORV9ERVRBQ0hfQVRUQUNITUVOVDpcblx0XHQvLyBkZXRhY2ggdGhlIGF0dGFjaG1lbnQgYnkgaW5kZXhcblx0XHRpZiAoYWN0aW9uLmF0dGFjaG1lbnRfaW5kZXggIT09IG51bGwgJiZcblx0XHRcdGFjdGlvbi5hdHRhY2htZW50X2luZGV4IDwgem9uZXNbYWN0aW9uLmlkXS5hdHRhY2htZW50cy5sZW5ndGgpIHtcblx0XHRcdHpvbmVzW2FjdGlvbi5pZF0uYXR0YWNobWVudHMuc3BsaWNlKGFjdGlvbi5hdHRhY2htZW50X2luZGV4LCAxKTtcblx0XHR9XG5cblx0XHRicmVhaztcblxuXHRkZWZhdWx0OlxuXHRcdHJldHVybiBzdGF0ZTtcblx0fVxuXG5cdHJldHVybiB6b25lcztcbn1cblxuZnVuY3Rpb24gZGlhbG9nKHN0YXRlID0gZGVmYXVsdF9zdGF0ZS5kaWFsb2csIGFjdGlvbikge1xuXHRzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cdGNhc2UgYWN0aW9uVHlwZXMuU0VUX0RJQUxPR19NT0RFOlxuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuXHRcdFx0bW9kZTogYWN0aW9uLm1vZGUsXG5cdFx0XHRzdGF0ZTogYWN0aW9uLnN0YXRlXG5cdFx0fSk7XG5cblx0ZGVmYXVsdDpcblx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY29tYmluZVJlZHVjZXJzKHtcblx0YXBwLFxuXHR6b25lcyxcblx0ZGlhbG9nXG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL3N0YXRlL3JlZHVjZXJzLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jhc2U2NC1qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBpbXBvcnQgdXJsKC8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1GaXJhK01vbm98TXVsaTo0MDAsNzAwKTtcIiwgXCJcIl0pO1xuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIHJlc2V0ICovXFxuaHRtbCwgYm9keSwgZGl2LCBzcGFuLCBvYmplY3QsIGlmcmFtZSxcXG5oMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBwLCBibG9ja3F1b3RlLCBwcmUsXFxuYWJiciwgYWRkcmVzcywgY2l0ZSwgY29kZSxcXG5kZWwsIGRmbiwgZW0sIGltZywgaW5zLCBrYmQsIHEsIHNhbXAsXFxuc21hbGwsIHN0cm9uZywgc3ViLCBzdXAsIHZhcixcXG5iLCBpLFxcbmRsLCBkdCwgZGQsIG9sLCB1bCwgbGksXFxuZmllbGRzZXQsIGZvcm0sIGxhYmVsLCBsZWdlbmQsXFxudGFibGUsIGNhcHRpb24sIHRib2R5LCB0Zm9vdCwgdGhlYWQsIHRyLCB0aCwgdGQsXFxuYXJ0aWNsZSwgYXNpZGUsIGNhbnZhcywgZGV0YWlscywgZmlnY2FwdGlvbiwgZmlndXJlLFxcbmZvb3RlciwgaGVhZGVyLCBoZ3JvdXAsIG1lbnUsIG5hdiwgc2VjdGlvbiwgc3VtbWFyeSxcXG50aW1lLCBtYXJrLCBhdWRpbywgdmlkZW8ge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIGJvcmRlcjogMDtcXG4gIG91dGxpbmU6IDA7XFxuICBmb250LXNpemU6IDEwMCU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgfVxcblxcbmJvZHkge1xcbiAgbGluZS1oZWlnaHQ6IDE7IH1cXG5cXG5hcnRpY2xlLCBhc2lkZSwgZGV0YWlscywgZmlnY2FwdGlvbiwgZmlndXJlLFxcbmZvb3RlciwgaGVhZGVyLCBoZ3JvdXAsIG1lbnUsIG5hdiwgc2VjdGlvbiB7XFxuICBkaXNwbGF5OiBibG9jazsgfVxcblxcbm5hdiB1bCB7XFxuICBsaXN0LXN0eWxlOiBub25lOyB9XFxuXFxuYmxvY2txdW90ZSwgcSB7XFxuICBxdW90ZXM6IG5vbmU7IH1cXG5cXG5ibG9ja3F1b3RlOmJlZm9yZSwgYmxvY2txdW90ZTphZnRlcixcXG5xOmJlZm9yZSwgcTphZnRlciB7XFxuICBjb250ZW50OiAnJztcXG4gIGNvbnRlbnQ6IG5vbmU7IH1cXG5cXG5hIHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBmb250LXNpemU6IDEwMCU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgfVxcblxcbi8qIGNoYW5nZSBjb2xvdXJzIHRvIHN1aXQgeW91ciBuZWVkcyAqL1xcbmlucyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmY5O1xcbiAgY29sb3I6ICMwMDA7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG5cXG4vKiBjaGFuZ2UgY29sb3VycyB0byBzdWl0IHlvdXIgbmVlZHMgKi9cXG5tYXJrIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZjk7XFxuICBjb2xvcjogIzAwMDtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG4gIGZvbnQtd2VpZ2h0OiBib2xkOyB9XFxuXFxuZGVsIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoOyB9XFxuXFxuYWJiclt0aXRsZV0sIGRmblt0aXRsZV0ge1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IGRvdHRlZDtcXG4gIGN1cnNvcjogaGVscDsgfVxcblxcbnRhYmxlIHtcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICBib3JkZXItc3BhY2luZzogMDsgfVxcblxcbi8qIGNoYW5nZSBib3JkZXIgY29sb3VyIHRvIHN1aXQgeW91ciBuZWVkcyAqL1xcbmhyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgaGVpZ2h0OiAxcHg7XFxuICBib3JkZXI6IDA7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI2NjY2NjYztcXG4gIG1hcmdpbjogMWVtIDA7XFxuICBwYWRkaW5nOiAwOyB9XFxuXFxuaW5wdXQsIHNlbGVjdCB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuXFxuYm9keSB7XFxuICBmb250LWZhbWlseTogXFxcIk11bGlcXFwiLCBzYW5zLXNlcmlmO1xcbiAgbGluZS1oZWlnaHQ6IDE0MCU7XFxuICBjb2xvcjogIzMzMzsgfVxcblxcbmgxIHtcXG4gIGZvbnQtc2l6ZTogMjRweDtcXG4gIGZvbnQtc2l6ZTogMS41cmVtOyB9XFxuXFxuaDIge1xcbiAgZm9udC1zaXplOiAyMnB4O1xcbiAgZm9udC1zaXplOiAxLjM3NXJlbTsgfVxcblxcbmgzIHtcXG4gIGZvbnQtc2l6ZTogMjBweDtcXG4gIGZvbnQtc2l6ZTogMS4yNXJlbTsgfVxcblxcbnAge1xcbiAgbWFyZ2luOiAuNzVlbSAwO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgZm9udC1zaXplOiAxcmVtOyB9XFxuXFxucDpmaXJzdC1jaGlsZCB7XFxuICBtYXJnaW4tdG9wOiAwOyB9XFxuXFxucDpsYXN0LWNoaWxkIHtcXG4gIG1hcmdpbi1ib3R0b206IDA7IH1cXG5cXG5wcmUge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJGaXJhIE1vbm9cXFwiLCBtb25vc3BhY2U7IH1cXG5cXG4udmlldyBpZnJhbWUge1xcbiAgei1pbmRleDogMTsgfVxcblxcbi5vdmVybGF5LFxcbi52aWV3IC5kcmFnLW1hc2sge1xcbiAgei1pbmRleDogMjsgfVxcblxcbi5kcm9wbGV0LFxcbi5kcmFnLWhhbmRsZSB7XFxuICB6LWluZGV4OiAzOyB9XFxuXFxuLmRpYWxvZyB7XFxuICB6LWluZGV4OiA0OyB9XFxuXFxuKiB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuXFxuLyogbWFpbiBsYXlvdXQgKi9cXG5ib2R5IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7IH1cXG5cXG4uYXBwLFxcbi50YWctY2FudmFzIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICBib3R0b206IDA7XFxuICByaWdodDogMDsgfVxcblxcbi50YWctY2FudmFzIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB9XFxuICAudGFnLWNhbnZhcyBoZWFkZXIge1xcbiAgICBmbGV4LXNocmluazogMDsgfVxcbiAgLnRhZy1jYW52YXMgLm1haW4ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWdyb3c6IDE7IH1cXG4gICAgLnRhZy1jYW52YXMgLm1haW4gPiAqOm5vdCguZHJhZy1oYW5kbGUpIHtcXG4gICAgICBmbGV4LWJhc2lzOiA1MCU7IH1cXG4gICAgLnRhZy1jYW52YXMgLm1haW4gLmRyYWctaGFuZGxlIHtcXG4gICAgICBmbGV4LWJhc2lzOiAyMHB4OyB9XFxuICAudGFnLWNhbnZhcyAucGFsbGV0IHtcXG4gICAgZmxleC1zaHJpbms6IDA7IH1cXG5cXG5oZWFkZXIge1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjOyB9XFxuICBoZWFkZXIgaDEge1xcbiAgICBsZXR0ZXItc3BhY2luZzogMXB4OyB9XFxuICAgIGhlYWRlciBoMSBiIHtcXG4gICAgICBjb2xvcjogIzQ2NGFlMDsgfVxcblxcbi50ZW1wbGF0ZSB7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNjY2M7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlOyB9XFxuICAudGVtcGxhdGUgcHJlIHtcXG4gICAgbWFyZ2luOiAxMHB4O1xcbiAgICBsaW5lLWhlaWdodDogMTMwJTtcXG4gICAgdGFiLXNpemU6IDM7IH1cXG4gIC50ZW1wbGF0ZSAuaGxqcyB7XFxuICAgIGZvbnQtc2l6ZTogMS4xMjVlbTtcXG4gICAgbGluZS1oZWlnaHQ6IDEzMCU7IH1cXG4gICAgLnRlbXBsYXRlIC5obGpzIC5kcm9wLXpvbmUgLmhsanMtc3RyaW5nIHtcXG4gICAgICBjb2xvcjogd2hpdGU7IH1cXG5cXG4uZHJvcGxldC1hY3RpdmUgLnRlbXBsYXRlLFxcbi5kcmFnZ2luZyAudGVtcGxhdGUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YzZmZjNjsgfVxcblxcbi52aWV3IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2NjYzsgfVxcbiAgLnZpZXcgaWZyYW1lLFxcbiAgLnZpZXcgLmRyYWctbWFzayB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlOyB9XFxuICAudmlldyAuZHJhZy1tYXNrIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyB9XFxuXFxuLmRyYWdnaW5nIC52aWV3IC5kcmFnLW1hc2sge1xcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gIG9wYWNpdHk6IC43OyB9XFxuXFxuLnBhbGxldCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNjY2M7XFxuICBwYWRkaW5nOiA1cHggMTBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7IH1cXG4gIC5wYWxsZXQgLmRyb3BsZXQge1xcbiAgICBtYXJnaW46IDVweCAxMHB4IDVweCAwOyB9XFxuXFxuLmRyb3Atem9uZSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH1cXG4gIC5kcm9wLXpvbmUgLnRhcmdldC1vdXRlciB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAuZHJvcC16b25lIC50YXJnZXQgYiB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgcGFkZGluZzogMnB4IDVweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzk1OWVmZjtcXG4gICAgbGluZS1oZWlnaHQ6IDEyMCU7XFxuICAgIGNvbG9yOiB3aGl0ZTsgfVxcbiAgLmRyb3Atem9uZSAudGFyZ2V0LmlzLWFjdGl2ZSBiIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzQ2NGFlMDsgfVxcbiAgLmRyb3Atem9uZSAudGFyZ2V0LmlzLXRhcmdldCBiIHtcXG4gICAgYm94LXNoYWRvdzogMCAwIDVweCAjZmY1MTVjO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmY1MTVjOyB9XFxuICAuZHJvcC16b25lIC50YXJnZXQuaGlkZGVuIHtcXG4gICAgZGlzcGxheTogbm9uZTsgfVxcbiAgLmRyb3Atem9uZSAuYXR0YWNobWVudHMgPiAqIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBtYXJnaW46IDFweDtcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICBwYWRkaW5nOiAxcHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM2MWZmNGQ7IH1cXG4gIC5kcm9wLXpvbmUgLmF0dGFjaG1lbnRzIC5lbGVtZW50IHtcXG4gICAgZGlzcGxheTogYmxvY2s7IH1cXG5cXG4uZHJvcC16b25lOmhvdmVyIC50YXJnZXQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogc2t5Ymx1ZTtcXG4gIGN1cnNvcjogcG9pbnRlcjsgfVxcblxcbi5kcm9wbGV0LWFjdGl2ZSAuZHJvcC16b25lIC50YXJnZXQgYiB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDY0YWUwOyB9XFxuXFxuLmRyb3BsZXQtYWN0aXZlIC5kcm9wLXpvbmUgLnRhcmdldDpob3ZlciBiIHtcXG4gIGJveC1zaGFkb3c6IDAgMCA1cHggI2ZmNTE1YztcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZjUxNWM7IH1cXG5cXG4uZHJvcGxldCB7XFxuICBoZWlnaHQ6IDM1cHg7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4gIC5kcm9wbGV0IC5sYWJlbCB7XFxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4xNXMgY3ViaWMtYmV6aWVyKDAuNzcsIDAsIDAuMTc1LCAxKSwgY29sb3IgMC4xNXMgY3ViaWMtYmV6aWVyKDAuNzcsIDAsIDAuMTc1LCAxKSwgYm9yZGVyLWNvbG9yIDAuMTVzIGN1YmljLWJlemllcigwLjc3LCAwLCAwLjE3NSwgMSksIG9wYWNpdHkgMC41cyBjdWJpYy1iZXppZXIoMC43NywgMCwgMC4xNzUsIDEpO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNhMGEwYTA7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiA1cHg7XFxuICAgIGhlaWdodDogMzVweDtcXG4gICAgcGFkZGluZzogNXB4IDEwcHg7XFxuICAgIGxpbmUtaGVpZ2h0OiAxMjAlO1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIGZvbnQtc2l6ZTogMC44NzVyZW07XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgIGNvbG9yOiAjMzMzOyB9XFxuICAgIC5kcm9wbGV0IC5sYWJlbCAuaWNvbiB7XFxuICAgICAgdHJhbnNpdGlvbjogZmlsbCAwLjE1cyBjdWJpYy1iZXppZXIoMC43NywgMCwgMC4xNzUsIDEpO1xcbiAgICAgIG1hcmdpbi1yaWdodDogLjVlbTsgfVxcbiAgLmRyb3BsZXQ6aG92ZXIgLmxhYmVsLFxcbiAgLmRyb3BsZXQ6YWN0aXZlIC5sYWJlbCxcXG4gIC5kcm9wbGV0LmFjdGl2ZSAubGFiZWwge1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2EwYTBhMDsgfVxcbiAgICAuZHJvcGxldDpob3ZlciAubGFiZWwgLmljb24sXFxuICAgIC5kcm9wbGV0OmFjdGl2ZSAubGFiZWwgLmljb24sXFxuICAgIC5kcm9wbGV0LmFjdGl2ZSAubGFiZWwgLmljb24ge1xcbiAgICAgIGZpbGw6ICNmZmY7IH1cXG4gIC5kcm9wbGV0Lml0ZW0tZHJhZ2dpbmcgLmxhYmVsIHtcXG4gICAgb3BhY2l0eTogMC41O1xcbiAgICBib3gtc2hhZG93OiAtMnB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMyk7IH1cXG4gIC5kcm9wbGV0LnR5cGUtdGV4dCAubGFiZWwge1xcbiAgICBib3JkZXItY29sb3I6ICM5NTllZmY7IH1cXG4gIC5kcm9wbGV0LnR5cGUtdGV4dDpob3ZlciAubGFiZWwsXFxuICAuZHJvcGxldC50eXBlLXRleHQ6YWN0aXZlIC5sYWJlbCxcXG4gIC5kcm9wbGV0LnR5cGUtdGV4dC5hY3RpdmUgLmxhYmVsIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjNDY0YWUwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDY0YWUwOyB9XFxuICAuZHJvcGxldC50eXBlLWF0dHJpYnV0ZSAubGFiZWwge1xcbiAgICBib3JkZXItY29sb3I6ICM2MWZmNGQ7IH1cXG4gIC5kcm9wbGV0LnR5cGUtYXR0cmlidXRlOmhvdmVyIC5sYWJlbCxcXG4gIC5kcm9wbGV0LnR5cGUtYXR0cmlidXRlOmFjdGl2ZSAubGFiZWwsXFxuICAuZHJvcGxldC50eXBlLWF0dHJpYnV0ZS5hY3RpdmUgLmxhYmVsIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjM2I5ZTJmO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjM2I5ZTJmOyB9XFxuICAuZHJvcGxldC50eXBlLWVsZW1lbnQgLmxhYmVsIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjY2M0OWZmOyB9XFxuICAuZHJvcGxldC50eXBlLWVsZW1lbnQ6aG92ZXIgLmxhYmVsLFxcbiAgLmRyb3BsZXQudHlwZS1lbGVtZW50OmFjdGl2ZSAubGFiZWwsXFxuICAuZHJvcGxldC50eXBlLWVsZW1lbnQuYWN0aXZlIC5sYWJlbCB7XFxuICAgIGJvcmRlci1jb2xvcjogIzhmMzJiNDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzhmMzJiNDsgfVxcblxcbi5kaWFsb2cge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIHRvcDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIGJhY2tncm91bmQ6ICNjY2M7XFxuICAvKiBUaGUgRmFsbGJhY2sgKi9cXG4gIGJhY2tncm91bmQ6IHJnYmEoMjA0LCAyMDQsIDIwNCwgMC43KTsgfVxcbiAgLmRpYWxvZy52aXNpYmxlIHtcXG4gICAgZGlzcGxheTogZmxleDsgfVxcbiAgLmRpYWxvZyAuZGlhbG9nLWNvbnRhaW5lciB7XFxuICAgIGJveC1zaGFkb3c6IC01cHggNXB4IHJnYmEoMCwgMCwgMCwgMC4xKTtcXG4gICAgbWF4LXdpZHRoOiA1MDBweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjsgfVxcbiAgLmRpYWxvZyAuZGlhbG9nLWhlYWRpbmcge1xcbiAgICBwYWRkaW5nOiAyMHB4O1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYzsgfVxcbiAgICAuZGlhbG9nIC5kaWFsb2ctaGVhZGluZyAuaWNvbiB7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAuNWVtOyB9XFxuICAgIC5kaWFsb2cgLmRpYWxvZy1oZWFkaW5nIHA6bnRoLW9mLXR5cGUobisyKSB7XFxuICAgICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICAgIGZvbnQtc2l6ZTogMC44NzVyZW07IH1cXG5cXG5mb3JtIGZpZWxkc2V0Om5vdCguYnV0dG9ucykge1xcbiAgcGFkZGluZzogMCAyMHB4O1xcbiAgbWFyZ2luOiAxMHB4IDA7IH1cXG5cXG5mb3JtIGZpZWxkc2V0LmJ1dHRvbnMge1xcbiAgY29udGVudDogJyc7XFxuICBkaXNwbGF5OiB0YWJsZTtcXG4gIGNsZWFyOiBib3RoO1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNjY2M7XFxuICBwYWRkaW5nOiAyMHB4OyB9XFxuICBmb3JtIGZpZWxkc2V0LmJ1dHRvbnMgYnV0dG9uIHtcXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbiAgICBtYXJnaW46IDAgLjI1ZW07IH1cXG4gICAgZm9ybSBmaWVsZHNldC5idXR0b25zIGJ1dHRvbi5wdWxsLWxlZnQge1xcbiAgICAgIGZsb2F0OiBsZWZ0OyB9XFxuXFxuZm9ybSBsZWdlbmQge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjsgfVxcblxcbmZvcm0gLmZpZWxkIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luOiAxMHB4IDA7IH1cXG4gIGZvcm0gLmZpZWxkIGxhYmVsIHtcXG4gICAgd2lkdGg6IDQwJTsgfVxcblxcbmlucHV0LFxcbmJ1dHRvbixcXG5zZWxlY3Qge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgZm9udC1zaXplOiAwLjg3NXJlbTtcXG4gIHBhZGRpbmc6IDVweDsgfVxcblxcbmJ1dHRvbiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBib3JkZXI6IDA7XFxuICBwYWRkaW5nOiAxMHB4IDE1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjOyB9XFxuICBidXR0b246aG92ZXIsIGJ1dHRvbjpmb2N1cyB7XFxuICAgIGxlZnQ6IDJweDtcXG4gICAgdG9wOiAtMnB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIGJveC1zaGFkb3c6IC0ycHggMnB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Q5ZDlkOTsgfVxcbiAgYnV0dG9uOmFjdGl2ZSB7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHRvcDogMDtcXG4gICAgYm94LXNoYWRvdzogbm9uZTsgfVxcbiAgYnV0dG9uLnByaW1hcnkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOTU5ZWZmOyB9XFxuICAgIGJ1dHRvbi5wcmltYXJ5LnByaW1hcnk6aG92ZXIsIGJ1dHRvbi5wcmltYXJ5LnByaW1hcnk6Zm9jdXMge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNhZmI1ZmY7IH1cXG4gIGJ1dHRvbi5kYW5nZXIge1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmNTE1YzsgfVxcbiAgICBidXR0b24uZGFuZ2VyLmRhbmdlcjpob3ZlciwgYnV0dG9uLmRhbmdlci5kYW5nZXI6Zm9jdXMge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZjZiNzQ7IH1cXG5cXG4uaWNvbiB7XFxuICBmaWxsOiAjMzMzOyB9XFxuXFxuLmRyYWctaGFuZGxlIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICBjdXJzb3I6IGNvbC1yZXNpemU7IH1cXG4gIC5kcmFnLWhhbmRsZTphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4xNXMgY3ViaWMtYmV6aWVyKDAuNzcsIDAsIDAuMTc1LCAxKTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIHRvcDogNTAlO1xcbiAgICBtYXJnaW4tdG9wOiAtMjVweDtcXG4gICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICAgIHdpZHRoOiA4cHg7XFxuICAgIGhlaWdodDogNTBweDtcXG4gICAgYm9yZGVyLWxlZnQ6IDJweCBzb2xpZCAjY2NjO1xcbiAgICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCAjY2NjOyB9XFxuICAuZHJhZy1oYW5kbGU6aG92ZXIsIC5kcmFnLWhhbmRsZS5pdGVtLWRyYWdnaW5nIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDsgfVxcbiAgLmRyYWctaGFuZGxlOmhvdmVyOmFmdGVyLCAuZHJhZy1oYW5kbGUuaXRlbS1kcmFnZ2luZzphZnRlciB7XFxuICAgIGhlaWdodDogMTAwcHg7XFxuICAgIG1hcmdpbi10b3A6IC01MHB4OyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L25qcC10YWcvc3JjL3N0eWxlcy9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCkge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgdmFyIGJhc2U2NCA9IG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG4gIHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pZWVlNzU0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaXNhcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIHNpbmdsZSBgZWRpdGFibGVgIGRlZmlpdGlvbiB0byBwcm9kdWNlIG9uZSBmaWVsZC5cbiAqIEB0eXBlZGVmIEVkaXRhYmxlSXRlbURlZmluaXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIC0gT25lIG9mICd0ZXh0JywgJ2xvbmd0ZXh0JywgJ2Ryb3Bkb3duJywgJ2NoZWNrYm94Jywgb3IgJ3JhZGlvJy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbH0gW3JlcXVpcmVkXSAtIFdoZXRoZXIgdGhlIGZpZWxkIG11c3QgYmUgZmlsbGVkIGluIG9yIG5vdC5cbiAqIEBwcm9wZXJ0eSB7bWl4ZWR9IFt2YWx1ZV0gLSBFaXRoZXIgYW4gYXJyYXkgb2YgdmFsdWVzLCBvciBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyXSAtIEluIHRoZSBjYXNlIG9mIGEgdGV4dCB2YWx1ZSwgdGhpcyB3aWxsIHNob3cgaW4gcGxhY2Ugb2YgZW1wdHkgdmFsdWVzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RlZF0gLSBJbiB0aGUgY2FzZSBvZiBhbiBhcnJheSB2YWx1ZSwgdGhpcyBzZXQgdGhlIHZhbHVlIGFzICdzZWxlY3RlZCcuXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICcuL1Byb3BUeXBlcyc7XG5pbXBvcnQgRm9ybUZpZWxkIGZyb20gJy4vRm9ybUZpZWxkJztcblxudmFyIERyb3BsZXQsIGRyb3BsZXRfaWQgPSAwO1xuXG4vKipcbiAqIEluZGl2aWR1YWwgZHJvcGxldCBjbGFzcy4gSGFuZGxlcyB2YWxpZGF0aW9uIG9mIHByb3BzIGluIGEgc2ltaWxhciBmYXNoaW9uIHRvXG4gKiBSZWFjdCwgYnV0IChwcm9iYWJseSkgd2l0aCBhIGxvdCBsZXNzIHN0eWxlLlxuICogQGNsYXNzXG4gKi9cbkRyb3BsZXQgPSBmdW5jdGlvbihzZXR0aW5ncyA9IHt9LCBpZCkge1xuXHRpZiAodHlwZW9mIGlkID09PSAnbnVtYmVyJykge1xuXHRcdHRoaXMuaWQgPSAnZHJvcGxldF8nICsgaWQ7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5pZCA9ICdkcm9wbGV0XycgKyArK2Ryb3BsZXRfaWQ7XG5cdH1cblxuXHR0aGlzLl9vcmlnaW5hbFNldHRpbmdzID0gT2JqZWN0LmRlZXBBc3NpZ24oe30sIHNldHRpbmdzKTtcblx0dGhpcy5kYXRhID0ge307XG5cdHRoaXMubmFtZSA9IG51bGw7XG5cdHRoaXMuZHJvcGxldFR5cGUgPSBudWxsO1xuXHR0aGlzLmF0dGFjaG1lbnRJZHMgPSBbXTtcblxuXHR0aGlzLmluaXQoKTtcbn07XG5cbkRyb3BsZXQucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogSW5pdGlhbGlzYXRpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHQvLyBzZXQgYmFzZSBwcm9wZXJ0aWVzIGZvciBhbGwgZHJvcGxldHNcblx0XHR0aGlzLl92YWxpZGF0ZUFuZFNldChbXG5cdFx0XHQnbmFtZScsXG5cdFx0XHQnZHJvcGxldFR5cGUnLFxuXHRcdFx0J2F0dGFjaG1lbnRJZHMnLFxuXHRcdFx0J2VkaXRhYmxlJ1xuXHRcdF0sIHRoaXMpO1xuXG5cdFx0Ly8gY2hlY2sgZHJvcGxldCB0eXBlIGlzIHZhbGlkXG5cdFx0c3dpdGNoICh0aGlzLmRyb3BsZXRUeXBlKSB7XG5cdFx0Y2FzZSAnZWxlbWVudCc6XG5cdFx0Y2FzZSAndGV4dCc6XG5cdFx0Y2FzZSAnYXR0cmlidXRlJzpcblx0XHRcdHRoaXMuX3NldEV4dHJhRmllbGRzKCk7XG5cdFx0XHRicmVhaztcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Ryb3BsZXQgdHlwZSAnICsgdGhpcy5kcm9wbGV0VHlwZSArICcgaXMgaW52YWxpZC4nKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyB0eXBlIHNwZWNpZmljIGZpZWxkcyBmb3IgdmFsaWRhdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zZXRFeHRyYUZpZWxkczogZnVuY3Rpb24oKSB7XG5cdFx0c3dpdGNoICh0aGlzLmRyb3BsZXRUeXBlKSB7XG5cdFx0Y2FzZSAndGV4dCc6XG5cdFx0XHR0aGlzLl92YWxpZGF0ZUFuZFNldChbJ3ZhbHVlJ10sIHRoaXMuZGF0YSk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2VsZW1lbnQnOlxuXHRcdFx0dGhpcy5fdmFsaWRhdGVBbmRTZXQoWydhdHRycycsICd0YWdOYW1lJywgJ2lubmVySFRNTCddLCB0aGlzLmRhdGEpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdhdHRyaWJ1dGUnOlxuXHRcdFx0dGhpcy5fdmFsaWRhdGVBbmRTZXQoWydrZXknLCAndmFsdWUnXSwgdGhpcy5kYXRhKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVmFsaWRhdGVzICh1c2luZyB0aGUgUHJvcFR5cGUgZnVuY3Rpb25zKSBhbmQgc2V0cyB0aGUgaW5zdGFuY2UgdmFsdWVzXG5cdCAqIGdpdmVuIHRoZSBkZWZpbmVkIHByb3BlcnRpZXMuXG5cdCAqL1xuXHRfdmFsaWRhdGVBbmRTZXQodmFsdWVzLCBjb250ZXh0KSB7XG5cdFx0dmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB7XG5cdFx0XHRpZiAoRHJvcGxldC5Qcm9wVHlwZXMuaGFzT3duUHJvcGVydHkodmFsdWUpKSB7XG5cdFx0XHRcdGlmIChEcm9wbGV0LlByb3BUeXBlc1t2YWx1ZV0oXG5cdFx0XHRcdFx0XHR0aGlzLl9vcmlnaW5hbFNldHRpbmdzW3ZhbHVlXSxcblx0XHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdFx0dGhpcy5fb3JpZ2luYWxTZXR0aW5ncy5uYW1lIHx8IG51bGwsXG5cdFx0XHRcdFx0XHR0aGlzLl9vcmlnaW5hbFNldHRpbmdzLmRyb3BsZXRUeXBlIHx8IG51bGxcblx0XHRcdFx0XHQpKSB7XG5cdFx0XHRcdFx0Y29udGV4dFt2YWx1ZV0gPSB0aGlzLl9vcmlnaW5hbFNldHRpbmdzW3ZhbHVlXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdEcm9wbGV0IHByb3BlcnR5IFwiJyArIHZhbHVlICsgJ1wiIGRlZmluaXRpb24gZG9lcyBub3QgZXhpc3QuJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8qKlxuICogRGVzaWduZWQgYXMgYSBQcm9wVHlwZSB2YWxpZGF0b3IgbXVjaCBsaWtlIHN0cmluZywgaXNSZXF1aXJlZCwgYXJyYXlPZiBldGMsIHRoaXNcbiAqIGZ1bmN0aW9uIHNwZWNpZmljYWxseSB0ZXN0cyB0aGUgdmFsaWRpdHkgb2YgdGhlIGBlZGl0YWJsZWAgcHJvcCBhbmQgaXRzIGNoaWxkcmVuLlxuICovXG5Ecm9wbGV0Ll92YWxpZGF0ZUVkaXRhYmxlU2V0ID0gZnVuY3Rpb24odmFsdWUsIHByb3AsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlKSB7XG5cdHZhciBhdHRyaWJ1dGUsIGtleSwgYXR0cmtleSxcblx0XHRwcm9wX2Vycm9yID0gJ0Vycm9yIGluIERyb3BsZXQgcHJvcCAnICsgZHJvcGxldF9uYW1lICsgJyAoJyArIHByb3AgKyAnKTonO1xuXG5cdC8vIGFsbG93IHVuZGVmaW5lZCB2YWx1ZXNcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIHRlc3RpbmcgdGhlIGRyb3BsZXQgdmFsdWVcblx0aWYgKFByb3BUeXBlcy5fYXNzZXJ0KFxuXHRcdCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSwgcHJvcCwgJ1ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0LicsIGRyb3BsZXRfbmFtZSwgZHJvcGxldF90eXBlXG5cdCkpIHtcblx0XHQvLyBjb250aW51ZSB0ZXN0aW5nXG5cdFx0Zm9yIChrZXkgaW4gdmFsdWUpIHtcblx0XHRcdC8vIHRlc3RpbmcgaW5kaXZpZHVhbCBhdHRyaWJ1dGVzXG5cdFx0XHRhdHRyaWJ1dGUgPSB2YWx1ZVtrZXldO1xuXG5cdFx0XHQvLyBhdHRyaWJ1dGUgaXMgdW5yZWNvZ25pc2VkIG9yIG5vdCBhbiBvYmplY3Rcblx0XHRcdGlmIChcblx0XHRcdFx0RHJvcGxldC5lZGl0YWJsZUF0dHJpYnV0ZXMuaW5kZXhPZihrZXkpID09PSAtMSB8fFxuXHRcdFx0XHR0eXBlb2YgYXR0cmlidXRlICE9PSAnb2JqZWN0J1xuXHRcdFx0KSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRwcm9wX2Vycm9yICsgJyBcIicgKyBrZXkgKyAnXCIgaXMgbm90IGFuIGVkaXRhYmxlIGF0dHJpYnV0ZSBvciBpcyBvZiB0aGUgd3JvbmcgdHlwZSdcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXR0cmlidXRlIGlzICdhdHRycycsIGJ1dCBpcyBub3QgYW4gb2JqZWN0IG9mIG9iamVjdHNcblx0XHRcdGlmIChrZXkgPT09ICdhdHRycycpIHtcblx0XHRcdFx0Zm9yIChhdHRya2V5IGluIGF0dHJpYnV0ZSkge1xuXHRcdFx0XHRcdERyb3BsZXQuX3ZhbGlkYXRlRWRpdGFibGVJdGVtKGF0dHJrZXksIGF0dHJpYnV0ZVthdHRya2V5XSwgcHJvcF9lcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdERyb3BsZXQuX3ZhbGlkYXRlRWRpdGFibGVJdGVtKGtleSwgYXR0cmlidXRlLCBwcm9wX2Vycm9yKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkRyb3BsZXQuX3ZhbGlkYXRlRWRpdGFibGVJdGVtID0gZnVuY3Rpb24oaXRlbSwgZGF0YSwgZXJyb3JfcHJlZml4KSB7XG5cdHZhciBlcnJvciA9IGVycm9yX3ByZWZpeCArIGl0ZW0gKyAnIC0gJztcblxuXHRpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yICsgJ25vdCBhbiBFZGl0YWJsZUl0ZW1EZWZpbml0aW9uIG9iamVjdCcpO1xuXHR9XG5cblx0Ly8gY2hlY2sgXCJ0eXBlXCIgZXhpc3RzXG5cdGlmICh0eXBlb2YgZGF0YS50eXBlID09PSAndW5kZWZpbmVkJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvciArICdkb2VzbuKAmXQgY29udGFpbiDigJh0eXBl4oCZIHZhbHVlJyk7XG5cdH1cblxuXHQvLyBjaGVjayBcInR5cGVcIiBpcyB2YWxpZFxuXHRpZiAoRHJvcGxldC5lZGl0YWJsZUZpZWxkVHlwZXMuaW5kZXhPZihkYXRhLnR5cGUpID09PSAtMSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvciArICdpbnZhbGlkIHR5cGUgYXR0cmlidXRlIFwiJyArIGRhdGEudHlwZSArICdcIicpO1xuXHR9XG5cblx0Ly8gcnVuIGNoZWNrcyBvbiB0aGUgZWRpdGFibGUgYXR0cmlidXRlcyB0aGF0IG1hdGNoIEZvcm1GaWVsZCBkYXRhIGF0dHJpYnV0ZXNcblx0Rm9ybUZpZWxkLnZhbGlkYXRlRGF0YUF0dHJpYnV0ZShkYXRhLCBpdGVtLCBlcnJvcl9wcmVmaXgpO1xuXG5cdHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBwb3NzaWJsZSBwcm9wIHR5cGVzIGZvciBEcm9wbGV0cy4gU29tZSBhcmUgYWx3YXlzIHJlcXVpcmVkLlxuICogQHByb3Age3N0cmluZ30gdmFsdWUgLSBEcm9wbGV0ICd2YWx1ZScuIFdoZW4gdXNlZCBhcyBhbiBgYXR0cmlidXRlYCB0eXBlIHZhbHVlLCBjYW4gYmVcbiAqIHNldCB0byBgbnVsbGAgdG8gZGVmaW5lIGEgdmFsdWUtbGVzcyBhdHRyaWJ1dGUuXG4gKiBAcHJvcCB7c3RyaW5nfSBuYW1lIC0gRHJvcGxldCBuYW1lICh1c2VkIGFzIGEgbGFiZWwpLlxuICogQHByb3Age3N0cmluZ1tdfSBhdHRhY2htZW50SWRzIC0gRHJvcCB6b25lIGF0dGFjaG1lbnQgSURzLlxuICogQHByb3Age3N0cmluZ30gZHJvcGxldFR5cGUgLSBEcm9wbGV0IHR5cGUuIE9uZSBvZiBgZWxlbWVudGAsIGB0ZXh0YCBvciBgYXR0cmlidXRlYC5cbiAqIEBwcm9wIHtvYmplY3R9IFthdHRyc10gLSBEcm9wbGV0IGF0dHJpYnV0ZXMsIGluIHRoZSBjYXNlIG9mIHRoZSBgZWxlbWVudGAgdHlwZS5cbiAqIEBwcm9wIHtzdHJpbmd9IHRhZ25hbWUgLSBEcm9wbGV0IHRhZ05hbWUgYXR0cmlidXRlLCBpLmUuIHRoZSBhY3R1YWwgSFRNTEVsZW1lbnQgdXNlZC5cbiAqIFJlcXVyZWQgd2hlbiB0eXBlIGlzIGBlbGVtZW50YC5cbiAqIEBwcm9wIHtzdHJpbmd9IGlubmVySFRNTCAtIERyb3BsZXQncyBpbm5lckhUTUwuXG4gKiBAcHJvcCB7RWRpdGFibGVJdGVtRGVmaW5pdGlvbn0gZWRpdGFibGUgLSBFZGl0YWJsZSBwcm9wZXJ0aWVzIG9mIGBlbGVtZW50YCB0eXBlcy4gW2FkZCBsaW5rIHRvIHR1dG9yaWFsIV0uXG4gKiBAcHJvcCB7c3RyaW5nfSBrZXkgLSBBdHRyaWJ1dGUga2V5cyAobmFtZXMpIG9mIGBhdHRyaWJ1dGVgIHR5cGVzLlxuICovXG5Ecm9wbGV0LlByb3BUeXBlcyA9IHtcblx0dmFsdWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcblx0bmFtZTogUHJvcFR5cGVzLnN0cmluZy5ub3RFbXB0eS5pc1JlcXVpcmVkLFxuXHRhdHRhY2htZW50SWRzOiBQcm9wVHlwZXMuYXJyYXlPZi5zdHJpbmcuaXNSZXF1aXJlZCxcblx0ZHJvcGxldFR5cGU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcblx0YXR0cnM6IFByb3BUeXBlcy5vYmplY3QsXG5cdHRhZ05hbWU6IFByb3BUeXBlcy5zdHJpbmcubm90RW1wdHkuaXNSZXF1aXJlZCxcblx0aW5uZXJIVE1MOiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRlZGl0YWJsZTogRHJvcGxldC5fdmFsaWRhdGVFZGl0YWJsZVNldCxcblx0a2V5OiBQcm9wVHlwZXMuc3RyaW5nLm5vdEVtcHR5LmlzUmVxdWlyZWQsXG59O1xuXG5Ecm9wbGV0LmVkaXRhYmxlQXR0cmlidXRlcyA9IFtcblx0J3ZhbHVlJyxcdCdhdHRycycsXHQndGFnTmFtZScsXHQnaW5uZXJIVE1MJ1xuXTtcblxuRHJvcGxldC5lZGl0YWJsZUZpZWxkVHlwZXMgPSBbXG5cdCd0ZXh0Jyxcblx0J2xvbmd0ZXh0Jyxcblx0J2Ryb3Bkb3duJyxcblx0J2NoZWNrYm94Jyxcblx0J3JhZGlvJ1xuXTtcblxuZXhwb3J0IGRlZmF1bHQgRHJvcGxldDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2xpYi9Ecm9wbGV0LmpzIiwiZXhwb3J0IGNvbnN0IHJlZ2lzdGVyR2VuZXJhbEV2ZW50ID0gZnVuY3Rpb24oY29tcG9uZW50LCBpZCwgaW5mbykge1xuXHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuXHRyZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGlmICh0eXBlb2YgY29tcG9uZW50LnByb3BzLm9uRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNvbXBvbmVudC5wcm9wcy5vbkV2ZW50LmFwcGx5KGNvbXBvbmVudCwgW2V2ZW50LCBpbmZvLCBpZF0uY29uY2F0KFxuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAzKVxuXHRcdFx0KSk7XG5cdFx0fVxuXHR9LmJpbmQodGhpcyk7XG59O1xuXG5leHBvcnQgY29uc3QgY29sbGVjdFJlZiA9IGZ1bmN0aW9uKHByb3BzLCBjb2xsZWN0aW9uLCBrZXkpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKHJlZikge1xuXHRcdGlmICh0eXBlb2YgcHJvcHMucmVmQ29sbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRwcm9wcy5yZWZDb2xsZWN0b3IoY29sbGVjdGlvbiwgcmVmLCBrZXkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdCdyZWYgY29sbGVjdGlvbiB1c2VkIGJ1dCBubyBjb2xsZWN0b3IgaGFzIGJlZW4gc2V0IHVwIGZvciAnICtcblx0XHRcdFx0Y29sbGVjdGlvbiArIChrZXkgPyAnLycgKyBrZXkgOiAnJylcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gZm9yIHZhbGlkYXRpbmcgc3BlY2lmaWMga2V5cyB3aXRoaW4gYW4gb2JqZWN0IHByb3BlcnR5LlxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVQcm9wS2V5cyA9IGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKHByb3BzLCBrZXksIGNvbXBvbmVudCkge1xuXHRcdHZhciBhO1xuXG5cdFx0Zm9yIChhID0gMDsgYSA8IHJlcXVpcmUubGVuZ3RoOyBhICs9IDEpIHtcblx0XHRcdGlmICghcHJvcHNba2V5XS5oYXNPd25Qcm9wZXJ0eShyZXF1aXJlW2FdKSAmJlxuXHRcdFx0XHRwcm9wc1trZXldW3JlcXVpcmVbYV1dICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBFcnJvcihcblx0XHRcdFx0XHQnUHJvcFx0YCcgKyBrZXkgKyAnYCBkb2VzIG5vdCBjb250YWluIGRlZmluaXRpb24gYCcgKyByZXF1aXJlW2FdICtcblx0XHRcdFx0XHRcdCdgIGluICcgKyBjb21wb25lbnQgKyAnIGNvbXBvbmVudC4nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuLyoqXG4gKiBFc2NhcGVzIGEgc3RyaW5nIGZvciB1c2UgYXMgYSBtYXRjaCB3aXRoaW4gYSByZWdleFxuICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM0NDYxNzAvZXNjYXBlLXN0cmluZy1mb3ItdXNlLWluLWphdmFzY3JpcHQtcmVnZXgvNjk2OTQ4NiM2OTY5NDg2XG4gKi9cbmV4cG9ydCBjb25zdCBlc2NhcGVSZWdFeHAgPSBmdW5jdGlvbihzdHIpIHtcblx0cmV0dXJuIHN0ci5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgJ1xcJCYnKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9saWIvdXRpbHMuanMiLCIoZnVuY3Rpb24oaG9zdCkge1xuXG4gIHZhciBwcm9wZXJ0aWVzID0ge1xuICAgIGJyb3dzZXI6IFtcbiAgICAgIFsvbXNpZSAoW1xcLlxcX1xcZF0rKS8sIFwiaWVcIl0sXG4gICAgICBbL3RyaWRlbnRcXC8uKj9ydjooW1xcLlxcX1xcZF0rKS8sIFwiaWVcIl0sXG4gICAgICBbL2ZpcmVmb3hcXC8oW1xcLlxcX1xcZF0rKS8sIFwiZmlyZWZveFwiXSxcbiAgICAgIFsvY2hyb21lXFwvKFtcXC5cXF9cXGRdKykvLCBcImNocm9tZVwiXSxcbiAgICAgIFsvdmVyc2lvblxcLyhbXFwuXFxfXFxkXSspLio/c2FmYXJpLywgXCJzYWZhcmlcIl0sXG4gICAgICBbL21vYmlsZSBzYWZhcmkgKFtcXC5cXF9cXGRdKykvLCBcInNhZmFyaVwiXSxcbiAgICAgIFsvYW5kcm9pZC4qP3ZlcnNpb25cXC8oW1xcLlxcX1xcZF0rKS4qP3NhZmFyaS8sIFwiY29tLmFuZHJvaWQuYnJvd3NlclwiXSxcbiAgICAgIFsvY3Jpb3NcXC8oW1xcLlxcX1xcZF0rKS4qP3NhZmFyaS8sIFwiY2hyb21lXCJdLFxuICAgICAgWy9vcGVyYS8sIFwib3BlcmFcIl0sXG4gICAgICBbL29wZXJhXFwvKFtcXC5cXF9cXGRdKykvLCBcIm9wZXJhXCJdLFxuICAgICAgWy9vcGVyYSAoW1xcLlxcX1xcZF0rKS8sIFwib3BlcmFcIl0sXG4gICAgICBbL29wZXJhIG1pbmkuKj92ZXJzaW9uXFwvKFtcXC5cXF9cXGRdKykvLCBcIm9wZXJhLm1pbmlcIl0sXG4gICAgICBbL29waW9zXFwvKFthLXpcXC5cXF9cXGRdKykvLCBcIm9wZXJhXCJdLFxuICAgICAgWy9ibGFja2JlcnJ5LywgXCJibGFja2JlcnJ5XCJdLFxuICAgICAgWy9ibGFja2JlcnJ5Lio/dmVyc2lvblxcLyhbXFwuXFxfXFxkXSspLywgXCJibGFja2JlcnJ5XCJdLFxuICAgICAgWy9iYlxcZCsuKj92ZXJzaW9uXFwvKFtcXC5cXF9cXGRdKykvLCBcImJsYWNrYmVycnlcIl0sXG4gICAgICBbL3JpbS4qP3ZlcnNpb25cXC8oW1xcLlxcX1xcZF0rKS8sIFwiYmxhY2tiZXJyeVwiXSxcbiAgICAgIFsvaWNld2Vhc2VsXFwvKFtcXC5cXF9cXGRdKykvLCBcImljZXdlYXNlbFwiXSxcbiAgICAgIFsvZWRnZVxcLyhbXFwuXFxkXSspLywgXCJlZGdlXCJdXG4gICAgXSxcbiAgICBvczogW1xuICAgICAgWy9saW51eCAoKShbYS16XFwuXFxfXFxkXSspLywgXCJsaW51eFwiXSxcbiAgICAgIFsvbWFjIG9zIHgvLCBcIm1hY29zXCJdLFxuICAgICAgWy9tYWMgb3MgeC4qPyhbXFwuXFxfXFxkXSspLywgXCJtYWNvc1wiXSxcbiAgICAgIFsvb3MgKFtcXC5cXF9cXGRdKykgbGlrZSBtYWMgb3MvLCBcImlvc1wiXSxcbiAgICAgIFsvb3BlbmJzZCAoKShbYS16XFwuXFxfXFxkXSspLywgXCJvcGVuYnNkXCJdLFxuICAgICAgWy9hbmRyb2lkLywgXCJhbmRyb2lkXCJdLFxuICAgICAgWy9hbmRyb2lkIChbYS16XFwuXFxfXFxkXSspOy8sIFwiYW5kcm9pZFwiXSxcbiAgICAgIFsvbW96aWxsYVxcL1thLXpcXC5cXF9cXGRdKyBcXCgoPzptb2JpbGUpfCg/OnRhYmxldCkvLCBcImZpcmVmb3hvc1wiXSxcbiAgICAgIFsvd2luZG93c1xccyooPzpudCk/XFxzKihbXFwuXFxfXFxkXSspLywgXCJ3aW5kb3dzXCJdLFxuICAgICAgWy93aW5kb3dzIHBob25lLio/KFtcXC5cXF9cXGRdKykvLCBcIndpbmRvd3MucGhvbmVcIl0sXG4gICAgICBbL3dpbmRvd3MgbW9iaWxlLywgXCJ3aW5kb3dzLm1vYmlsZVwiXSxcbiAgICAgIFsvYmxhY2tiZXJyeS8sIFwiYmxhY2tiZXJyeW9zXCJdLFxuICAgICAgWy9iYlxcZCsvLCBcImJsYWNrYmVycnlvc1wiXSxcbiAgICAgIFsvcmltLio/b3NcXHMqKFtcXC5cXF9cXGRdKykvLCBcImJsYWNrYmVycnlvc1wiXVxuICAgIF0sXG4gICAgZGV2aWNlOiBbXG4gICAgICBbL2lwYWQvLCBcImlwYWRcIl0sXG4gICAgICBbL2lwaG9uZS8sIFwiaXBob25lXCJdLFxuICAgICAgWy9sdW1pYS8sIFwibHVtaWFcIl0sXG4gICAgICBbL2h0Yy8sIFwiaHRjXCJdLFxuICAgICAgWy9uZXh1cy8sIFwibmV4dXNcIl0sXG4gICAgICBbL2dhbGF4eSBuZXh1cy8sIFwiZ2FsYXh5Lm5leHVzXCJdLFxuICAgICAgWy9ub2tpYS8sIFwibm9raWFcIl0sXG4gICAgICBbLyBndFxcLS8sIFwiZ2FsYXh5XCJdLFxuICAgICAgWy8gc21cXC0vLCBcImdhbGF4eVwiXSxcbiAgICAgIFsveGJveC8sIFwieGJveFwiXSxcbiAgICAgIFsvKD86YmJcXGQrKXwoPzpibGFja2JlcnJ5KXwoPzogcmltICkvLCBcImJsYWNrYmVycnlcIl1cbiAgICBdXG4gIH07XG5cbiAgdmFyIFVOS05PV04gPSBcIlVua25vd25cIjtcblxuICB2YXIgcHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuXG4gIGZ1bmN0aW9uIFNuaWZmcigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBwcm9wZXJ0eU5hbWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHlOYW1lKSB7XG4gICAgICBzZWxmW3Byb3BlcnR5TmFtZV0gPSB7XG4gICAgICAgIG5hbWU6IFVOS05PV04sXG4gICAgICAgIHZlcnNpb246IFtdLFxuICAgICAgICB2ZXJzaW9uU3RyaW5nOiBVTktOT1dOXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGV0ZXJtaW5lUHJvcGVydHkoc2VsZiwgcHJvcGVydHlOYW1lLCB1c2VyQWdlbnQpIHtcbiAgICBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0uZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eU1hdGNoZXIpIHtcbiAgICAgIHZhciBwcm9wZXJ0eVJlZ2V4ID0gcHJvcGVydHlNYXRjaGVyWzBdO1xuICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBwcm9wZXJ0eU1hdGNoZXJbMV07XG5cbiAgICAgIHZhciBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaChwcm9wZXJ0eVJlZ2V4KTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHNlbGZbcHJvcGVydHlOYW1lXS5uYW1lID0gcHJvcGVydHlWYWx1ZTtcblxuICAgICAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICBzZWxmW3Byb3BlcnR5TmFtZV0udmVyc2lvblN0cmluZyA9IG1hdGNoWzJdO1xuICAgICAgICAgIHNlbGZbcHJvcGVydHlOYW1lXS52ZXJzaW9uID0gW107XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICBzZWxmW3Byb3BlcnR5TmFtZV0udmVyc2lvblN0cmluZyA9IG1hdGNoWzFdLnJlcGxhY2UoL18vZywgXCIuXCIpO1xuICAgICAgICAgIHNlbGZbcHJvcGVydHlOYW1lXS52ZXJzaW9uID0gcGFyc2VWZXJzaW9uKG1hdGNoWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmW3Byb3BlcnR5TmFtZV0udmVyc2lvblN0cmluZyA9IFVOS05PV047XG4gICAgICAgICAgc2VsZltwcm9wZXJ0eU5hbWVdLnZlcnNpb24gPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VWZXJzaW9uKHZlcnNpb25TdHJpbmcpIHtcbiAgICByZXR1cm4gdmVyc2lvblN0cmluZy5zcGxpdCgvW1xcLl9dLykubWFwKGZ1bmN0aW9uKHZlcnNpb25QYXJ0KSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQodmVyc2lvblBhcnQpO1xuICAgIH0pO1xuICB9XG5cbiAgU25pZmZyLnByb3RvdHlwZS5zbmlmZiA9IGZ1bmN0aW9uKHVzZXJBZ2VudFN0cmluZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdXNlckFnZW50ID0gKHVzZXJBZ2VudFN0cmluZyB8fCBuYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBwcm9wZXJ0eU5hbWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHlOYW1lKSB7XG4gICAgICBkZXRlcm1pbmVQcm9wZXJ0eShzZWxmLCBwcm9wZXJ0eU5hbWUsIHVzZXJBZ2VudCk7XG4gICAgfSk7XG4gIH07XG5cblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNuaWZmcjtcbiAgfSBlbHNlIHtcbiAgICBob3N0LlNuaWZmciA9IG5ldyBTbmlmZnIoKTtcbiAgICBob3N0LlNuaWZmci5zbmlmZihuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxufSkodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc25pZmZyL3NyYy9zbmlmZnIuanNcbi8vIG1vZHVsZSBpZCA9IDI3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xudmFyIHN0eWxlc0luRG9tID0ge30sXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuXHRcdHZhciBtZW1vO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG1lbW87XG5cdFx0fTtcblx0fSxcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHNlbGYubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcblx0fSksXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXHR9KSxcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdLFxuXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vZml4VXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YXR0YWNoVGFnQXR0cnMoc3R5bGVFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhsaW5rRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XG5cdHJldHVybiBsaW5rRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gYXR0YWNoVGFnQXR0cnMoZWxlbWVudCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcblx0XHRpZihuZXdPYmopIHtcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0LyogSWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpe1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XG5cblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKVxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmwgKlxcKCAqKC4rPykgKlxcKS9nLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qc1xuLy8gbW9kdWxlIGlkID0gMjc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9tYWluLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L25qcC10YWcvc3JjL3N0eWxlcy9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBzcHJpdGUgPSByZXF1aXJlKFwiL1VzZXJzL25laWxhbmRlcnNvbi9TaXRlcy90YWctbGlnaHRzaG93L25vZGVfbW9kdWxlcy9zdmctc3ByaXRlLWxvYWRlci9saWIvd2ViL2dsb2JhbC1zcHJpdGVcIik7XG52YXIgaW1hZ2UgPSBcIjxzeW1ib2wgdmlld0JveD1cXFwiMCAwIDggOFxcXCIgaWQ9XFxcImljb24tcHV6emxlLXBpZWNlXFxcIiA+IDxwYXRoIGQ9XFxcIk0zIDBjLS4yOCAwLS41NC4xLS43Mi4yOC0uMTguMTgtLjI4LjQ0LS4yOC43MiAwIC4yOC4xOC40OC4yOC43Mi4wMy4wNi4wMy4xNi4wMy4yOGgtMi4zMXY2aDIuMzFjMC0uMTItLjAxLS4yMi0uMDMtLjI4LS4xLS4yNC0uMjgtLjQ0LS4yOC0uNzIgMC0uMjguMS0uNTQuMjgtLjcyLjE4LS4xOC40NC0uMjguNzItLjI4LjI4IDAgLjU0LjEuNzIuMjguMTguMTguMjguNDQuMjguNzIgMCAuMjgtLjE4LjQ4LS4yOC43Mi0uMDMuMDYtLjAzLjE2LS4wMy4yOGgyLjMxdi0yLjMxYy4xMiAwIC4yMi4wMS4yOC4wMy4yNC4xLjQ0LjI4LjcyLjI4LjI4IDAgLjU0LS4xLjcyLS4yOC4xOC0uMTguMjgtLjQ0LjI4LS43MiAwLS4yOC0uMS0uNTQtLjI4LS43Mi0uMTgtLjE4LS40NC0uMjgtLjcyLS4yOC0uMjggMC0uNDguMTgtLjcyLjI4LS4wNi4wMy0uMTYuMDMtLjI4LjAzdi0yLjMxaC0yLjMxYzAtLjEyLjAxLS4yMi4wMy0uMjguMS0uMjQuMjgtLjQ0LjI4LS43MiAwLS4yOC0uMS0uNTQtLjI4LS43Mi0uMTgtLjE4LS40NC0uMjgtLjcyLS4yOHpcXFwiLz4gPC9zeW1ib2w+XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHNwcml0ZS5hZGQoaW1hZ2UsIFwiaWNvbi1wdXp6bGUtcGllY2VcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvcHV6emxlLXBpZWNlLnN2Z1xuLy8gbW9kdWxlIGlkID0gMjg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIHNwcml0ZSA9IHJlcXVpcmUoXCIvVXNlcnMvbmVpbGFuZGVyc29uL1NpdGVzL3RhZy1saWdodHNob3cvbm9kZV9tb2R1bGVzL3N2Zy1zcHJpdGUtbG9hZGVyL2xpYi93ZWIvZ2xvYmFsLXNwcml0ZVwiKTtcbnZhciBpbWFnZSA9IFwiPHN5bWJvbCB2aWV3Qm94PVxcXCIwIDAgOCA4XFxcIiBpZD1cXFwiaWNvbi10YWdcXFwiID4gPHBhdGggZD1cXFwiTTAgMHYzbDUgNSAzLTMtNS01aC0zem0yIDFjLjU1IDAgMSAuNDUgMSAxcy0uNDUgMS0xIDEtMS0uNDUtMS0xIC40NS0xIDEtMXpcXFwiLz4gPC9zeW1ib2w+XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHNwcml0ZS5hZGQoaW1hZ2UsIFwiaWNvbi10YWdcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L25qcC10YWcvc3JjL2ltZy9zdmcvdGFnLnN2Z1xuLy8gbW9kdWxlIGlkID0gMjg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIHNwcml0ZSA9IHJlcXVpcmUoXCIvVXNlcnMvbmVpbGFuZGVyc29uL1NpdGVzL3RhZy1saWdodHNob3cvbm9kZV9tb2R1bGVzL3N2Zy1zcHJpdGUtbG9hZGVyL2xpYi93ZWIvZ2xvYmFsLXNwcml0ZVwiKTtcbnZhciBpbWFnZSA9IFwiPHN5bWJvbCB2aWV3Qm94PVxcXCIwIDAgOCA4XFxcIiBpZD1cXFwiaWNvbi10ZXh0XFxcIiA+IDxwYXRoIGQ9XFxcIk0wIDB2MmguNWMwLS41NS40NS0xIDEtMWgxLjV2NS41YzAgLjI4LS4yMi41LS41LjVoLS41djFoNHYtMWgtLjVjLS4yOCAwLS41LS4yMi0uNS0uNXYtNS41aDEuNWMuNTUgMCAxIC40NSAxIDFoLjV2LTJoLTh6XFxcIi8+IDwvc3ltYm9sPlwiO1xubW9kdWxlLmV4cG9ydHMgPSBzcHJpdGUuYWRkKGltYWdlLCBcImljb24tdGV4dFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbmpwLXRhZy9zcmMvaW1nL3N2Zy90ZXh0LnN2Z1xuLy8gbW9kdWxlIGlkID0gMjg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmlmZnIgPSByZXF1aXJlKCdzbmlmZnInKTtcblxuLyoqXG4gKiBMaXN0IG9mIFNWRyBhdHRyaWJ1dGVzIHRvIGZpeCB1cmwgdGFyZ2V0IGluIHRoZW1cbiAqIEB0eXBlIHtzdHJpbmdbXX1cbiAqL1xudmFyIGZpeEF0dHJpYnV0ZXMgPSBbXG4gICdjbGlwUGF0aCcsXG4gICdjb2xvclByb2ZpbGUnLFxuICAnc3JjJyxcbiAgJ2N1cnNvcicsXG4gICdmaWxsJyxcbiAgJ2ZpbHRlcicsXG4gICdtYXJrZXInLFxuICAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyTWlkJyxcbiAgJ21hcmtlckVuZCcsXG4gICdtYXNrJyxcbiAgJ3N0cm9rZSdcbl07XG5cbi8qKlxuICogUXVlcnkgdG8gZmluZCdlbVxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIGZpeEF0dHJpYnV0ZXNRdWVyeSA9ICdbJyArIGZpeEF0dHJpYnV0ZXMuam9pbignXSxbJykgKyAnXSc7XG4vKipcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBVUklfRlVOQ19SRUdFWCA9IC9edXJsXFwoKC4qKVxcKSQvO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXktbGlrZSB0byBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IGFycmF5TGlrZVxuICogQHJldHVybnMge0FycmF5LjwqPn1cbiAqL1xuZnVuY3Rpb24gYXJyYXlGcm9tKGFycmF5TGlrZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlLCAwKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGZvcmJpZGRlbiBzeW1ib2xzIHdoaWNoIGNhbm5vdCBiZSBkaXJlY3RseSB1c2VkIGluc2lkZSBhdHRyaWJ1dGVzIHdpdGggdXJsKC4uLikgY29udGVudC5cbiAqIEFkZHMgbGVhZGluZyBzbGFzaCBmb3IgdGhlIGJyYWNrZXRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGVuY29kZWQgdXJsXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVybEZvckVtYmVkZGluZyh1cmwpIHtcbiAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXFxcXCQmXCIpO1xufVxuXG4vKipcbiAqIFJlcGxhY2VzIHByZWZpeCBpbiBgdXJsKClgIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtFbGVtZW50fSBzdmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50VXJsUHJlZml4XG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3VXJsUHJlZml4XG4gKi9cbmZ1bmN0aW9uIGJhc2VVcmxXb3JrQXJvdW5kKHN2ZywgY3VycmVudFVybFByZWZpeCwgbmV3VXJsUHJlZml4KSB7XG4gIHZhciBub2RlcyA9IHN2Zy5xdWVyeVNlbGVjdG9yQWxsKGZpeEF0dHJpYnV0ZXNRdWVyeSk7XG5cbiAgaWYgKCFub2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFycmF5RnJvbShub2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICghbm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXJyYXlGcm9tKG5vZGUuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZS5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKGZpeEF0dHJpYnV0ZXMuaW5kZXhPZihhdHRyaWJ1dGVOYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gVVJJX0ZVTkNfUkVHRVguZXhlYyhub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSk7XG5cbiAgICAgICAgLy8gRG8gbm90IHRvdWNoIHVybHMgd2l0aCB1bmV4cGVjdGVkIHByZWZpeFxuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0uaW5kZXhPZihjdXJyZW50VXJsUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgIHZhciByZWZlcmVuY2VVcmwgPSBlbmNvZGVVcmxGb3JFbWJlZGRpbmcobmV3VXJsUHJlZml4ICsgbWF0Y2hbMV0uc3BsaXQoY3VycmVudFVybFByZWZpeClbMV0pO1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICd1cmwoJyArIHJlZmVyZW5jZVVybCArICcpJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQmVjYXVzZSBvZiBGaXJlZm94IGJ1ZyAjMzUzNTc1IGdyYWRpZW50cyBhbmQgcGF0dGVybnMgZG9uJ3Qgd29yayBpZiB0aGV5IGFyZSB3aXRoaW4gYSBzeW1ib2wuXG4gKiBUbyB3b3JrYXJvdW5kIHRoaXMgd2UgbW92ZSB0aGUgZ3JhZGllbnQgZGVmaW5pdGlvbiBvdXRzaWRlIHRoZSBzeW1ib2wgZWxlbWVudFxuICogQHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNTM1NzVcbiAqIEBwYXJhbSB7RWxlbWVudH0gc3ZnXG4gKi9cbnZhciBGaXJlZm94U3ltYm9sQnVnV29ya2Fyb3VuZCA9IGZ1bmN0aW9uIChzdmcpIHtcbiAgdmFyIGRlZnMgPSBzdmcucXVlcnlTZWxlY3RvcignZGVmcycpO1xuXG4gIHZhciBtb3ZlVG9EZWZzRWxlbXMgPSBzdmcucXVlcnlTZWxlY3RvckFsbCgnc3ltYm9sIGxpbmVhckdyYWRpZW50LCBzeW1ib2wgcmFkaWFsR3JhZGllbnQsIHN5bWJvbCBwYXR0ZXJuJyk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtb3ZlVG9EZWZzRWxlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBkZWZzLmFwcGVuZENoaWxkKG1vdmVUb0RlZnNFbGVtc1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRml4IGZvciBicm93c2VyIChJRSwgbWF5YmUgb3RoZXIgdG9vKSB3aGljaCBhcmUgdGhyb3dpbmcgJ1dyb25nRG9jdW1lbnRFcnJvcidcbiAqIGlmIHlvdSBpbnNlcnQgYW4gZWxlbWVudCB3aGljaCBpcyBub3QgcGFydCBvZiB0aGUgZG9jdW1lbnRcbiAqIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83OTgxMTAwL2hvdy1kby1pLWR5bmFtaWNhbGx5LWluc2VydC1hbi1zdmctaW1hZ2UtaW50by1odG1sIzc5ODY1MTlcbiAqIEBwYXJhbSB7RWxlbWVudH0gc3ZnXG4gKi9cbmZ1bmN0aW9uIGltcG9ydFN2ZyhzdmcpIHtcbiAgdHJ5IHtcbiAgICBpZiAoZG9jdW1lbnQuaW1wb3J0Tm9kZSkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmltcG9ydE5vZGUoc3ZnLCB0cnVlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cblxuICByZXR1cm4gc3ZnO1xufVxuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciBERUZBVUxUX1VSSV9QUkVGSVggPSAnIyc7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIHhMaW5rSHJlZiA9ICd4bGluazpocmVmJztcbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIHhMaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciBzdmdPcGVuaW5nID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiJyArIHhMaW5rTlMgKyAnXCInO1xuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgc3ZnQ2xvc2luZyA9ICc8L3N2Zz4nO1xuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgY29udGVudFBsYWNlSG9sZGVyID0gJ3tjb250ZW50fSc7XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgU1ZHIHNwcml0ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFNwcml0ZSgpIHtcbiAgdmFyIGJhc2VFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jhc2UnKVswXTtcbiAgdmFyIGN1cnJlbnRVcmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnIycpWzBdO1xuICB2YXIgYmFzZVVybCA9IGJhc2VFbGVtZW50ICYmIGJhc2VFbGVtZW50LmhyZWY7XG4gIHRoaXMudXJsUHJlZml4ID0gYmFzZVVybCAmJiBiYXNlVXJsICE9PSBjdXJyZW50VXJsID8gY3VycmVudFVybCArIERFRkFVTFRfVVJJX1BSRUZJWCA6IERFRkFVTFRfVVJJX1BSRUZJWDtcblxuICB2YXIgc25pZmZyID0gbmV3IFNuaWZmcigpO1xuICBzbmlmZnIuc25pZmYoKTtcbiAgdGhpcy5icm93c2VyID0gc25pZmZyLmJyb3dzZXI7XG4gIHRoaXMuY29udGVudCA9IFtdO1xuXG4gIGlmICh0aGlzLmJyb3dzZXIubmFtZSAhPT0gJ2llJyAmJiBiYXNlVXJsKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Nwcml0ZUxvYWRlckxvY2F0aW9uVXBkYXRlZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgY3VycmVudFByZWZpeCA9IHRoaXMudXJsUHJlZml4O1xuICAgICAgdmFyIG5ld1VybFByZWZpeCA9IGUuZGV0YWlsLm5ld1VybC5zcGxpdChERUZBVUxUX1VSSV9QUkVGSVgpWzBdICsgREVGQVVMVF9VUklfUFJFRklYO1xuICAgICAgYmFzZVVybFdvcmtBcm91bmQodGhpcy5zdmcsIGN1cnJlbnRQcmVmaXgsIG5ld1VybFByZWZpeCk7XG4gICAgICB0aGlzLnVybFByZWZpeCA9IG5ld1VybFByZWZpeDtcblxuICAgICAgaWYgKHRoaXMuYnJvd3Nlci5uYW1lID09PSAnZmlyZWZveCcgfHwgdGhpcy5icm93c2VyLm5hbWUgPT09ICdlZGdlJyB8fCB0aGlzLmJyb3dzZXIubmFtZSA9PT0gJ2Nocm9tZScgJiYgdGhpcy5icm93c2VyLnZlcnNpb25bMF0gPj0gNDkpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3VzZVsqfGhyZWZdJykpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIGhyZWYgPSBub2RlLmdldEF0dHJpYnV0ZSh4TGlua0hyZWYpO1xuICAgICAgICAgIGlmIChocmVmICYmIGhyZWYuaW5kZXhPZihjdXJyZW50UHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyh4TGlua05TLCB4TGlua0hyZWYsIG5ld1VybFByZWZpeCArIGhyZWYuc3BsaXQoREVGQVVMVF9VUklfUFJFRklYKVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG59XG5cblNwcml0ZS5zdHlsZXMgPSBbJ3Bvc2l0aW9uOmFic29sdXRlJywgJ3dpZHRoOjAnLCAnaGVpZ2h0OjAnXTtcblxuU3ByaXRlLnNwcml0ZVRlbXBsYXRlID0gZnVuY3Rpb24oKXsgcmV0dXJuIHN2Z09wZW5pbmcgKyAnIHN0eWxlPVwiJysgU3ByaXRlLnN0eWxlcy5qb2luKCc7JykgKydcIj48ZGVmcz4nICsgY29udGVudFBsYWNlSG9sZGVyICsgJzwvZGVmcz4nICsgc3ZnQ2xvc2luZzsgfVxuU3ByaXRlLnN5bWJvbFRlbXBsYXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBzdmdPcGVuaW5nICsgJz4nICsgY29udGVudFBsYWNlSG9sZGVyICsgc3ZnQ2xvc2luZzsgfVxuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxTdHJpbmc+fVxuICovXG5TcHJpdGUucHJvdG90eXBlLmNvbnRlbnQgPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqL1xuU3ByaXRlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoY29udGVudCwgaWQpIHtcbiAgaWYgKHRoaXMuc3ZnKSB7XG4gICAgdGhpcy5hcHBlbmRTeW1ib2woY29udGVudCk7XG4gIH1cblxuICB0aGlzLmNvbnRlbnQucHVzaChjb250ZW50KTtcblxuICByZXR1cm4gREVGQVVMVF9VUklfUFJFRklYICsgaWQ7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gY29udGVudFxuICogQHBhcmFtIHRlbXBsYXRlXG4gKiBAcmV0dXJucyB7RWxlbWVudH1cbiAqL1xuU3ByaXRlLnByb3RvdHlwZS53cmFwU1ZHID0gZnVuY3Rpb24gKGNvbnRlbnQsIHRlbXBsYXRlKSB7XG4gIHZhciBzdmdTdHJpbmcgPSB0ZW1wbGF0ZS5yZXBsYWNlKGNvbnRlbnRQbGFjZUhvbGRlciwgY29udGVudCk7XG5cbiAgdmFyIHN2ZyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc3ZnU3RyaW5nLCAnaW1hZ2Uvc3ZnK3htbCcpLmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGltcG9ydGVkU3ZnID0gaW1wb3J0U3ZnKHN2Zyk7XG5cbiAgaWYgKHRoaXMuYnJvd3Nlci5uYW1lICE9PSAnaWUnICYmIHRoaXMudXJsUHJlZml4KSB7XG4gICAgYmFzZVVybFdvcmtBcm91bmQoaW1wb3J0ZWRTdmcsIERFRkFVTFRfVVJJX1BSRUZJWCwgdGhpcy51cmxQcmVmaXgpO1xuICB9XG5cbiAgcmV0dXJuIGltcG9ydGVkU3ZnO1xufTtcblxuU3ByaXRlLnByb3RvdHlwZS5hcHBlbmRTeW1ib2wgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICB2YXIgc3ltYm9sID0gdGhpcy53cmFwU1ZHKGNvbnRlbnQsIFNwcml0ZS5zeW1ib2xUZW1wbGF0ZSgpKS5jaGlsZE5vZGVzWzBdO1xuXG4gIHRoaXMuc3ZnLnF1ZXJ5U2VsZWN0b3IoJ2RlZnMnKS5hcHBlbmRDaGlsZChzeW1ib2wpO1xuICBpZiAodGhpcy5icm93c2VyLm5hbWUgPT09ICdmaXJlZm94Jykge1xuICAgIEZpcmVmb3hTeW1ib2xCdWdXb3JrYXJvdW5kKHRoaXMuc3ZnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5TcHJpdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyKCkpO1xuICByZXR1cm4gd3JhcHBlci5pbm5lckhUTUw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFt0YXJnZXRdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmVwZW5kPXRydWVdXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IFJlbmRlcmVkIHNwcml0ZSBub2RlXG4gKi9cblNwcml0ZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHRhcmdldCwgcHJlcGVuZCkge1xuICB0YXJnZXQgPSB0YXJnZXQgfHwgbnVsbDtcbiAgcHJlcGVuZCA9IHR5cGVvZiBwcmVwZW5kID09PSAnYm9vbGVhbicgPyBwcmVwZW5kIDogdHJ1ZTtcblxuICB2YXIgc3ZnID0gdGhpcy53cmFwU1ZHKHRoaXMuY29udGVudC5qb2luKCcnKSwgU3ByaXRlLnNwcml0ZVRlbXBsYXRlKCkpO1xuXG4gIGlmICh0aGlzLmJyb3dzZXIubmFtZSA9PT0gJ2ZpcmVmb3gnKSB7XG4gICAgRmlyZWZveFN5bWJvbEJ1Z1dvcmthcm91bmQoc3ZnKTtcbiAgfVxuXG4gIGlmICh0YXJnZXQpIHtcbiAgICBpZiAocHJlcGVuZCAmJiB0YXJnZXQuY2hpbGROb2Rlc1swXSkge1xuICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShzdmcsIHRhcmdldC5jaGlsZE5vZGVzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN2Zyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zdmcgPSBzdmc7XG5cbiAgcmV0dXJuIHN2Zztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3ByaXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N2Zy1zcHJpdGUtbG9hZGVyL2xpYi93ZWIvc3ByaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gcmVxdWlyZS5lbnN1cmUoW10sICgpID0+IHtcblx0Y29uc3QgQXBwID0gcmVxdWlyZSgnbmpwLXRhZycpLmRlZmF1bHQ7XG5cblx0dmFyIGFwcCA9IG5ldyBBcHAoe1xuXHRcdG9uRWxlbWVudFJlbmRlcjogZnVuY3Rpb24obWFya3VwLCBkcm9wbGV0LCB6b25lLCBpc19vdXRwdXQpIHtcblx0XHRcdGlmIChkcm9wbGV0Lm5hbWUgPT09ICdMZXR0ZXIgYnV0dG9uJyAmJiBpc19vdXRwdXQpIHtcblx0XHRcdFx0bWFya3VwLmlubmVySFRNTCA9ICc8c3Bhbj4nICsgbWFya3VwLmlubmVySFRNTCArICc8L3NwYW4+Jztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hcmt1cDtcblx0XHR9XG5cdH0pO1xuXG5cdGFwcC5sb2FkKFxuXHRcdCd0ZW1wbGF0ZXMvZGVmYXVsdC5odG1sJyxcblx0XHQndGVtcGxhdGVzL3BhbGxldC5qc29uJ1xuXHQpLmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuXHR9KTtcbi8vIH0sICdhcHAnKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvdGFnLmpzIiwiLyoqXG4gKiBGb3JtRmllbGQgZGF0YSBvYmplY3RcbiAqIEB0eXBlZGVmIEZvcm1GaWVsZERhdGFcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVpcmVkXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbF1cbiAqIEBwcm9wZXJ0eSB7bWl4ZWR9IFtvcHRpb25zXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwbGFjZWhvbGRlcl1cbiAqIEBwcm9wZXJ0eSB7bWl4ZWR9IFt2YWx1ZV1cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmllbGQgPSBGb3JtRmllbGQoJ2ZpZWxkbmFtZScsICdkcm9wZG93bicsIHtcbiAqIFx0J2xhYmVsJzogJ1BsZWFzZSBzZWxlY3QgYSB2YWx1ZScsXG4gKiBcdCdvcHRpb25zJzogWydWYWx1ZSAxJywgJ1ZhbHVlIDInLCAnVmFsdWUgMyddLFxuICogXHQndmFsdWUnOiAnVmFsdWUgMidcbiAqIH0pO1xuICovXG5cbiAvKipcbiAqIFRoaXMgY2xhc3MgZXhpc3RzIGFsbW9zdCBlbnRpcmVseSBmb3IgZGF0YSBjb25zaXN0ZW5jeS5cbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBGaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBJbnB1dCB0eXBlLlxuICogQHBhcmFtIHtGb3JtRmllbGREYXRhfSBkYXRhIC0gRmllbGQgZGF0YS5cbiAqL1xudmFyIEZvcm1GaWVsZCA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIGRhdGEgPSB7fSkge1xuXHR0aGlzLl9zZXROYW1lQW5kVHlwZShuYW1lLCB0eXBlKTtcblx0dGhpcy5fdmFsaWRhdGVBbmRTZXQoZGF0YSk7XG59O1xuXG5Gb3JtRmllbGQucHJvdG90eXBlID0ge1xuXHRfc2V0TmFtZUFuZFR5cGU6IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcblx0XHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZmllbGQgbmFtZSBcIicgKyBuYW1lICsgJ1wiJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fFxuXHRcdFx0Rm9ybUZpZWxkLnZhbGlkVHlwZXMuaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmaWVsZCB0eXBlIFwiJyArIHR5cGUgKyAnXCInKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR9XG5cdH0sXG5cblx0X3ZhbGlkYXRlQW5kU2V0OiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0dmFyIF9kYXRhID0gT2JqZWN0LmRlZXBBc3NpZ24oe30sIGRhdGEpO1xuXG5cdFx0aWYgKEZvcm1GaWVsZC52YWxpZGF0ZURhdGFBdHRyaWJ1dGUoXG5cdFx0XHRcdF9kYXRhLFxuXHRcdFx0XHR0aGlzLm5hbWUsXG5cdFx0XHRcdCdFcnJvciB3aXRoIEZvcm1GaWVsZCBkYXRhIGF0dHJpYnV0ZSdcblx0XHRcdCkpIHtcblx0XHRcdHRoaXMuZGF0YSA9IF9kYXRhO1xuXG5cdFx0XHQvLyBleHRlcm5hbGlzZSByZW1haW5pbmcgb3B0aW9uc1xuXHRcdFx0dGhpcy5yZXF1aXJlZCA9IGRhdGEucmVxdWlyZWQ7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBkYXRhLm9wdGlvbnM7XG5cdFx0XHR0aGlzLnBsYWNlaG9sZGVyID0gZGF0YS5wbGFjZWhvbGRlcjtcblx0XHRcdHRoaXMubGFiZWwgPSBkYXRhLmxhYmVsO1xuXG5cdFx0XHR0aGlzLnZhbHVlID0gKHR5cGVvZiBkYXRhLnZhbHVlICE9PSAndW5kZWZpbmVkJykgPyBkYXRhLnZhbHVlIDogJyc7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIEVuc3VyZXMgYSBmb3JtIGZpZWxkJ3MgZGF0YSBhdHRyaWJ1dGVzIGFyZSB2YWxpZFxuICovXG5Gb3JtRmllbGQudmFsaWRhdGVEYXRhQXR0cmlidXRlID0gZnVuY3Rpb24oZGF0YSwgaXRlbSwgZXJyb3JfcHJlZml4KSB7XG5cdHZhciBlcnJvciA9IGVycm9yX3ByZWZpeCArICcgJyArIGl0ZW0gKyAnIC0gJztcblxuXHQvLyBjaGVjayBcInJlcXVpcmVkXCIgaXMgYSBib29sZWFuLCBpZiBkZWZpbmVkXG5cdGlmICh0eXBlb2YgZGF0YS5yZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRhdGEucmVxdWlyZWQgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvciArICdcInJlcXVpcmVkXCIgYXR0cmlidXRlIGlzbuKAmXQgYSBib29sZWFuIHRydWUgb3IgZmFsc2UnKTtcblx0fVxuXG5cdC8vIGNoZWNrIFwib3B0aW9uc1wiIGlzIHZhbGlkXG5cdGlmICh0eXBlb2YgZGF0YS5vcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuXHRcdEZvcm1GaWVsZC5fdmFsaWRhdGVPcHRpb25zU2V0dGluZyhkYXRhLm9wdGlvbnMsIGVycm9yKTtcblx0fVxuXG5cdC8vIGNoZWNrIFwicGxhY2Vob2xkZXJcIiBpcyB2YWxpZFxuXHRpZiAodHlwZW9mIGRhdGEucGxhY2Vob2xkZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkYXRhLnBsYWNlaG9sZGVyICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvciArICdcInBsYWNlaG9sZGVyXCIgYXR0cmlidXRlIGlzbuKAmXQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdC8vIGNoZWNrIFwidmFsdWVcIiBpcyB2YWxpZFxuXHRpZiAodHlwZW9mIGRhdGEudmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0Rm9ybUZpZWxkLl92YWxpZGF0ZVZhbHVlU2V0dGluZyhkYXRhLnZhbHVlLCBkYXRhLm9wdGlvbnMsIGVycm9yKTtcblx0fVxuXG5cdC8vIGNoZWNrIFwibGFiZWxcIiBpcyB2YWxpZFxuXHRpZiAodHlwZW9mIGRhdGEubGFiZWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkYXRhLmxhYmVsICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGVycm9yICsgJ1wibGFiZWxcIiBhdHRyaWJ1dGUgaXNu4oCZdCBhIHN0cmluZydcblx0XHQpO1xuXHR9XG5cblx0Ly8gY2hlY2sgXCJtYXhsZW5ndGhcIiBpcyB2YWxpZFxuXHRpZiAodHlwZW9mIGRhdGEubWF4bGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdCh0eXBlb2YgZGF0YS5tYXhsZW5ndGggIT09ICdudW1iZXInIHx8ZGF0YS5tYXhsZW5ndGggPCAxKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGVycm9yICsgJ1wibWF4bGVuZ3RoXCIgYXR0cmlidXRlIGlzbuKAmXQgYSBudW1iZXIgb3IgYWJvdmUgemVybydcblx0XHQpO1xuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5Gb3JtRmllbGQuX3ZhbGlkYXRlT3B0aW9uc1NldHRpbmcgPSBmdW5jdGlvbihvcHRpb25zLCBlcnJvcl9wcmVmaXgpIHtcblx0dmFyIGtleSwgYSxcblx0XHRlcnJvciA9IGVycm9yX3ByZWZpeCArICdcIm9wdGlvbnNcIiBpcyBvZiBhbiB1bnJlY29nbmlzZWQgdHlwZSc7XG5cblx0aWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcblx0XHRmb3IgKGEgPSAwOyBhIDwgb3B0aW9ucy5sZW5ndGg7IGEgKz0gMSkge1xuXHRcdFx0aWYgKHR5cGVvZiBvcHRpb25zW2FdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuXHRcdGZvciAoa2V5IGluIG9wdGlvbnMpIHtcblx0XHRcdGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3B0aW9uc1trZXldICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3IgKyAnIC0gb2JqZWN0IHZhbHVlcyBtdXN0IGJlIGEgc2ltcGxlIGtleS92YWx1ZSBzZXQnKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAob3B0aW9ucyA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJvciArICcgLSBvcHRpb25zIGNhbm5vdCBiZSBudWxsJyk7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkZvcm1GaWVsZC5fdmFsaWRhdGVWYWx1ZVNldHRpbmcgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucywgZXJyb3JfcHJlZml4KSB7XG5cdGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcblx0XHR0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmXG5cdFx0dHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGVycm9yX3ByZWZpeCArICdcInZhbHVlXCIgaXMgb2YgYW4gdW5yZWNvZ25pc2VkIHR5cGUnXG5cdFx0KTtcblx0fVxuXG5cdGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHQvLyB2YWxpZGF0ZSBhZ2FpbnN0IG9wdGlvbnNcblx0XHRpZiAoXG5cdFx0XHQoQXJyYXkuaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLmluZGV4T2YodmFsdWUpID09PSAtMSkgfHxcblx0XHRcdChcblx0XHRcdFx0dHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmXG5cdFx0XHRcdCFBcnJheS5pc0FycmF5KG9wdGlvbnMpICYmXG5cdFx0XHRcdCFvcHRpb25zW3ZhbHVlXVxuXHRcdFx0KVxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRlcnJvcl9wcmVmaXggKyAnXCJ2YWx1ZVwiIGF0dHJpYnV0ZSBjb250YWlucyBhbiBvcHRpb24gdGhhdCBkb2VzbuKAmXQgZXhpc3QnXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxufTtcblxuRm9ybUZpZWxkLnZhbGlkVHlwZXMgPSBbXG5cdCd0ZXh0Jyxcblx0J2xvbmd0ZXh0Jyxcblx0J2Ryb3Bkb3duJyxcblx0J2NoZWNrYm94Jyxcblx0J3JhZGlvJ1xuXTtcblxuZXhwb3J0IGRlZmF1bHQgRm9ybUZpZWxkO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvbGliL0Zvcm1GaWVsZC5qcyIsImltcG9ydCBSZWFjdCwgeyBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBjb25zdCBHTFlQSFMgPSB7XG5cdFRFWFQ6IHJlcXVpcmUoJy4uLy4uL2ltZy9zdmcvdGV4dC5zdmcnKSxcblx0UFVaWkxFX1BJRUNFOiByZXF1aXJlKCcuLi8uLi9pbWcvc3ZnL3B1enpsZS1waWVjZS5zdmcnKSxcblx0VEFHOiByZXF1aXJlKCcuLi8uLi9pbWcvc3ZnL3RhZy5zdmcnKVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIEljb24ocHJvcHMpIHtcblx0cmV0dXJuIChcblx0XHQ8c3ZnIGNsYXNzTmFtZT1cImljb25cIiB3aWR0aD17cHJvcHMud2lkdGh9IGhlaWdodD17cHJvcHMuaGVpZ2h0fT5cblx0XHRcdDx1c2UgeGxpbmtIcmVmPXtwcm9wcy5nbHlwaH0vPlxuXHRcdDwvc3ZnPlxuXHQpO1xufVxuXG5JY29uLmRlZmF1bHRQcm9wcyA9IHtcblx0d2lkdGg6IDE2LFxuXHRoZWlnaHQ6IDE2XG59O1xuXG5JY29uLnByb3BUeXBlcyA9IHtcblx0d2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG5cdGhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcblx0Z2x5cGg6IFByb3BUeXBlcy5zdHJpbmcsXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvY29tcG9uZW50cy92aWV3cy9JY29uLmpzeCIsInZhciBsb2NhbFN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlLFxuXHRKU09OID0gSlNPTiB8fCB3aW5kb3cuSlNPTjtcblxuLyoqXG4gKiBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfU3RvcmFnZV9BUEkvVXNpbmdfdGhlX1dlYl9TdG9yYWdlX0FQSVxuICovXG5jb25zdCBjaGVja1N0b3JhZ2UgPSBmdW5jdGlvbih0eXBlKSB7XG5cdHRyeSB7XG5cdFx0dmFyIHN0b3JhZ2UgPSB3aW5kb3dbdHlwZV0sXG5cdFx0XHR4ID0gJ19fdGFnX3N0b3JhZ2VfdGVzdF9fJztcblx0XHRzdG9yYWdlLnNldEl0ZW0oeCwgeCk7XG5cdFx0c3RvcmFnZS5yZW1vdmVJdGVtKHgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbnZhciBDb21tdW5pY2F0b3IgPSBmdW5jdGlvbihpZCwgb3JpZ2luLCBjYWxsYmFja3MgPSB7fSkge1xuXHRpZiAoIWNoZWNrU3RvcmFnZSgnbG9jYWxTdG9yYWdlJykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBFcnJvcignUGxlYXNlIGNob29zZSBhIHN0cmluZy1iYXNlZCBJRCBmb3IgdGhlIGd1ZXN0LicpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY2hvb3NlIGEgc3RyaW5nLWJhc2VkIG9yaWdpbiBhZGRyZXNzLicpO1xuXHR9XG5cblx0dGhpcy5fc2V0dGluZ3MgPSB7XG5cdFx0bmFtZTogJ3RhZy1jb21tLWRhdGEnXG5cdH07XG5cblx0dGhpcy5fZ3Vlc3RzID0ge307XG5cdHRoaXMuX3F1ZXVlID0ge307XG5cdHRoaXMuaWQgPSBpZDtcblxuXHR0aGlzLl9vcmlnaW4gPSBvcmlnaW47XG5cdHRoaXMuX2NhbGxiYWNrcyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdG1lc3NhZ2U6IG51bGxcblx0fSwgY2FsbGJhY2tzKTtcblxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX3JlY2VpdmVNZXNzYWdlLmJpbmQodGhpcyksIGZhbHNlKTtcblxuXHR0aGlzLl9zZW5kUGluZygpO1xufTtcblxuQ29tbXVuaWNhdG9yLnByb3RvdHlwZSA9IHtcblx0LyoqXG5cdCAqIEF0dGVtcHQgdG8gcGluZyBzb3VyY2Ugd2luZG93XG5cdCAqL1xuXHRfc2VuZFBpbmc6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHR2YXIgcGluZyA9IHRoaXMuX2NyZWF0ZU1lc3NhZ2UobnVsbCwge1xuXHRcdFx0cGluZzogdGhpcy5pZFxuXHRcdH0pO1xuXG5cdFx0aWYgKCFub2RlKSB7XG5cdFx0XHRpZiAod2luZG93Lm9wZW5lcikge1xuXHRcdFx0XHRub2RlID0gd2luZG93Lm9wZW5lcjtcblx0XHRcdH0gZWxzZSBpZiAod2luZG93LnRvcCAhPT0gd2luZG93KSB7XG5cdFx0XHRcdG5vZGUgPSB3aW5kb3cudG9wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChub2RlKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyh0aGlzLmlkICsgJyA+PiBwaW5nIScpO1xuXHRcdFx0dGhpcy5fcG9zdChub2RlLCBwaW5nKTtcblx0XHR9XG5cdH0sXG5cblx0X3NlbmRQb25nOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0dmFyIHBvbmcgPSB0aGlzLl9jcmVhdGVNZXNzYWdlKG51bGwsIHtcblx0XHRcdHBvbmc6IHRoaXMuaWRcblx0XHR9KTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCdwb25nISA8PCAnICsgdGhpcy5pZCk7XG5cdFx0dGhpcy5fcG9zdChub2RlLCBwb25nKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgc2luZ2xlIGd1ZXN0IGZvciBjb21tdW5pY2F0aW9uIHB1cnBvc2VzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBHdWVzdCBJRC4gVXNlZCB3aGVuIHNlbmRpbmcgbWVzc2FnZXMuXG5cdCAqIEBwYXJhbSB7bWl4ZWR9IGRlc3QgLSBEZXN0aW5hdGlvbiBub2RlLlxuXHQgKi9cblx0cmVnaXN0ZXJHdWVzdEFkZHJlc3M6IGZ1bmN0aW9uKGlkLCBkZXN0KSB7XG5cdFx0aWYgKHR5cGVvZiBkZXN0ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnQ2Fubm90IHJlZ2lzdGVyIGFkZHJlc3MgZm9yICcgKyBpZCArICcuICcgK1xuXHRcdFx0XHQnQSBndWVzdCBhZGRyZXNzIERPTSBub2RlLCB3aW5kb3cgb3IgZnJhbWUgbXVzdCBiZSBkZWZpbmVkLidcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKCEoJ3Bvc3RNZXNzYWdlJyBpbiBkZXN0KSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnQ29tbXVuaWNhdG9yIGNhbm5vdCBzZW5kIG1lc3NhZ2VzIHRvIGRlc3RpbmF0aW9uLiBQbGVhc2UgY2hvb3NlIGFuIEhUTUxFbGVtZW50ICcgK1xuXHRcdFx0XHQndGhhdCBzdXBwb3J0cyB0aGUgcG9zdE1lc3NhZ2UgbWV0aG9kJ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY2hvb3NlIGEgc3RyaW5nLWJhc2VkIElEIGZvciB0aGUgZ3Vlc3QuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVnaXN0ZXIgbG9jYWwgYWRkcmVzcyBmb3IgZ3Vlc3Rcblx0XHR0aGlzLl9zZXRHdWVzdERhdGEoaWQsIHtcblx0XHRcdGlkLFxuXHRcdFx0bm9kZTogZGVzdFxuXHRcdH0pO1xuXG5cdFx0Ly8gc3RhcnQgdGltZXJcblx0XHRpZiAodGhpcy50aW1lcikge1xuXHRcdFx0d2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIG9yIHJlcGxhY2VzIHRoZSBndWVzdCBkYXRhLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBHdWVzdCBJRC5cblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBHdWVzdCBkYXRhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3NldEd1ZXN0RGF0YTogZnVuY3Rpb24oaWQsIGRhdGEpIHtcblx0XHRpZiAoIXRoaXMuX2d1ZXN0c1tpZF0pIHtcblx0XHRcdHRoaXMuX2d1ZXN0c1tpZF0gPSB7XG5cdFx0XHRcdGxpdmU6IGZhbHNlLFxuXHRcdFx0XHRub2RlOiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdE9iamVjdC5hc3NpZ24odGhpcy5fZ3Vlc3RzW2lkXSwgZGF0YSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgZGVmaW5lZCBndWVzdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRvIC0gR3Vlc3QgSUQsIGFzIHN0b3JlZC5cblx0ICogQHBhcmFtIHttaXhlZH0gbWVzc2FnZSAtIEFueSBKUyBjb21wYXRpYmxlIGRhdGEgdG8gc2VuZCBhcyBhIG1lc3NhZ2UuXG5cdCAqL1xuXHRzZW5kOiBmdW5jdGlvbih0bywgbWVzc2FnZSkge1xuXHRcdHZhciBndWVzdCA9IHRoaXMuX2dldEd1ZXN0QnlJZCh0byk7XG5cblx0XHRpZiAoZ3Vlc3QgJiYgZ3Vlc3QubGl2ZSkge1xuXHRcdFx0Ly8gcG9zdCBtZXNzYWdlIGltbWVkaWF0ZWx5XG5cdFx0XHR0aGlzLl9wb3N0KHRvLCB0aGlzLl9jcmVhdGVNZXNzYWdlKG1lc3NhZ2UpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcXVldWUgbWVzc2FnZSBmb3IgcG9zdGluZ1xuXHRcdFx0dGhpcy5fYWRkVG9RdWV1ZSh0bywgbWVzc2FnZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbWVzc2FnZSB0byB0aGUgbG9jYWwgJ291dGJveCcgZm9yIHRoZSBndWVzdCAoYnkgSUQpLlxuXHQgKi9cblx0X2FkZFRvUXVldWU6IGZ1bmN0aW9uKHRvLCBtZXNzYWdlKSB7XG5cdFx0aWYgKCF0aGlzLl9xdWV1ZVt0b10pIHtcblx0XHRcdHRoaXMuX3F1ZXVlW3RvXSA9IFtdO1xuXHRcdH1cblxuXHRcdHRoaXMuX3F1ZXVlW3RvXS5wdXNoKG1lc3NhZ2UpO1xuXHR9LFxuXG5cdF9zZW5kUXVldWU6IGZ1bmN0aW9uKHRvKSB7XG5cdFx0dmFyIGE7XG5cblx0XHRpZiAodGhpcy5fcXVldWVbdG9dICYmIHRoaXMuX2d1ZXN0c1t0b10pIHtcblx0XHRcdC8vIHNlbmQgbWVzc2FnZXMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSBxdWV1ZWRcblx0XHRcdGZvciAoYSA9IDA7IGEgPCB0aGlzLl9xdWV1ZVt0b10ubGVuZ3RoOyBhICs9IDEpIHtcblx0XHRcdFx0dGhpcy5fcG9zdChcblx0XHRcdFx0XHR0aGlzLl9ndWVzdHNbdG9dLm5vZGUsXG5cdFx0XHRcdFx0dGhpcy5fY3JlYXRlTWVzc2FnZSh0aGlzLl9xdWV1ZVt0b11bYV0pXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNsZWFyIHF1ZXVlIGZvciB0aGlzIHJlY2lwaWVudFxuXHRcdFx0dGhpcy5fcXVldWVbdG9dID0gW107XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXRzIGEgY29tbXVuaWNhdG9yIGd1ZXN0IGJ5IGl0cyBJRCwgb3IgcmV0dXJucyBgbnVsbGAuXG5cdCAqIEByZXR1cm5zIHttaXhlZH0gR3Vlc3QgZGF0YSwgb3IgYG51bGxgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldEd1ZXN0QnlJZDogZnVuY3Rpb24oaWQpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ3Vlc3RzW2lkXSB8fCBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYSBndWVzdCBieSBrbm93biBub2RlIChpLmUuIHRoYXQgcmVnaXN0ZXJlZCBpbiBgdGhpcy5fZ3Vlc3RzYClcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRHdWVzdEJ5Tm9kZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdHZhciBpZDtcblxuXHRcdC8vIGNvbnNvbGUuZ3JvdXAoJ19nZXRHdWVzdEJ5Tm9kZScpO1xuXHRcdC8vIGNvbnNvbGUubG9nKCdmaW5kaW5nJywgbm9kZSk7XG5cblx0XHRmb3IgKGlkIGluIHRoaXMuX2d1ZXN0cykge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coaWQsIHRoaXMuX2d1ZXN0c1tpZF0sICh0aGlzLl9ndWVzdHNbaWRdLm5vZGUgPT09IG5vZGUpKTtcblx0XHRcdGlmICh0aGlzLl9ndWVzdHMuaGFzT3duUHJvcGVydHkoaWQpICYmXG5cdFx0XHRcdHRoaXMuX2d1ZXN0c1tpZF0ubm9kZSA9PT0gbm9kZSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnbm9kZSBmb3VuZCEnLCBpZCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9nZXRHdWVzdEJ5SWQoaWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBjb25zb2xlLmdyb3VwRW5kKCk7XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogQWN0dWFsbHkgcG9zdHMgdGhlIG1lc3NhZ2UgdG8gdGhlIGRlc3RpbmF0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdG8gLSBHdWVzdCBJRC5cblx0ICogQHBhcmFtIHttaXhlZH0gbWVzc2FnZSAtIEFueSBKUyBjb21wYXRpYmxlIGRhdGEgdG8gc2VuZCBhcyBhIG1lc3NhZ2UuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcG9zdDogZnVuY3Rpb24odG8sIG1lc3NhZ2UpIHtcblx0XHR2YXIgZ3Vlc3QsIG5vZGU7XG5cblx0XHRpZiAodHlwZW9mIHRvID09PSAnc3RyaW5nJykge1xuXHRcdFx0Z3Vlc3QgPSB0aGlzLl9nZXRHdWVzdEJ5SWQodG8pO1xuXG5cdFx0XHRpZiAoIWd1ZXN0Lm5vZGUpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdDYW5ub3QgY29tbXVuaWNhdGUgd2l0aCBndWVzdCBcIicgKyB0byArICdcIi4gSGFzIGl0cyBOb2RlIGFkZHJlc3MgYmVlbiByZWdpc3RlcmVkPydcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0bm9kZSA9IGd1ZXN0Lm5vZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5vZGUgPSB0bztcblx0XHR9XG5cblx0XHRub2RlLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRoaXMuX29yaWdpbik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEludm9rZWQgd2hlbiBhIGxpdmUgbWVzc2FnZSBpcyByZWNlaXZlZC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZWNlaXZlTWVzc2FnZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgb3JpZ2luID0gZXZlbnQub3JpZ2luIHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQub3JpZ2luLFxuXHRcdFx0c291cmNlID0gZXZlbnQuc291cmNlIHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQuc291cmNlLFxuXHRcdFx0bWVzc2FnZSA9IGV2ZW50LmRhdGEsXG5cdFx0XHRndWVzdDtcblxuXHRcdC8vIGNvbnNvbGUuZ3JvdXAoJ19yZWNlaXZlTWVzc2FnZScpO1xuXHRcdC8vIGNvbnNvbGUubG9nKCd0byBcIicgKyB0aGlzLmlkICsgJ1wiOicsIGV2ZW50LmRhdGEpO1xuXHRcdGlmIChvcmlnaW4gIT09IGxvY2F0aW9uLm9yaWdpbilcblx0XHRcdHJldHVybjtcblxuXHRcdGlmICgobWVzc2FnZS5waW5nIHx8IG1lc3NhZ2UucG9uZykgJiYgdGhpcy5fZ2V0R3Vlc3RCeU5vZGUoc291cmNlKSkge1xuXHRcdFx0Ly8gcmVjZWl2ZWQgYSBwaW5nL3BvbmcgZnJvbSB2YWxpZCBzb3VyY2Vcblx0XHRcdGd1ZXN0ID0gbWVzc2FnZS5waW5nIHx8IG1lc3NhZ2UucG9uZztcblx0XHRcdC8vIGNvbnNvbGUubG9nKHRoaXMuaWQsICdzZXR0aW5nIGd1ZXN0IFwiJywgZ3Vlc3QsICdcIiBsaXZlJyk7XG5cdFx0XHR0aGlzLl9zZXRHdWVzdExpdmUoZ3Vlc3QpO1xuXHRcdFx0dGhpcy5fc2VuZFF1ZXVlKGd1ZXN0KTtcblxuXHRcdFx0aWYgKG1lc3NhZ2UucGluZykge1xuXHRcdFx0XHQvLyBwb25nIGJhY2sgYSBwaW5nIChkb24ndCBwb25nIGEgcG9uZyBvciB3ZSdsbCBiZSBoZXJlIGZvcmV2ZXIpXG5cdFx0XHRcdHRoaXMuX3NlbmRQb25nKHNvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2NhbGxiYWNrcy5tZXNzYWdlICYmIG1lc3NhZ2Uub3JpZ2luYWxNZXNzYWdlKSB7XG5cdFx0XHR0aGlzLl9jYWxsYmFja3MubWVzc2FnZShtZXNzYWdlLm9yaWdpbmFsTWVzc2FnZSk7XG5cdFx0fVxuXG5cdFx0Ly8gY29uc29sZS5ncm91cEVuZCgpO1xuXHR9LFxuXG5cdF9zZXRHdWVzdExpdmU6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0dGhpcy5fc2V0R3Vlc3REYXRhKGlkLCB7XG5cdFx0XHRsaXZlOiB0cnVlXG5cdFx0fSk7XG5cdH0sXG5cblx0X2NyZWF0ZU1lc3NhZ2U6IGZ1bmN0aW9uKG1lc3NhZ2UsIGRhdGEpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSwge1xuXHRcdFx0aG9zdDogdGhpcy5pZCxcblx0XHRcdG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZVxuXHRcdH0pO1xuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb21tdW5pY2F0b3I7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9saWIvQ29tbXVuaWNhdG9yLmpzIiwiaW1wb3J0IERyb3BsZXQgZnJvbSAnLi9Ecm9wbGV0JztcbmltcG9ydCB7IGVycm9yQ29kZXMgfSBmcm9tICcuLi9hc3NldHMvY29uc3RhbnRzJztcblxudmFyIERyb3Bab25lLCBkcm9wX3pvbmVfaWQgPSAwO1xuXG4vKipcbiAqIEBjbGFzc1xuICovXG5Ecm9wWm9uZSA9IGZ1bmN0aW9uKGRhdGEgPSB7fSwgdGFnKSB7XG5cdHRoaXMudGFnID0gdGFnO1xuXHR0aGlzLmlkID0gJ2Ryb3Bfem9uZV8nICsgKytkcm9wX3pvbmVfaWQ7XG5cdHRoaXMuYXR0YWNobWVudElkID0gZGF0YS5hdHRhY2htZW50SWQ7XG5cdHRoaXMubWF4QXR0YWNobWVudHMgPSAodHlwZW9mIGRhdGEubWF4QXR0YWNobWVudHMgIT09ICd1bmRlZmluZWQnID8gZGF0YS5tYXhBdHRhY2htZW50cyA6IDEpO1xufTtcblxuRHJvcFpvbmUucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogVGVzdCBpZiB0aGUgRHJvcFpvbmUgaW5zdGFuY2Ugd2lsbCBhY2NlcHQgYSBuZXcgZHJvcGxldC4gVGhlIHRlc3QgbG9va3MgYXQgdGhlXG5cdCAqIG1heGltdW0gbnVtYmVyIG9mIGF0dGFjaG1lbnRzIGFuZCBhdHRhY2htZW50IGVsaWdpYmlsaXR5IGJhc2VkIG9uIGF0dGFjaG1lbnRJZFxuXHQgKi9cblx0d2lsbEFjY2VwdDogZnVuY3Rpb24oZHJvcGxldCwgc3RvcmUpIHtcblx0XHR2YXIgY3VycmVudF9hdHRhY2htZW50cyA9IDAsXG5cdFx0XHRzdGF0ZTtcblxuXHRcdGlmICghKGRyb3BsZXQgaW5zdGFuY2VvZiBEcm9wbGV0KSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yQ29kZXMuTk9UX0FfRFJPUExFVCk7XG5cdFx0fVxuXG5cdFx0aWYgKHN0b3JlKSB7XG5cdFx0XHQvLyBzdG9yZSBleGlzdHMgLSBnZXQgc3RhdGUgKGFuZCBjdXJyZW50IG51bWJlciBvZiBhdHRhY2htZW50cylcblx0XHRcdHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuXHRcdFx0aWYgKHN0YXRlLnpvbmVzW3RoaXMuaWRdICYmIHN0YXRlLnpvbmVzW3RoaXMuaWRdLmF0dGFjaG1lbnRzKSB7XG5cdFx0XHRcdGN1cnJlbnRfYXR0YWNobWVudHMgPSBzdGF0ZS56b25lc1t0aGlzLmlkXS5hdHRhY2htZW50cy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGVzdCBhdHRhY2htZW50IGNvdW50XG5cdFx0aWYgKHRoaXMubWF4QXR0YWNobWVudHMgIT09IDAgJiYgY3VycmVudF9hdHRhY2htZW50cyA9PT0gdGhpcy5tYXhBdHRhY2htZW50cykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIHRlc3QgYXR0YWNobWVudElkIGVsaWdpYmlsaXR5XG5cdFx0aWYgKHRoaXMuYXR0YWNobWVudElkICE9PSAnKicgJiZcblx0XHRcdGRyb3BsZXQuYXR0YWNobWVudElkcy5pbmRleE9mKHRoaXMuYXR0YWNobWVudElkKSA9PT0gLTEpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufTtcblxuLyoqXG4gKiBNYXRjaGVzIGEgZHJvcCB6b25lIHdpdGhpbiB0aGUgc3VwcGxpZWQgbWFya3VwLlxuICogQ2FuIGJlIHVzZWQgbW9yZSB0aGFuIG9uY2Ugb24gdGhlIHNhbWUgbWFya3VwLCBhbmQgd2lsbCBpbnRlcm5hbGx5IGluY3JlbWVudCB0aHJvdWdoIHRoZSBkYXRhLlxuICovXG5Ecm9wWm9uZS5mZXRjaFpvbmUgPSBmdW5jdGlvbihtYXJrdXApIHtcblx0dmFyIG1hdGNoLCB6b25lO1xuXG5cdC8vIGtlZXAgbG9va2luZyBmb3IgYSB2YWxpZCBkcm9wIHpvbmUgLSByZXBvcnQgb24gdGhlIGJhZCBvbmVzXG5cdHdoaWxlICgobWF0Y2ggPSBEcm9wWm9uZS5fcmVfem9uZXMuZXhlYyhtYXJrdXApKSAhPT0gbnVsbCkge1xuXHRcdGlmIChtYXRjaCAhPT0gbnVsbCAmJiAoem9uZSA9IERyb3Bab25lLmNoZWNrU3ludGF4KG1hdGNoWzBdKSkpIHtcblx0XHRcdC8vIHJldHVybiBpdFxuXHRcdFx0cmV0dXJuIG5ldyBEcm9wWm9uZSh7XG5cdFx0XHRcdGF0dGFjaG1lbnRJZDogem9uZS5hdHRhY2htZW50SWQsXG5cdFx0XHRcdG1heEF0dGFjaG1lbnRzOiB6b25lLm1heEF0dGFjaG1lbnRzXG5cdFx0XHR9LCBtYXRjaFswXSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrcyBhbmQgcmVwb3J0cyBvbiBzeW50YXggZXJyb3JzIHdpdGhpbiBhIHN1cHBsaWVkIHRhZy5cbiAqL1xuRHJvcFpvbmUuY2hlY2tTeW50YXggPSBmdW5jdGlvbih0YWcpIHtcblx0dmFyIGQ7XG5cblx0aWYgKChkID0gdGFnLm1hdGNoKERyb3Bab25lLnN5bnRheF9yZS5yZV9zdHJ1Y3R1cmUpKSAhPT0gbnVsbCAmJiBkWzFdICE9PSBudWxsKSB7XG5cdFx0Ly8gY2hlY2sgaWQgcG9ydGlvblxuXHRcdGlmICghZFsyXSB8fCAhRHJvcFpvbmUuc3ludGF4X3JlLnJlX2lkLnRlc3QoZFsyXSkpIHtcblx0XHRcdHJldHVybiBEcm9wWm9uZS5zbnl0YXhGYXVsdChcblx0XHRcdFx0ZFsxXSxcblx0XHRcdFx0J0ludmFsaWQgc3ludGF4LiBJRCBtdXN0IGVpdGhlciBzdGFydCB3aXRoIGEgbGV0dGVyIGFuZCBvbmx5IGNvbnRhaW4nICtcblx0XHRcdFx0JyBsZXR0ZXJzLCBudW1iZXJzLCBhbmQgdGhlIHVuZGVzY29yZSAoXykgY2hhcmFjdGVyLCBvciBiZSBhbiBhc3RlcmlzayAoKikgJyArXG5cdFx0XHRcdCd0byBzcGVjaWZ5IGFueSBhdHRhY2htZW50IElELicsXG5cdFx0XHRcdGRbMl1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgcXVhbnRpdHkgcG9ydGlvblxuXHRcdGlmIChcblx0XHRcdGRbNF0gJiZcblx0XHRcdChcblx0XHRcdFx0IURyb3Bab25lLnN5bnRheF9yZS5yZV9xdHkudGVzdChkWzRdKSB8fFxuXHRcdFx0XHQoZFs0XSA8IDEgfHwgZFs0XSA+IDEwMClcblx0XHRcdClcblx0XHQpIHtcblx0XHRcdHJldHVybiBEcm9wWm9uZS5zbnl0YXhGYXVsdChcblx0XHRcdFx0ZFsxXSxcblx0XHRcdFx0J0ludmFsaWQgc3ludGF4LiBRdWFudGl0eSBtdXN0IGJlIGEgdmFsaWQgbnVtYmVyIGFuZCBiZXR3ZWVuIDEgYW5kIDEwMCwgJyArXG5cdFx0XHRcdFx0J29yIHRoZSBhc3RlcmlzayAoKikgY2hhcmFjdGVyIHRvIHNwZWNpZnkgdW5saW1pdGVkIHVwIHRvIHRoZSBpbnRlcm5hbCBtYXhpbXVtLicsXG5cdFx0XHRcdGRbNF1cblx0XHRcdCk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBEcm9wWm9uZS5zbnl0YXhGYXVsdCh0YWcsICdJbnZhbGlkIHN5bnRheC4nKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0YXR0YWNobWVudElkOiBkWzJdLFxuXHRcdG1heEF0dGFjaG1lbnRzOiAoZFs0XSA9PT0gJyonID8gMCA6IChwYXJzZUZsb2F0KGRbNF0pIHx8IDEpKVxuXHR9O1xufTtcblxuRHJvcFpvbmUuc255dGF4RmF1bHQgPSBmdW5jdGlvbihzdHIsIG1lc3NhZ2UsIGNoYXIpIHtcblx0dmFyIGVycm9yO1xuXG5cdGlmIChjaGFyKSB7XG5cdFx0Ly8gZXNjYXBlICUgc3ltYm9sc1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKCclJywgJyUlJyk7XG5cdFx0Y2hhciA9IGNoYXIucmVwbGFjZSgnJScsICclJScpO1xuXG5cdFx0Ly8gYWRkIGNvbG91cmluZ1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKGNoYXIsICclYyQmJWMnKTtcblxuXHRcdGVycm9yID0gJ0Vycm9yIHdpdGggc3ludGF4IGluIHRhZyBcIicgKyBzdHIgKyAnXCI6ICcgKyBtZXNzYWdlO1xuXHRcdGNvbnNvbGUud2FybihlcnJvciwgJ2NvbG9yOiByZWQ7JywgJ2NvbG9yOiBpbmhlcml0OycpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIGJhc2ljIGVycm9yIHdpdGggbm8gY29sb3VyaW5nXG5cdFx0ZXJyb3IgPSAnRXJyb3Igd2l0aCBzeW50YXggaW4gdGFnIFwiJyArIHN0ciArICdcIjogJyArIG1lc3NhZ2U7XG5cdFx0Y29uc29sZS53YXJuKGVycm9yKTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRGlzY3JpbWluYXRpbmcgcmVnZXggY29sbGVjdGlvbiBmb3IgdGVzdGluZyBkcm9wIHpvbmVzIHdpdGggZXhwbGljaXQgc3ludGF4LlxuICovXG5Ecm9wWm9uZS5zeW50YXhfcmUgPSB7XG5cdHJlX3N0cnVjdHVyZTogL15cXHtcXHtcXHM/KChbXnxcXHNdKykoXFx8KFtefFxcc10qKSk/KVxccz9cXH1cXH0kLyxcblx0cmVfaWQ6IC9eW2EteipdW2EtejAtOV9dKiQvaSxcblx0cmVfcXR5OiAvXlswLTkqXSskL1xufTtcblxuLyoqXG4gKiBJbmNsdXNpdmUgcmVnZXggZm9yIGNhcHR1cmluZyBpbmRpdmlkdWFsIHpvbmVzIHdpdGggYmFzaWMgc3ludGF4XG4gKi9cbkRyb3Bab25lLl9yZV96b25lcyA9IC9cXHtcXHtcXHM/KC4rPykoXFx8KC4qPykpP1xccz9cXH1cXH0vZ2k7XG5cbmV4cG9ydCBkZWZhdWx0IERyb3Bab25lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvbGliL0Ryb3Bab25lLmpzIiwiaW1wb3J0IHsgYWN0aW9uVHlwZXMgfSBmcm9tICcuLi9hc3NldHMvY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRzZXRVSVN0YXRlOiBmdW5jdGlvbih1aV9zdGF0ZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBhY3Rpb25UeXBlcy5VSV9TVEFURSxcblx0XHRcdHVpX3N0YXRlXG5cdFx0fTtcblx0fSxcblxuXHRzZXRBY3RpdmVEcm9wbGV0OiBmdW5jdGlvbihkcm9wbGV0X2lkKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IGFjdGlvblR5cGVzLlNFVF9BQ1RJVkVfRFJPUExFVCxcblx0XHRcdGRyb3BsZXRfaWRcblx0XHR9O1xuXHR9LFxuXG5cdHNldERpYWxvZ01vZGU6IGZ1bmN0aW9uKG1vZGUsIHN0YXRlID0ge30pIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogYWN0aW9uVHlwZXMuU0VUX0RJQUxPR19NT0RFLFxuXHRcdFx0bW9kZSxcblx0XHRcdHN0YXRlXG5cdFx0fTtcblx0fSxcblxuXHR6b25lQWRkQXR0YWNobWVudDogZnVuY3Rpb24oaWQsIGRyb3BsZXRfaWQsIGF0dGFjaGVkLCBkYXRhKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IGFjdGlvblR5cGVzLlpPTkVfQUREX0FUVEFDSE1FTlQsXG5cdFx0XHRpZCxcblx0XHRcdGRyb3BsZXRfaWQsXG5cdFx0XHRhdHRhY2hlZCxcblx0XHRcdGRhdGFcblx0XHR9O1xuXHR9LFxuXG5cdHpvbmVFZGl0QXR0YWNobWVudDogZnVuY3Rpb24oaWQsIGF0dGFjaG1lbnRfaW5kZXgsIGRhdGEpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogYWN0aW9uVHlwZXMuWk9ORV9FRElUX0FUVEFDSE1FTlQsXG5cdFx0XHRpZCxcblx0XHRcdGF0dGFjaG1lbnRfaW5kZXgsXG5cdFx0XHRkYXRhXG5cdFx0fTtcblx0fSxcblxuXHR6b25lRGV0YWNoQXR0YWNobWVudDogZnVuY3Rpb24oaWQsIGF0dGFjaG1lbnRfaW5kZXgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogYWN0aW9uVHlwZXMuWk9ORV9ERVRBQ0hfQVRUQUNITUVOVCxcblx0XHRcdGlkLFxuXHRcdFx0YXR0YWNobWVudF9pbmRleFxuXHRcdH07XG5cdH0sXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbmpwLXRhZy9zcmMvc3RhdGUvYWN0aW9ucy5qcyIsInZhciBTcHJpdGUgPSByZXF1aXJlKCcuL3Nwcml0ZScpO1xudmFyIGdsb2JhbFNwcml0ZSA9IG5ldyBTcHJpdGUoKTtcblxuaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgZ2xvYmFsU3ByaXRlLmVsZW0gPSBnbG9iYWxTcHJpdGUucmVuZGVyKGRvY3VtZW50LmJvZHkpO1xufSBlbHNlIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBnbG9iYWxTcHJpdGUuZWxlbSA9IGdsb2JhbFNwcml0ZS5yZW5kZXIoZG9jdW1lbnQuYm9keSk7XG4gIH0sIGZhbHNlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxTcHJpdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3ZnLXNwcml0ZS1sb2FkZXIvbGliL3dlYi9nbG9iYWwtc3ByaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBGb3JtRmllbGQgZnJvbSAnLi4vbGliL0Zvcm1GaWVsZCc7XG5cbmV4cG9ydCBjb25zdCBmaWVsZCA9IHtcblx0ZmllbGQ6IFByb3BUeXBlcy5pbnN0YW5jZU9mKEZvcm1GaWVsZCkuaXNSZXF1aXJlZCxcblx0dmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuXHRcdFByb3BUeXBlcy5zdHJpbmcsXG5cdFx0UHJvcFR5cGVzLm51bWJlcixcblx0XHRQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKVxuXHRdKS5pc1JlcXVpcmVkLFxuXHRvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmNcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9hc3NldHMvY29tbW9uLXByb3AtdHlwZXMuanMiLCJpbXBvcnQgcmVxdWVzdCBmcm9tICcuL2FqYXgnO1xuaW1wb3J0IERyb3Bab25lIGZyb20gJy4vRHJvcFpvbmUnO1xuaW1wb3J0IERyb3BsZXQgZnJvbSAnLi9Ecm9wbGV0JztcblxudmFyIFRlbXBsYXRlID0gZnVuY3Rpb24ocGFyZW50LCBzZXR0aW5ncyA9IHt9KSB7XG5cdHRoaXMuX3BhcmVudCA9IHBhcmVudDtcblx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXHR0aGlzLl9kcm9wX3pvbmVzID0ge307XG5cdHRoaXMuX3RlbXBsYXRlID0gW107XG5cdHRoaXMuX21heF96b25lcyA9IDEwMDtcbn07XG5cblRlbXBsYXRlLnByb3RvdHlwZSA9IHtcblx0bG9hZDogZnVuY3Rpb24odXJsKSB7XG5cdFx0cmV0dXJuIHJlcXVlc3QuZ2V0KHVybClcblx0XHRcdC50aGVuKChyZXNwb25zZSkgPT4ge1xuXHRcdFx0XHRpZiAocmVzcG9uc2UudGV4dCkge1xuXHRcdFx0XHRcdHRoaXMuX21hcmt1cCA9IHJlc3BvbnNlLnRleHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goKGVycm9yKSA9PiB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihlcnJvcik7XG5cdFx0XHR9KTtcblx0fSxcblxuXHRjcmVhdGU6IGZ1bmN0aW9uKG1hcmt1cCA9IHRoaXMuX21hcmt1cCkge1xuXHRcdGlmICh0eXBlb2YgbWFya3VwID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBjcmVhdGUoKSB3aXRoIG5vIG1hcmt1cCBkZWZpbmVkLicpO1xuXHRcdH1cblxuXHRcdC8vIHJlcGxhY2UgaHRtbCB3aXRoIGVudGl0aWVzXG5cdFx0bWFya3VwID0gVGVtcGxhdGUuZW50aXRpZXMobWFya3VwKTtcblxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVEcm9wWm9uZXMobWFya3VwKTtcblx0fSxcblxuXHRfY3JlYXRlRHJvcFpvbmVzOiBmdW5jdGlvbihtYXJrdXApIHtcblx0XHR2YXIgem9uZSwgY291bnRlciA9IDA7XG5cblx0XHQvLyBsb29wIHRocm91Z2ggbWFya3VwIGZpbmRpbmcgZHJvcCB6b25lc1xuXHRcdHdoaWxlICgoem9uZSA9IERyb3Bab25lLmZldGNoWm9uZShtYXJrdXApKSAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fZHJvcF96b25lc1t6b25lLmlkXSA9IHpvbmU7XG5cdFx0XHRjb3VudGVyICs9IDE7XG5cblx0XHRcdGlmIChjb3VudGVyID09PSB0aGlzLl9tYXhfem9uZXMpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdNYXhpbXVtIG51bWJlciBvZiB6b25lcyBpbiB0ZW1wbGF0ZSByZWFjaGVkICgnICsgdGhpcy5fbWF4X3pvbmVzICsgJykuJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGxvb3AgdGhyb3VnaCBjb2xsZWN0ZWQgZHJvcCB6b25lcyBhbmQgcmVwbGFjZSB0YWdzIGluIG1hcmt1cFxuXHRcdGZvciAoem9uZSBpbiB0aGlzLl9kcm9wX3pvbmVzKSB7XG5cdFx0XHRtYXJrdXAgPSBtYXJrdXAucmVwbGFjZShcblx0XHRcdFx0dGhpcy5fZHJvcF96b25lc1t6b25lXS50YWcsXG5cdFx0XHRcdCc8c3BhbicgK1xuXHRcdFx0XHRcdCcgZGF0YS1pZD1cIicgKyB0aGlzLl9kcm9wX3pvbmVzW3pvbmVdLmlkICsgJ1wiJyArXG5cdFx0XHRcdFx0JyBkYXRhLWF0dGFjaG1lbnQ9XCInICsgdGhpcy5fZHJvcF96b25lc1t6b25lXS5hdHRhY2htZW50SWQgKyAnXCI+JyArXG5cdFx0XHRcdCc8L3NwYW4+J1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLl90ZW1wbGF0ZSA9IHRoaXMuX2NyZWF0ZVRlbXBsYXRlQXJyYXkobWFya3VwKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRkcm9wX3pvbmVzOiB0aGlzLl9kcm9wX3pvbmVzLFxuXHRcdFx0dGVtcGxhdGU6IHRoaXMuX3RlbXBsYXRlXG5cdFx0fTtcblx0fSxcblxuXHRfY3JlYXRlVGVtcGxhdGVBcnJheTogZnVuY3Rpb24obWFya3VwKSB7XG5cdFx0dmFyIHNhbmRib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHRcdGRhdGEgPSBbXTtcblx0XHRzYW5kYm94LmlubmVySFRNTCA9IG1hcmt1cDtcblxuXHRcdHNhbmRib3guY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG5cdFx0XHRzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcblx0XHRcdGNhc2UgTm9kZS5URVhUX05PREU6XG5cdFx0XHRcdGRhdGEucHVzaCh7XG5cdFx0XHRcdFx0dHlwZTogJ3RleHQnLFxuXHRcdFx0XHRcdGNvbnRlbnQ6IG5vZGUudGV4dENvbnRlbnRcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuXHRcdFx0XHRkYXRhLnB1c2goe1xuXHRcdFx0XHRcdHR5cGU6ICdkcm9wem9uZScsXG5cdFx0XHRcdFx0em9uZTogdGhpcy5fZHJvcF96b25lc1tub2RlLmRhdGFzZXQuaWRdXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBkYXRhO1xuXHR9LFxuXG5cdHJlbmRlckFzSFRNTDogZnVuY3Rpb24oem9uZXMpIHtcblx0XHR2YXIgaHRtbCA9ICcnO1xuXG5cdFx0dGhpcy5fdGVtcGxhdGUuZm9yRWFjaCgobm9kZSkgPT4ge1xuXHRcdFx0aWYgKG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG5cdFx0XHRcdC8vIHBsYWluIHRleHQgbm9kZVxuXHRcdFx0XHRodG1sICs9IG5vZGUuY29udGVudDtcblx0XHRcdH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnZHJvcHpvbmUnICYmIHpvbmVzW25vZGUuem9uZS5pZF0pIHtcblx0XHRcdFx0Ly8gZHJvcCB6b25lIHdpdGggYXR0YWNobWVudHNcblx0XHRcdFx0em9uZXNbbm9kZS56b25lLmlkXS5hdHRhY2htZW50cy5mb3JFYWNoKChhdHRhY2htZW50KSA9PiB7XG5cdFx0XHRcdFx0dmFyIGRyb3BsZXQgPSB0aGlzLl9wYXJlbnQuX1VJLmdldERyb3BsZXRCeUlkKGF0dGFjaG1lbnQuZHJvcGxldF9pZCksXG5cdFx0XHRcdFx0XHRkYXRhID0gT2JqZWN0LmRlZXBBc3NpZ24oe30sIGRyb3BsZXQuZGF0YSwgYXR0YWNobWVudC5kYXRhKTtcblxuXHRcdFx0XHRcdGh0bWwgKz0gVGVtcGxhdGUucmVuZGVyRHJvcGxldChcblx0XHRcdFx0XHRcdGRyb3BsZXQsXG5cdFx0XHRcdFx0XHRkYXRhLFxuXHRcdFx0XHRcdFx0dGhpcy5fcGFyZW50Ll9VSS5nZXREcm9wWm9uZUJ5SWQobm9kZS56b25lLmlkKSxcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Mub25FbGVtZW50UmVuZGVyXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gaHRtbDtcblx0fVxufTtcblxuVGVtcGxhdGUucmVuZGVyRHJvcGxldCA9IGZ1bmN0aW9uKGRyb3BsZXQsIGRhdGEsIGRyb3Bfem9uZSwgaXNfb3V0cHV0ID0gdHJ1ZSkge1xuXHR2YXIgb3V0cHV0O1xuXG5cdGlmICghKGRyb3BsZXQgaW5zdGFuY2VvZiBEcm9wbGV0KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZHJvcGxldCBhcmd1bWVudCBtdXN0IGJlIGEgRHJvcGxldCBpbnN0YW5jZScpO1xuXHR9XG5cblx0c3dpdGNoIChkcm9wbGV0LmRyb3BsZXRUeXBlKSB7XG5cdGNhc2UgJ2VsZW1lbnQnOlxuXHRcdG91dHB1dCA9IFRlbXBsYXRlLnJlbmRlckVsZW1lbnREcm9wbGV0KGRhdGEsIGRyb3BsZXQsIGRyb3Bfem9uZSwgaXNfb3V0cHV0KTtcblx0XHRicmVhaztcblxuXHRjYXNlICd0ZXh0Jzpcblx0XHRvdXRwdXQgPSBUZW1wbGF0ZS5yZW5kZXJUZXh0RHJvcGxldChkYXRhLCBkcm9wbGV0LCBkcm9wX3pvbmUsIGlzX291dHB1dCk7XG5cdFx0YnJlYWs7XG5cblx0Y2FzZSAnYXR0cmlidXRlJzpcblx0XHRvdXRwdXQgPSBUZW1wbGF0ZS5yZW5kZXJBdHRyaWJ1dGVEcm9wbGV0KGRhdGEsIGRyb3BsZXQsIGRyb3Bfem9uZSwgaXNfb3V0cHV0KTtcblx0XHRicmVhaztcblx0fVxuXG5cdHJldHVybiBvdXRwdXQ7XG59O1xuXG5UZW1wbGF0ZS5yZW5kZXJFbGVtZW50RHJvcGxldCA9IGZ1bmN0aW9uKGRhdGEsIGRyb3BsZXQsIGRyb3Bfem9uZSwgaXNfb3V0cHV0KSB7XG5cdC8vICFUT0RPIC0gbWFrZSBzdXJlIHNlbGYtY2xvc2luZyB0YWdzIGFyZSBjb3JyZWN0bHkgcmVuZGVyZWRcblx0dmFyIGF0dHJzID0gW10sXG5cdFx0bWFya3VwID0ge30sXG5cdFx0YXR0cjtcblxuXHRtYXJrdXAub3BlbiA9ICc8JyArIGRhdGEudGFnTmFtZTtcblxuXHRpZiAoZGF0YS5hdHRycykge1xuXHRcdGZvciAoYXR0ciBpbiBkYXRhLmF0dHJzKSB7XG5cdFx0XHRhdHRycy5wdXNoKGF0dHIgKz0gJz1cIicgKyBUZW1wbGF0ZS5lbnRpdGllcyhkYXRhLmF0dHJzW2F0dHJdKSArICdcIicpO1xuXHRcdH1cblxuXHRcdGlmIChhdHRycy5sZW5ndGgpIHtcblx0XHRcdG1hcmt1cC5vcGVuICs9ICcgJyArIGF0dHJzLmpvaW4oJyAnKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoZGF0YS5pbm5lckhUTUwgfHwgVGVtcGxhdGUuY29udGFpbmVyVGFncy5pbmRleE9mKGRhdGEudGFnTmFtZSkgIT09IC0xKSB7XG5cdFx0bWFya3VwLm9wZW4gKz0gJz4nO1xuXHRcdG1hcmt1cC5pbm5lckhUTUwgPSAoZGF0YS5pbm5lckhUTUwgfHwgJycpO1xuXHRcdG1hcmt1cC5jbG9zZSA9ICc8LycgKyBkYXRhLnRhZ05hbWUgKyAnPic7XG5cdH0gZWxzZSB7XG5cdFx0bWFya3VwLmNsb3NlID0gJy8+Jztcblx0fVxuXG5cdG1hcmt1cCA9IFRlbXBsYXRlLm9uRWxlbWVudFJlbmRlcihcblx0XHRtYXJrdXAsXG5cdFx0ZHJvcGxldCxcblx0XHRkcm9wX3pvbmUsXG5cdFx0aXNfb3V0cHV0XG5cdCk7XG5cblx0cmV0dXJuIG1hcmt1cC5vcGVuICsgbWFya3VwLmlubmVySFRNTCArIG1hcmt1cC5jbG9zZTtcbn07XG5cblRlbXBsYXRlLnJlbmRlclRleHREcm9wbGV0ID0gZnVuY3Rpb24oZGF0YSwgZHJvcGxldCwgZHJvcF96b25lLCBpc19vdXRwdXQpIHtcblx0dmFyIHZhbHVlID0gVGVtcGxhdGUub25FbGVtZW50UmVuZGVyKFxuXHRcdGRhdGEudmFsdWUsXG5cdFx0ZHJvcGxldCxcblx0XHRkcm9wX3pvbmUsXG5cdFx0aXNfb3V0cHV0XG5cdCk7XG5cblx0cmV0dXJuIFRlbXBsYXRlLmVudGl0aWVzKHZhbHVlKTtcbn07XG5cblRlbXBsYXRlLnJlbmRlckF0dHJpYnV0ZURyb3BsZXQgPSBmdW5jdGlvbihkYXRhLCBkcm9wbGV0LCBkcm9wX3pvbmUsIGlzX291dHB1dCkge1xuXHR2YXIgbWFya3VwID0ge1xuXHRcdGtleTogZGF0YS5rZXksXG5cdFx0dmFsdWU6IGRhdGEudmFsdWVcblx0fTtcblxuXHRtYXJrdXAgPSBUZW1wbGF0ZS5vbkVsZW1lbnRSZW5kZXIoXG5cdFx0bWFya3VwLFxuXHRcdGRyb3BsZXQsXG5cdFx0ZHJvcF96b25lLFxuXHRcdGlzX291dHB1dFxuXHQpO1xuXG5cdHJldHVybiBtYXJrdXAua2V5ICsgJz1cIicgKyBUZW1wbGF0ZS5lbnRpdGllcyhtYXJrdXAudmFsdWUpICsgJ1wiJztcbn07XG5cblRlbXBsYXRlLmVudGl0aWVzID0gZnVuY3Rpb24oc3RyKSB7XG5cdHJldHVybiBzdHIucmVwbGFjZSgvW1xcdTAwQTAtXFx1OTk5OTw+XFwmXS9naW0sIChpKSA9PlxuXHRcdCgnJiMnICsgaS5jaGFyQ29kZUF0KDApICsgJzsnKVxuXHQpO1xufTtcblxuVGVtcGxhdGUub25FbGVtZW50UmVuZGVyID0gZnVuY3Rpb24obWFya3VwLCBkcm9wbGV0LCB6b25lLCBpc19vdXRwdXQpIHtcblx0cmV0dXJuIG1hcmt1cDtcbn07XG5cblRlbXBsYXRlLmNvbnRhaW5lclRhZ3MgPSBbJ2EnXTtcblxuZXhwb3J0IGRlZmF1bHQgVGVtcGxhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9saWIvVGVtcGxhdGUuanMiLCJpbXBvcnQgcHJvbWlzZSBmcm9tICdwcm9taXNlJztcbmltcG9ydCBzdXBlcmFnZW50IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0IHN1cGVyYWdlbnRfcHJvbWlzZSBmcm9tICdzdXBlcmFnZW50LXByb21pc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBzdXBlcmFnZW50X3Byb21pc2Uoc3VwZXJhZ2VudCwgcHJvbWlzZSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9uanAtdGFnL3NyYy9saWIvYWpheC5qcyIsImV4cG9ydCBjb25zdCBhY3Rpb25UeXBlcyA9IHtcblx0VUlfU1RBVEU6ICd1aS1zdGF0ZScsXG5cdFpPTkVfQUREX0FUVEFDSE1FTlQ6ICd6b25lLWFkZC1hdHRhY2htZW50Jyxcblx0Wk9ORV9FRElUX0FUVEFDSE1FTlQ6ICd6b25lLWVkaXQtYXR0YWNobWVudCcsXG5cdFpPTkVfREVUQUNIX0FUVEFDSE1FTlQ6ICd6b25lLWRldGFjaC1hdHRhY2htZW50Jyxcblx0U0VUX0RJQUxPR19NT0RFOiAnc2V0LWRpYWxvZy1tb2RlJyxcblx0U0VUX0FDVElWRV9EUk9QTEVUOiAnc2V0LWFjdGl2ZS1kcm9wbGV0J1xufTtcblxuZXhwb3J0IGNvbnN0IGRpYWxvZ01vZGVzID0ge1xuXHROT05FOiAnbm9uZScsXG5cdEVESVRfRFJPUExFVDogJ2VkaXQtZHJvcGxldCdcbn07XG5cbmV4cG9ydCBjb25zdCB1aVN0YXRlcyA9IHtcblx0SU5JVElBTElTSU5HOiAnaW5pdGlhbGlzaW5nJyxcblx0QUNUSVZFOiAnYWN0aXZlJ1xufTtcblxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VDb21tYW5kcyA9IHtcblx0UkVMT0FEOiAncmVsb2FkJ1xufTtcblxuZXhwb3J0IGNvbnN0IGVycm9yQ29kZXMgPSB7XG5cdE5PVF9BX0RST1BMRVQ6ICdBIHZhbGlkIERyb3BsZXQgaW5zdGFuY2UgbXVzdCBiZSBwYXNzZWQgdG8gRHJvcFpvbmUjd2lsbEFjY2VwdC4nXG59O1xuXG5leHBvcnQgY29uc3Qgc2V0TGFiZWxzID0ge1xuXHR2YWx1ZTogJ1ZhbHVlJyxcblx0YXR0cnM6ICdBdHRyaWJ1dGVzJyxcblx0dGFnTmFtZTogJ1RhZyBuYW1lJyxcblx0aW5uZXJIVE1MOiAnSFRNTCBjb250ZW50J1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25qcC10YWcvc3JjL2Fzc2V0cy9jb25zdGFudHMuanMiXSwic291cmNlUm9vdCI6IiJ9